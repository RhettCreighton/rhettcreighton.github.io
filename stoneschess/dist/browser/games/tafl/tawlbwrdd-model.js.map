{"version":3,"names":[],"mappings":"","sources":["tafl-model.js"],"sourcesContent":["/*\n * Copyright (c) 2013 - Jocly - www.jocly.com - All rights reserved\n */\n\n(function() {\n\t\n\tvar SIZE; // the actual board size\n\t\n\t// pos to [column,row]\n\tfunction Cr(pos) {\n\t\tvar c=pos%SIZE;\n\t\treturn [c,(pos-c)/SIZE];\n\t}\n\t\n\t//  column, row to pos\n\tfunction Pos(c,r) {\n\t\treturn r*SIZE+c;\n\t}\n\t\n\tfunction DistBorder(pos) {\n\t\tvar cr=Cr(pos);\n\t\treturn Math.min(cr[0],cr[1],SIZE-cr[0]-1,SIZE-cr[1]-1);\n\t}\n\t\n\tModel.Game.InitGame = function() {\n\t\tvar $this=this;\n\t\tSIZE=this.mOptions.centerDistance*2+1; \n\t\tvar directions=[[0,-1],[1,0],[0,1],[-1,0]]; // dx, dy\n\t\tthis.g.attackersCount=this.mOptions.initial.attackers.length;\n\t\tthis.g.defendersCount=this.mOptions.initial.defenders.soldiers.length;\n\n\t\tthis.g.excludeMap={};\n\t\tthis.mOptions.exclude.forEach(function(pos) {\n\t\t\t$this.g.excludeMap[pos]=true;\n\t\t});\n\t\t\n\t\tthis.g.home=this.mOptions.initial.defenders.king;\n\n\t\tthis.g.Graph=[];\n\t\tthis.g.borders={};\n\t\t\n\t\tfor(var pos=0;pos<SIZE*SIZE;pos++) {\n\t\t\tvar graph=[];\n\t\t\tvar cr=Cr(pos);\n\t\t\tdirections.forEach(function(dir) {\n\t\t\t\tvar x=cr[0]+dir[0];\n\t\t\t\tif(x<0 || x>=SIZE) {\n\t\t\t\t\tgraph.push(null);\n\t\t\t\t\t$this.g.borders[pos]=true;\n\t\t\t\t} else {\n\t\t\t\t\tvar y=cr[1]+dir[1];\n\t\t\t\t\tif(y<0 || y>=SIZE) {\n\t\t\t\t\t\tgraph.push(null);\n\t\t\t\t\t\t$this.g.borders[pos]=true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar pos1=Pos(x,y);\n\t\t\t\t\t\tif($this.g.excludeMap[pos1])\n\t\t\t\t\t\t\tgraph.push(null)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgraph.push(pos1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.g.Graph.push(graph);\n\t\t}\n\t\t\n\t\tthis.zobrist=new JocGame.Zobrist({\n\t\t\tboard: {\n\t\t\t\ttype: \"array\",\n\t\t\t\tsize: SIZE*SIZE,\n\t\t\t\tvalues: ['s1','s-1','k1','k-1'],\n\t\t\t}\n\t\t});\n\t}\n\t\n\tModel.Move.Init = function(args) {\n\t\tvar $this=this;\n\t\tthis.f=args.f;\n\t\tthis.t=args.t;\n\t\tthis.c=[];\n\t\tif(args.c)\n\t\t\tfor(var ci=0;ci<args.c.length;ci++)\n\t\t\t\t$this.c.push(args.c[ci]);\n\t}\n\t\n\tModel.Move.CopyFrom=function(move) {\n\t\tthis.Init(move);\n\t}\n\t\n\tModel.Move.ToString=function() {\n\t\tvar str=this.f+\">\"+this.t;\n\t\tif(this.c.length>0)\n\t\t\tstr+=\"x\"+this.c.join(\",\");\n\t\treturn str;\n\t}\n\t\n\tModel.Board.Init = function(aGame) {\n\t\tthis.zSign=0;\n\t}\n\t\n\tModel.Board.InitialPosition = function(aGame) {\n\t\tvar $this=this;\n\t\tthis.board=[];\n\t\tthis.pieces=[];\n\t\tfor(var pos=0;pos<SIZE*SIZE;pos++)\n\t\t\tthis.board.push(-1);\n\t\tfunction AddPiece(pos,side,type) {\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",type+side,pos);\n\t\t\t$this.board[pos]=$this.pieces.length;\n\t\t\t$this.pieces.push({\n\t\t\t\ti: $this.pieces.length,\n\t\t\t\tp: pos,\n\t\t\t\ts: side,\n\t\t\t\tt: type,\n\t\t\t});\n\t\t}\n\t\tvar attackersSide=aGame.mOptions.attackers;\n\t\tAddPiece(aGame.mOptions.initial.defenders.king,-attackersSide,'k');\n\t\tvar defenders=aGame.mOptions.initial.defenders.soldiers;\n\t\tthis.defendersCount=0;\n\t\tfor(var i=0;i<defenders.length;i++) {\n\t\t\tAddPiece(defenders[i],-attackersSide,'s');\n\t\t\tthis.defendersCount++;\n\t\t}\n\t\tthis.defendersCount=defenders.length;\n\t\tvar attackers=aGame.mOptions.initial.attackers;\n\t\tthis.attackersCount=0;\n\t\tfor(var i=0;i<attackers.length;i++) {\n\t\t\tAddPiece(attackers[i],attackersSide,'s');\n\t\t\tvar cr=Cr(attackers[i]);\n\t\t\tthis.attackersCount++;\n\t\t}\n\t}\n\n\tModel.Board.CopyFrom = function(aBoard) {\n\t\tvar $this=this;\n\t\tthis.board=[];\n\t\tvar board0=aBoard.board;\n\t\tfor(var pos=0;pos<board0.length;pos++)\n\t\t\t$this.board.push(board0[pos]);\n\t\tthis.pieces=[];\n\t\tvar pieces0=aBoard.pieces;\n\t\tfor(var pi=0;pi<pieces0.length;pi++) {\n\t\t\tvar piece=pieces0[pi];\n\t\t\t$this.pieces.push({\n\t\t\t\ti: piece.i,\n\t\t\t\tp: piece.p,\n\t\t\t\ts: piece.s,\n\t\t\t\tt: piece.t,\n\t\t\t});\n\t\t};\n\t\tthis.defendersCount=aBoard.defendersCount;\n\t\tthis.attackersCount=aBoard.attackersCount;\n\t\tthis.mWho=aBoard.mWho;\n\t\tthis.zSign=aBoard.zSign;\n\t}\n\t\n\tModel.Board.GenerateMoves = function(aGame) {\n\t\tvar $this=this;\n\t\tvar moves=[];\n\t\tfor(var pi=0;pi<this.pieces.length;pi++) {\n\t\t\tvar piece=this.pieces[pi];\n\t\t\tif(piece.s!=$this.mWho || piece.p<0)\n\t\t\t\tcontinue;\n\t\t\tfor(var dir=0;dir<4;dir++) {\n\t\t\t\tvar pos=aGame.g.Graph[piece.p][dir];\n\t\t\t\twhile(pos!=null) {\n\t\t\t\t\tvar index1=$this.board[pos];\n\t\t\t\t\tif(index1<0 && (pos!=aGame.g.home || !aGame.mOptions.privateHome || piece.t=='k')) {\n\t\t\t\t\t\tvar move={\n\t\t\t\t\t\t\tf: piece.p,\n\t\t\t\t\t\t\tt: pos,\n\t\t\t\t\t\t\tc: [],\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(var dir2=0;dir2<4;dir2++) {\n\t\t\t\t\t\t\tvar pos2=aGame.g.Graph[pos][dir2];\n\t\t\t\t\t\t\tif(pos2!=null) {\n\t\t\t\t\t\t\t\tvar index2=$this.board[pos2];\n\t\t\t\t\t\t\t\tif(index2>=0) {\n\t\t\t\t\t\t\t\t\tvar piece2=$this.pieces[index2];\n\t\t\t\t\t\t\t\t\tif(piece2.s==-piece.s) {\n\t\t\t\t\t\t\t\t\t\tif(piece2.t=='k') {\n\t\t\t\t\t\t\t\t\t\t\tfor(var dir3=0;dir3<4;dir3++) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar pos3=aGame.g.Graph[pos2][dir3];\n\t\t\t\t\t\t\t\t\t\t\t\tif(pos3==null)\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tvar index3=$this.board[pos3];\n\t\t\t\t\t\t\t\t\t\t\t\tif(index3<0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(pos3!=pos && (pos3!=aGame.g.home || !aGame.mOptions.homeCatch))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar piece3=$this.pieces[index3];\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(piece3.s==piece2.s)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(dir3==4)\n\t\t\t\t\t\t\t\t\t\t\t\tmove.c.push(pos2);\n\t\t\t\t\t\t\t\t\t\t} else { // piece2.t=='s'\n\t\t\t\t\t\t\t\t\t\t\tvar pos3=aGame.g.Graph[pos2][dir2];\n\t\t\t\t\t\t\t\t\t\t\tif(pos3!=null) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar index3=$this.board[pos3];\n\t\t\t\t\t\t\t\t\t\t\t\tif(pos3==aGame.g.home && aGame.mOptions.homeCatch)\n\t\t\t\t\t\t\t\t\t\t\t\t\tmove.c.push(pos2);\n\t\t\t\t\t\t\t\t\t\t\t\telse if(index3>=0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar piece3=$this.pieces[index3];\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(piece3.s==piece.s)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmove.c.push(pos2);\n\t\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmoves.push(move);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(!aGame.mOptions.longMove)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpos=aGame.g.Graph[pos][dir];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.mMoves=moves;\n\t}\n\t\n\tModel.Board.Evaluate = function(aGame) {\n\t\tvar debug=arguments[3]==\"debug\";\n\t\tthis.mEvaluation=0;\n\t\tif(this.pieces[0].p<0) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=aGame.mOptions.attackers;\n\t\t\treturn;\n\t\t}\n\t\tif(this.pieces[0].p in aGame.g.borders) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=-aGame.mOptions.attackers;\n\t\t\treturn;\n\t\t}\n\t\tif(aGame.GetRepeatOccurence(this)>2) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar posKing=this.pieces[0].p;\n\t\tvar crKing=Cr(posKing);\n\t\tvar distKing=0\n\t\tfor(var i=aGame.mOptions.initial.attackers.length+1;i<this.pieces.length;i++) {\n\t\t\tvar piece=this.pieces[i];\n\t\t\tif(piece.p>=0) {\n\t\t\t\tvar cr=Cr(piece.p);\n\t\t\t\tvar dist=Math.max(Math.abs(cr[0]-crKing[0]),Math.abs(cr[1]-crKing[1]));\n\t\t\t\tdistKing+=dist;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// metric based on the pathes the king may take to reach borders\n\t\t// plus, empty squares area from king\n\t\tvar pool={},poolDone={};\n\t\tpool[posKing]=1;\n\t\tvar poolCount=1;\n\t\tvar kingPath=0;\n\t\tvar kingFreedom=0;\n\t\twhile(poolCount>0) {\n\t\t\tvar nextPool={};\n\t\t\tpoolCount=0;\n\t\t\tfor(var pos in pool) {\n\t\t\t\tvar posValue=pool[pos];\n\t\t\t\tvar deltaPosValue=posValue/4;\n\t\t\t\tvar graph=aGame.g.Graph[pos];\n\t\t\t\tfor(var dir=0;dir<4;dir++) {\n\t\t\t\t\tvar pos1=graph[dir];\n\t\t\t\t\twhile(pos1) {\n\t\t\t\t\t\tif(this.board[pos1]>=0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif(!(pos1 in poolDone) && !(pos1 in pool)) {\n\t\t\t\t\t\t\tif(pos1 in aGame.g.borders)\n\t\t\t\t\t\t\t\tkingPath+=posValue;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif(!(pos1 in nextPool)) {\n\t\t\t\t\t\t\t\t\tkingFreedom++;\n\t\t\t\t\t\t\t\t\tpoolCount++;\n\t\t\t\t\t\t\t\t\tnextPool[pos1]=deltaPosValue;\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tnextPool[pos1]+=deltaPosValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!aGame.mOptions.longMove)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tpos1=aGame.g.Graph[pos1][dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpoolDone[pos]=posValue;\n\t\t\t}\n\t\t\tpool=nextPool;\n\t\t}\n\t\t\n\t\tvar evalValues={\n\t\t\t\"attackersCount\": this.attackersCount,\n\t\t\t\"defendersCount\": this.defendersCount,\n\t\t\t\"kingPath\": kingPath,\n\t\t\t\"kingFreedom\": kingFreedom,\n\t\t\t\"distKing\": distKing,\n\t\t}\n\t\t\n\t\tvar evParams=aGame.mOptions.levelOptions;\n\t\tfor(var name in evalValues) {\n\t\t\tvar value=evalValues[name];\n\t\t\tvar factor=evParams[name+'Factor'] || 0;\n\t\t\tvar weighted=value*factor;\n\t\t\tif(debug)\n\t\t\t\tconsole.log(name,\"=\",value,\"*\",factor,\"=>\",weighted);\n\t\t\tthis.mEvaluation+=weighted;\n\t\t}\n\t\tthis.mEvaluation*=aGame.mOptions.attackers;\n\t\tif(debug)\n\t\t\tconsole.log(\"Evaluation\",this.mEvaluation);\n\t}\n\t\n\tModel.Board.ApplyMove = function(aGame,move) {\n\t\t//this.taflIntegrity(aGame);\n\t\tvar $this=this;\n\t\tvar index=this.board[move.f];\n\t\tvar piece=this.pieces[index];\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.t+piece.s,move.f);\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.t+piece.s,move.t);\n\t\tthis.board[move.f]=-1;\n\t\tthis.board[move.t]=index;\n\t\tpiece.p=move.t;\n\t\tif(this.mWho==aGame.mOptions.attackers) {\n\t\t\tvar cr0=Cr(move.f);\n\t\t\tvar cr=Cr(move.t);\n\t\t}\n\t\tvar capts=move.c;\n\t\tfor(var ci=0;ci<capts.length;ci++) {\n\t\t\tvar pos1=capts[ci];\n\t\t\tvar index1=$this.board[pos1];\n\t\t\tvar piece1=$this.pieces[index1];\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",piece1.t+piece1.s,pos1);\n\t\t\t$this.board[pos1]=-1;\n\t\t\tpiece1.p=-1;\n\t\t\tif($this.mWho==-aGame.mOptions.attackers)\n\t\t\t\t$this.attackersCount--;\n\t\t\telse if(piece1.t=='s')\n\t\t\t\t$this.defendersCount--;\n\t\t}\n\t\t//this.taflIntegrity(aGame);\n\t}\n\t\n\tModel.Board.taflIntegrity = function(aGame) {\n\t\tvar $this=this;\n\t\t// debug: check integrity\n\t\tvar aCount=0;\n\t\tvar dCount=0;\n\t\tthis.board.forEach(function(index,pos) {\n\t\t\tif(index>=0) {\n\t\t\t\tvar piece=$this.pieces[index];\n\t\t\t\tif(piece.p!=pos)\n\t\t\t\t\tdebugger;\n\t\t\t\tif(piece.t=='s')\n\t\t\t\t\tif(piece.s==aGame.mOptions.attackers)\n\t\t\t\t\t\taCount++;\n\t\t\t\t\telse\n\t\t\t\t\t\tdCount++;\n\t\t\t}\n\t\t});\n\t\tif(aCount!=this.attackersCount)\n\t\t\tdebugger;\n\t\tif(dCount!=this.defendersCount)\n\t\t\tdebugger;\n\t\tthis.pieces.forEach(function(piece,index) {\n\t\t\tif(piece.p>=0) {\n\t\t\t\tif($this.board[piece.p]!=index)\n\t\t\t\t\tdebugger;\n\t\t\t}\n\t\t});\t\t\n\t}\n\t\n\tModel.Board.GetSignature = function() {\n\t\treturn this.zSign;\n\t}\n\n})();\n\n"],"file":"tawlbwrdd-model.js"}