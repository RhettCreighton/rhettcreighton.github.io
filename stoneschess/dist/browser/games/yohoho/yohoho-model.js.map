{"version":3,"names":[],"mappings":"","sources":["yohoho-model.js"],"sourcesContent":["/*\n *\n * Copyright (c) 2012 - Jocly - www.jocly.com\n * \n * This file is part of the Jocly game platform and cannot be used outside of this context without the written permission of Jocly.\n * \n */\n\nModel.Game.InitGame = function() {\n\tthis.HexInitGame();\n\tthis.g.GetStrengthByType=function(type) {\n\t\tswitch(type) {\n\t\tcase 'C': return 5;\n\t\tcase 'c': return 3;\n\t\tcase 'p': return 2;\n\t\tdefault: return 0;\n\t\t}\n\t}\n\tthis.g.distAmiralToLastRowSubFactor={ \"-1\": 10, \"0\":0, \"1\": -10 };\n\tthis.g.distAmiralToLastRowFactor=3;\n\tthis.g.pieceWeight={\n\t\tc: 2,\n\t\tp: 1,\n\t\tC: 0,\n\t\tr: 0,\n\t}\n\tthis.g.weightFactor=3;\n\tthis.g.GainOtherAmiralDist=[0,15,4,2,1,0.7,0.6,0.5,0.4,0.3,0.2,0.1,0];\n\tthis.g.GainSelfAmiralDist=[0,5,4,2,1,0.7,0.6,0.5,0.4,0.3,0.2,0.1,0];\n\tthis.g.gainOtherAmiralDistSubFactor=1;\n\tthis.g.gainSelfAmiralDistSubFactor=1;\n\tthis.g.yohohoFactor=2;\n\tthis.g.MoveCount=22;\n\t\n\tvar $this=this;\n\tthis.g.Dist=function(pos1,pos2) {\n\t\tif(pos1==pos2)\n\t\t\treturn 0;\n\t\tif(pos2<pos1) {\n\t\t\tvar tmp=pos1;\n\t\t\tpos1=pos2;\n\t\t\tpos2=tmp;\n\t\t}\n\t\treturn $this.g.DistArray[pos1][pos2-pos1-1];\n\t}\n\t\n\tvar NBCELLS=this.g.Graph.length;\n\t\n\tthis.g.DistArray=[];\n\tfor(var i=0;i<NBCELLS-1;i++) {\n\t\tvar line=[];\n\t\tfor(var j=0;j<NBCELLS-i;j++)\n\t\t\tline.push(-1);\n\t\tthis.g.DistArray.push(line);\t\n\t}\n\tthis.g.SetDist=function(pos1,pos2,dist) {\n\t\tif(pos1==pos2)\n\t\t\treturn;\n\t\tif(pos2<pos1) {\n\t\t\tvar tmp=pos1;\n\t\t\tpos1=pos2;\n\t\t\tpos2=tmp;\n\t\t}\n\t\t$this.g.DistArray[pos1][pos2-pos1-1]=dist;\n\t}\n\tfor(var pos=0;pos<NBCELLS;pos++) {\n\t\tthis.YohohoEachDirection(pos,function(pos1) {\n\t\t\tif(pos<pos1) {\n\t\t\t\tvar dist=$this.g.Dist(pos,pos1);\n\t\t\t\tif(dist<0)\n\t\t\t\t\t$this.g.SetDist(pos,pos1,1);\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n\tfor(var pos=0;pos<NBCELLS;pos++) {\n\t\tthis.YohohoEachDirection(pos,function(pos1) {\n\t\t\tif(pos<pos1) {\n\t\t\t\tfor(var pos2=0;pos2<NBCELLS;pos2++) {\n\t\t\t\tvar dist2=$this.g.Dist(pos2,pos);\n\t\t\t\t\tif(dist2>=0) {\n\t\t\t\t\tvar dist3=$this.g.Dist(pos2,pos1);\n\t\t\t\t\t\tif(dist3==-1 || dist2+1<dist3)\n\t\t\t\t\t\t\t$this.g.SetDist(pos2,pos1,dist2+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\treturn true;\n\t\t});\n\t}\n}\n\n/* Constructs an instance of the Move object for the game.\n * args is either an empty object ({}), or contains the data passed to the InitUI parameter.\n */\nModel.Move.Init = function(args) {\n\tif(typeof(args)!=\"undefined\")\n\t\tthis.CopyFrom(args);\n}\n\n/* Optional method.\n * Copy the given board data to self.\n * Even if optional, it is better to implement the method for performance reasons. \n */\nModel.Move.CopyFrom = function(args) {\n\tthis.t=args.t; // move type: 'm' move 2 pieces or 'a': attack\n\tif(args.t=='m') {\n\t\tthis.m=[{\n\t\t\tf: args.m[0].f, // first sub-move from\n\t\t\tt: args.m[0].t, // first sub-move to\n\t\t},{\n\t\t\tf: args.m[1].f, // second sub-move from\n\t\t\tt: args.m[1].t, // second sub-move to\n\t\t}]\n\t} else if(args.t=='a') {\n\t\tthis.af=[];\n\t\tfor(var i=0; i<args.af.length; i++)\n\t\t\tthis.af.push(args.af[i]);\n\t\tthis.at=args.at;\n\t}\n}\n\n\n/* Optional method.\n * Returns a string to represent the move for display to human. If not defined JSON is used.\n */\nModel.Move.ToString = function() {\n\tvar str;\n\tif(this.t=='m') {\n\t\tstr=\"M \"+this.m[0].f+\">\"+this.m[0].t;\n\t\tif(typeof this.m[1].f!=\"undefined\")\n\t\t\tstr+=\" \"+this.m[1].f+\">\"+this.m[1].t;\n\t} else {\n\t\tstr=\"A \"+this.af.join(\",\")+\">\"+this.at;\n\t}\n\treturn str;\n}\n\nModel.Board.InitialPosition = function(aGame) {\t\n\tthis.HexInit(aGame);\n\tthis.first=true;\n\tthis.yohoho=false;\n\tthis.amirals={};\n\tfor(var i=0; i<this.pieces.length; i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.type=='C')\n\t\t\tthis.amirals[piece.s]=i;\n\t\tif(piece.s==JocGame.PLAYER_A)\n\t\t\tpiece.angle=0;\n\t\telse\n\t\t\tpiece.angle=180;\n\t}\n\tthis.piecesWeight={ \"-1\": 8, \"1\": 8, };\n}\n\n/* Push into the mMoves array, every moves that must be explored from this position. \n * All possible moves may not be considered, for instance if a game has many possible \n * different moves for a given board (like the game of GO). However, if not all possible \n * moves are pushed, method IsValidMove must be implemented to validate human input moves.\n */\nModel.Board.GenerateMoves = function(aGame) {\n\t//JocLog(\"mLevelInfo\",aGame.mLevelInfo);\n\tvar lastRowRace=false;\n\tvar moveCount=aGame.g.MoveCount;\n\tif(typeof aGame.mLevelInfo!=\"undefined\") {\n\t\tif(typeof(aGame.mLevelInfo.rowRaceLevel)!=\"undefined\")\n\t\t\tlastRowRace=(aGame.mCurrentLevel>=0 && aGame.mCurrentLevel<=aGame.mLevelInfo.rowRaceLevel);\n\t\tif(typeof(aGame.mLevelInfo.moveCount)!=\"undefined\")\n\t\t\tmoveCount=aGame.mLevelInfo.moveCount;\n\t}\n\t//JocLog(\"GenerateMoves\",aGame.mCurrentLevel,\"/\",aGame.mTopLevel,\"lastRowRace\",lastRowRace,typeof lastRowRace);\n\tvar $this=this;\n\tvar selfAmiralPos=this.pieces[this.amirals[this.mWho]].pos;\n\tvar otherAmiralPos=this.pieces[this.amirals[-this.mWho]].pos;\n\tvar otherAmiralRow=aGame.g.Coord[otherAmiralPos][0];\n\tvar otherAmiralNextRow=otherAmiralRow-this.mWho;\n\t\n\t//JocLog(\"Position amiral self\",selfAmiralPos,\"other\",otherAmiralPos);\n\n\tvar subMovesMap={};\n\tvar subMoves=[];\n\t\n\tvar subMovesLastRow=[];\n\n\tvar pieces=this.pieces;\n\tif(lastRowRace)\n\t\tpieces=[this.pieces[this.amirals[this.mWho]]];\n\t\n\tfor(var i=0;i<pieces.length;i++) {\n\t\tvar piece=pieces[i];\n\t\t\n\t\tif(piece.s==this.mWho && piece.alive) {\n\t\t\tvar poss=this.YohohoReachablePositionsThrough(aGame,piece.pos,piece.type);\n\t\t\t//JocLog(\"Poss\",piece.pos,poss);\n\t\t\tfor(var j=0; j<poss.length; j++) {\n\t\t\t\tvar subMove={ f: piece.pos, t: poss[j].pos, index:i, reqEmpty: poss[j].reqEmpty };\n\t\t\t\t//subMove.d2Self=aGame.g.Dist(piece.pos,selfAmiralPos);\n\t\t\t\t//subMove.d2Other=aGame.g.Dist(piece.pos,otherAmiralPos);\n\t\t\t\tvar eval=0;\n\t\t\t\tif(piece.type=='C') {\n\t\t\t\t\tvar coord=aGame.g.Coord[piece.pos];\n\t\t\t\t\tvar frow=coord[0];\n\t\t\t\t\tvar fdistToLastRow=(this.mWho==JocGame.PLAYER_A?8-frow:frow);\n\t\t\t\t\tcoord=aGame.g.Coord[subMove.t];\n\t\t\t\t\tvar trow=coord[0];\n\t\t\t\t\tvar tdistToLastRow=(this.mWho==JocGame.PLAYER_A?8-trow:trow);\n\t\t\t\t\tif(tdistToLastRow==0 && this.board[subMove.t]==-1)\n\t\t\t\t\t\tsubMovesLastRow.push(subMove);\n\t\t\t\t\teval+=12;\n\t\t\t\t\teval+=aGame.g.distAmiralToLastRowSubFactor[tdistToLastRow-fdistToLastRow];\n\t\t\t\t} else if(piece.type=='c') {\n\t\t\t\t\teval+=1;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tvar distSelfAmiral0=aGame.g.Dist(subMove.f,selfAmiralPos);\n\t\t\t\tvar distSelfAmiral1=aGame.g.Dist(subMove.t,selfAmiralPos);\n\t\t\t\tvar distOtherAmiral0=aGame.g.Dist(subMove.f,otherAmiralPos);\n\t\t\t\tvar distOtherAmiral1=aGame.g.Dist(subMove.t,otherAmiralPos);\n\t\t\t\t\n\t\t\t\tvar gainSelfAmiralDist=aGame.g.GainSelfAmiralDist[distSelfAmiral1]-aGame.g.GainSelfAmiralDist[distSelfAmiral0];\n\t\t\t\tvar gainOtherAmiralDist=aGame.g.GainOtherAmiralDist[distOtherAmiral1]-aGame.g.GainOtherAmiralDist[distOtherAmiral0];\n\t\t\t\t*/\n\t\t\t\tvar distSelfAmiral1=aGame.g.Dist(subMove.t,selfAmiralPos);\n\t\t\t\tvar distOtherAmiral1=aGame.g.Dist(subMove.t,otherAmiralPos);\n\t\t\t\tvar gainSelfAmiralDist=aGame.g.GainSelfAmiralDist[distSelfAmiral1];\n\t\t\t\tvar gainOtherAmiralDist=aGame.g.GainOtherAmiralDist[distOtherAmiral1];\n\t\t\t\t\n\t\t\t\tif(distOtherAmiral1==2 && (piece.type=='c' || piece.type=='p')) {\n\t\t\t\t\taGame.YohohoEachDirection(subMove.t,function(pos) {\n\t\t\t\t\t\tif($this.board[pos]==-1 && aGame.g.Dist(pos,otherAmiralPos)==1 && aGame.g.Dist(pos,selfAmiralPos)==1 && aGame.g.Coord[pos][0]==otherAmiralNextRow ) {\n\t\t\t\t\t\t\teval+=3;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar gainAmiralDist=Math.max(gainSelfAmiralDist*aGame.g.gainSelfAmiralDistSubFactor,gainOtherAmiralDist*aGame.g.gainOtherAmiralDistSubFactor);\n\t\t\t\t\n\t\t\t\teval+=gainAmiralDist;\n\t\t\t\t\n\t\t\t\tsubMove.eval=eval;\n\t\t\t\t\n\t\t\t\tif(typeof subMovesMap[subMove.index]==\"undefined\")\n\t\t\t\t\tsubMovesMap[subMove.index]=[];\n\t\t\t\tsubMovesMap[subMove.index].push(subMove);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(subMovesLastRow.length>0) {\n\t\tfor(var i=0; i<subMovesLastRow.length; i++) {\n\t\t\tvar subMove=subMovesLastRow[i];\n\t\t\tthis.mMoves.push({ t: 'm', m: [{f:subMove.f, t:subMove.t }, { }] });\n\t\t}\n\t\treturn;\n\t}\n\t\n\tvar subMovesPool=[];\n\tfor(var index in subMovesMap)\n\t\tif(subMovesMap.hasOwnProperty(index)) {\n\t\t\tvar subMovesByPiece=subMovesMap[index];\n\t\t\tsubMovesByPiece.sort(function(a,b) {\n\t\t\t\treturn b.eval-a.eval;\n\t\t\t});\n\t\t\tsubMovesPool.push(subMovesByPiece);\n\t\t}\n\tsubMovesPool.sort(function(a,b) {\n\t\treturn b[0].eval-a[0].eval;\n\t});\n\t//JocLog(\"subMovesPool\",subMovesPool);\n\n\tvar i1=1;\n\tvar i2=0;\n\twhile(subMovesPool.length>0) {\n\t\tsubMoves.push(subMovesPool[i2].shift());\n\t\tif(subMovesPool[i2].length==0) {\n\t\t\tsubMovesPool.splice(i2,1);\n\t\t\ti1--;\n\t\t} else\n\t\t\ti2++;\n\t\tif(i2==i1) {\n\t\t\tif(i1<subMovesPool.length)\n\t\t\t\ti1++;\n\t\t\ti2=0;\n\t\t}\n\t}\n\t//JocLog(\"GenerateMoves subMoves\",subMoves);\n\n\tif(lastRowRace) {\n\t\t//JocLog(\"lastRowRace\",subMoves);\n\t\tvar keptSubMoves=[];\n\t\tvar bestRowGain=-1;\n\t\tfor(var i=0; i<subMoves.length; i++) {\n\t\t\tvar subMove=subMoves[i];\n\t\t\tvar rowGain=(aGame.g.Coord[subMove.t][0]-aGame.g.Coord[subMove.t][0])*this.mWho;\n\t\t\tif(rowGain==bestRowGain)\n\t\t\t\tkeptSubMoves.push(subMove);\n\t\t\telse if(rowGain>bestRowGain) {\n\t\t\t\tbestRowGain=rowGain;\n\t\t\t\tkeptSubMoves=[subMove];\n\t\t\t}\n\t\t}\n\t\tthis.mMoves=this.YohohoCaptures(aGame,this.mWho);\n\t\tfor(var i=0; i<keptSubMoves.length; i++) {\n\t\t\tvar subMove=keptSubMoves[i];\n\t\t\tif(this.board[subMove.t]==-1)\n\t\t\t\tthis.mMoves.push({t:'m',m:[{ f: subMove.f, t: subMove.t },{}]})\n\t\t}\n\t\t\n\t\t//JocLog(\"GenerateMoves moves\",moves);\t\n\t\tif(this.mMoves.length==0) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tfunction CompatibleSubMoves(sm1,sm2) {\n\t\tif(sm1.index==sm2.index)\n\t\t\treturn false;\n\t\t//if(sm1.f==sm2.f)\n\t\t//\tJocLog(\"%\",sm1,sm2);\n\t\tfor(var i=0; i<sm1.reqEmpty.length; i++) {\n\t\t\tvar emptyPos=sm1.reqEmpty[i];\n\t\t\tif($this.board[emptyPos]!=-1)\n\t\t\t\treturn false;\n\t\t}\n\t\tfor(var i=0; i<sm2.reqEmpty.length; i++) {\n\t\t\tvar emptyPos=sm2.reqEmpty[i];\n\t\t\tif(emptyPos==sm1.t)\n\t\t\t\treturn false;\n\t\t\tif($this.board[emptyPos]!=-1 && emptyPos!=sm1.f)\n\t\t\t\treturn false;\n\t\t}\n\t\tif(sm1.t==sm2.t)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\tvar moves=[];\n\n\tvar amiralCapture=this.YohohoAmiralCapture(aGame,this.mWho);\n\t//JocLog(\"Amiral capture\",amiralCapture);\n\tif(amiralCapture.risk) {\n\t\tfor(var i=0; i<amiralCapture.capture.length; i++) {\n\t\t\tvar capture=amiralCapture.capture[i];\n\t\t\tvar af=JSON.parse(JSON.stringify(capture.af));\n\t\t\tthis.mMoves.push({ t:'a', af:af, at:capture.at });\n\t\t}\n\t\tfor(var j=0;j<subMoves.length && moves.length<moveCount;j++) \n\t\t\tfor(var i=0;i<amiralCapture.escape.length && moves.length<moveCount;i++) {\n\t\t\t\tvar amiralIndex=this.amirals[this.mWho];\n\t\t\t\tvar amiralPiece=this.pieces[amiralIndex];\n\t\t\t\tvar escapeSubmove={ f: amiralPiece.pos, t: amiralCapture.escape[i].t, index: amiralIndex, reqEmpty: [amiralCapture.escape[i].t] }; \n\t\t\t\tif(subMoves[j].index!=amiralIndex) {\n\t\t\t\t\tvar valid=CompatibleSubMoves(escapeSubmove,subMoves[j]);\n\t\t\t\t\tif(valid)\n\t\t\t\t\t\tmoves.push({ t: 'm', m: [{f: escapeSubmove.f, t: escapeSubmove.t },{f:subMoves[j].f, t:subMoves[j].t }] });\n\t\t\t\t\telse if(CompatibleSubMoves(subMoves[j],escapeSubmove))\n\t\t\t\t\t\tmoves.push({ t: 'm', m: [{f:subMoves[j].f, t:subMoves[j].t },{f: escapeSubmove.f, t: escapeSubmove.t }] });\n\t\t\t\t}\n\t\t\t}\n\t\tthis.mMoves=this.mMoves.concat(moves);\n\t\t//JocLog(\"GenerateMoves moves\",moves);\t\n\t\tif(this.mMoves.length==0) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=-this.mWho;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tif(this.first) {\n\t\tfor(var j=0;j<i && moves.length<moveCount;j++)\n\t\t\tif(this.board[subMoves[j].t]==-1)\n\t\t\t\tmoves.push({ t: 'm', m: [{f:subMoves[j].f, t:subMoves[j].t }, { }] });\n\t} else {\n\t\tfor(var i=1;i<subMoves.length && moves.length<moveCount;i++)\n\t\t\tfor(var j=0;j<i && moves.length<moveCount;j++) {\n\t\t\t\tif(subMoves[i].index!=subMoves[j].index)\n\t\t\t\t\tif(CompatibleSubMoves(subMoves[i],subMoves[j]))\n\t\t\t\t\t\tmoves.push({ t: 'm', m: [{ f:subMoves[i].f, t:subMoves[i].t },{ f:subMoves[j].f, t:subMoves[j].t }] });\n\t\t\t\t\telse if(CompatibleSubMoves(subMoves[j],subMoves[i]))\n\t\t\t\t\t\tmoves.push({ t: 'm', m: [{ f:subMoves[j].f, t:subMoves[j].t },{ f:subMoves[i].f, t:subMoves[i].t }] });\n\t\t\t}\n\t}\n\t\n\tthis.mMoves=this.YohohoCaptures(aGame,this.mWho);\n\t\n\tthis.mMoves=this.mMoves.concat(moves);\n\t//JocLog(\"GenerateMoves moves\",moves);\t\n\tif(this.mMoves.length==0) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=-this.mWho;\n\t}\n}\n\n/* Optional method.\n * If not defined, verification is made by checking move is equal to one of the moves generated by GenerateMove\n */\nModel.Board.IsValidMove = function(aGame,move) {\n\t// TODO: truly verify move validity to prevent hacked clients in duel\n\treturn true;\n}\n\n\n/* Optional method.\n * Using it will decrease the number of explored boards but each explored board will take longer.\n * In the case of TicTacToe, the overall duration will be bigger if QuickEvaluate is used.\n */\n/*Model.Board.QuickEvaluate = function(aGame) {\n\treturn 0; // good to have board center\n}*/\n\n/* The Evaluate method must:\n * - detects whether the game is finished by setting mFinished to true, and determine the winner by assigning\n * mWinner (to JocGame.PLAYER_A, JocGame.PLAYER_B, JocGame.DRAW).\n * - calculate mEvaluation to indicate apparent advantage to PLAYER_A (higher positive evaluation) or to\n * PLAYER_B (lower negative evaluation)\n * Parameters:\n * - aFinishOnly: it is safe to ignore this parameter value, but for better performance, the mEvaluation setting\n * can be skipped if aFinishOnly is true (function caller is only interested if the game is finished).\n * - aTopLevel: it is safe to ignore this parameter value. For convenience, if true, there is no performance involved \n * so it is safe to make additional calculation and storing data, for instance to simplify the display of the last move.\n */\nModel.Board.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\tthis.mEvaluation=0;\n\tvar amiralCaptureA=this.YohohoAmiralCapture(aGame,JocGame.PLAYER_A);\n\tif(amiralCaptureA.risk && amiralCaptureA.end) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.PLAYER_B;\n\t}\n\tvar amiralCaptureB=this.YohohoAmiralCapture(aGame,JocGame.PLAYER_B);\n\tif(amiralCaptureB.risk && amiralCaptureB.end) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.PLAYER_A;\n\t}\n\n\tvar aAmiralPos=this.pieces[this.amirals[JocGame.PLAYER_A]].pos;\n\tvar bAmiralPos=this.pieces[this.amirals[JocGame.PLAYER_B]].pos;\n\t\n\tvar arow=aGame.g.Coord[aAmiralPos][0];\n\tif(arow==8) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.PLAYER_A;\n\t}\n\tvar brow=aGame.g.Coord[bAmiralPos][0];\n\tif(brow==0) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.PLAYER_B;\n\t}\n\tif(this.mFinished)\n\t\treturn;\n\t\n\t//JocLog(\"amiral brow\",this.pieces[this.amirals[JocGame.PLAYER_B]].pos,brow);\n\tvar distAmiralToLastRowFactor=aGame.g.distAmiralToLastRowFactor;\n\tswitch(aGame.g.Dist(aAmiralPos,bAmiralPos)) {\n\tcase 1: distAmiralToLastRowFactor=aGame.g.distAmiralToLastRowFactor; break;\n\tcase 2: distAmiralToLastRowFactor=1.2*aGame.g.distAmiralToLastRowFactor; break;\n\tdefault: distAmiralToLastRowFactor=2*aGame.g.distAmiralToLastRowFactor;\n\t}\n\tthis.mEvaluation+=(arow-8+brow)*distAmiralToLastRowFactor;\n\t\n\tthis.mEvaluation+=(this.piecesWeight[JocGame.PLAYER_A]-this.piecesWeight[JocGame.PLAYER_B])*aGame.g.weightFactor;\n\tvar adist=0, bdist=0;\n\n\tfor(var i=0; i<this.pieces.length; i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.alive) {\n\t\t\tvar minDist=Math.min(aGame.g.Dist(piece.pos,aAmiralPos),aGame.g.Dist(piece.pos,bAmiralPos));\n\t\t\tif(piece.s==JocGame.PLAYER_A)\n\t\t\t\tadist+=minDist;\n\t\t\telse\n\t\t\t\tbdist+=minDist;\n\t\t}\n\t}\n\tthis.mEvaluation+=(bdist-adist)*0.001;\n\tthis.mEvaluation+=(amiralCaptureA?-aGame.g.yohohoFactor:0)+(amiralCaptureB?aGame.g.yohohoFactor:0);\n\n\t//if(aGame.g.Dist(this.pieces[this.amirals[1]].pos,this.pieces[this.amirals[-1]].pos)==0)\n\t//\tthis.mEvaluation+=10*this.mWho;\n\t\n\t//JocLog(\"Evaluation\",this.mEvaluation,\"arow\",arow,\"brow\",brow);\n}\n\n/* Optional method.\n * Copy the given board data to self.\n * Even if optional, it is better to implement the method for performance reasons. \n */\n/*\nModel.Board.CopyFrom = function(aBoard) {\n\tfor(var i=0;i<3;i++) {\n\t\tfor(var j=0;j<3;j++) {\n\t\t\tthis.board[i][j]=aBoard.board[i][j];\n\t\t}\n\t}\n}\n*/\n\nModel.Board.yohohoUpdateAngle = function(aGame,piece,pos0,pos) {\n\tvar angle=0;\n\tif(pos===undefined || pos0===undefined)\n\t\tangle=0;\n\telse { \n\t\tvar coord0=aGame.g.Coord[pos0];\n\t\tvar coord=aGame.g.Coord[pos];\n\t\tif(coord[1]>coord0[1])\n\t\t\tif(coord[0]>coord0[0])\n\t\t\t\tangle=-30;\n\t\t\telse if(coord[0]<coord0[0])\n\t\t\t\tangle=-150;\n\t\t\telse\n\t\t\t\tangle=-90;  // ok\n\t\telse if(coord[0]>coord0[0])\n\t\t\tangle=30;\n\t\telse if(coord[0]<coord0[0])\n\t\t\tangle=150;\n\t\telse\n\t\t\tangle=90;\n\t}\n\tpiece.angle=angle;\n}\n\n/* Modify the current board instance to apply the move.\n */\nModel.Board.ApplyMove = function(aGame,move) {\n\tif(move.t=='m') {\n\t\tvar index=this.board[move.m[0].f];\n\t\tvar side=this.pieces[index].s;\n\t\tthis.board[move.m[0].f]=-1;\n\t\tthis.board[move.m[0].t]=index;\n\t\tthis.pieces[index].pos=move.m[0].t;\n\t\tthis.yohohoUpdateAngle(aGame,this.pieces[index],move.m[0].f,move.m[0].t);\n\t\tif(this.first==false && typeof move.m[1].f!=\"undefined\") {\n\t\t\tindex=this.board[move.m[1].f];\n\t\t\tif(index<0)\n\t\t\t\tJocLog(\"!!!! move from nowhere\",move);\n\t\t\tthis.board[move.m[1].f]=-1;\n\t\t\tthis.board[move.m[1].t]=index;\n\t\t\tthis.pieces[index].pos=move.m[1].t;\n\t\t\tthis.yohohoUpdateAngle(aGame,this.pieces[index],move.m[1].f,move.m[1].t);\n\t\t}\n\t\tvar amiralCapture=this.YohohoAmiralCapture(aGame,-side);\n\t\tthis.yohoho=amiralCapture.risk;\n\t} else if(move.t=='a') {\n\t\tvar index=this.board[move.at];\n\t\tthis.board[move.at]=-1;\n\t\tthis.pieces[index].alive=0;\n\t\tthis.piecesWeight[-this.mWho]-=aGame.g.pieceWeight[this.pieces[index].type];\n\t}\n\tthis.first=false;\n}\n\nModel.Board.YohohoReachablePositions=function(aGame,pos,type,accept,reject) {\n\tvar $this=this;\n\tvar poss=[];\n\tvar range=0;\n\tvar side=this.pieces[this.board[pos]].s;\n\tvar eachDirection=\"YohohoEachDirectionWind\";\n\tswitch(type) {\n\tcase 'C': range=1; break;\n\tcase 'c': range=2; break;\n\tcase 'p': range=3; break;\n\tcase 'r': eachDirection=\"YohohoEachDirection\"; break;\n\t}\n\taGame[eachDirection](pos,function(pos1,dir) {\n\t\tvar dist=0;\n\t\twhile(pos1!=null && (range==0 || dist<range) && \n\t\t\t\t(pos1==accept || ($this.board[pos1]==-1 && pos1!=reject))\n\t\t\t) {\n\t\t\tvar valid=true;\n\t\t\tif(type=='C') {\n\t\t\t\tvar strength=0;\n\t\t\t\taGame.YohohoEachDirection(pos1,function(pos2) {\n\t\t\t\t\tvar index=$this.board[pos2];\n\t\t\t\t\tif(index>=0 && $this.pieces[index].alive && $this.pieces[index].s==-side) {\n\t\t\t\t\t\tvar strength0=aGame.g.GetStrengthByType($this.pieces[index].type);\n\t\t\t\t\t\tstrength+=strength0;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tif(strength>5)\n\t\t\t\t\tvalid=false;\n\t\t\t}\n\t\t\tif(valid)\n\t\t\t\tposs.push(pos1);\n\t\t\tpos1=aGame.g.Graph[pos1][dir];\n\t\t\tdist++;\n\t\t}\n\t\treturn true;\n\t});\n\treturn poss;\n}\n\nModel.Board.YohohoReachablePositionsThrough=function(aGame,pos,type) {\n\tvar $this=this;\n\tvar poss=[];\n\tvar range=0;\n\tvar side=this.pieces[this.board[pos]].s;\n\tvar eachDirection=\"YohohoEachDirectionWind\";\n\tswitch(type) {\n\tcase 'C': range=1; break;\n\tcase 'c': range=2; break;\n\tcase 'p': range=3; break;\n\tcase 'r': eachDirection=\"YohohoEachDirection\"; break;\n\t}\n\taGame[eachDirection](pos,function(pos1,dir) {\n\t\tvar dist=0;\n\t\tvar reqEmpty=[];\n\t\twhile(pos1!=null && (range==0 || dist<range) && ($this.board[pos1]==-1 || $this.pieces[$this.board[pos1]].s==side)) {\n\t\t\tvar valid=true;\n\t\t\tif(type=='C') {\n\t\t\t\tvar strength=0;\n\t\t\t\taGame.YohohoEachDirection(pos1,function(pos2) {\n\t\t\t\t\tvar index=$this.board[pos2];\n\t\t\t\t\tif(index>=0 && $this.pieces[index].alive && $this.pieces[index].s==-side) {\n\t\t\t\t\t\tvar strength0=aGame.g.GetStrengthByType($this.pieces[index].type);\n\t\t\t\t\t\tstrength+=strength0;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tif(strength>5)\n\t\t\t\t\tvalid=false;\n\t\t\t}\n\t\t\treqEmpty.push(pos1);\n\t\t\tif(valid) {\n\t\t\t\tvar reqEmpty0=[];\n\t\t\t\tfor(var i=0; i<reqEmpty.length; i++)\n\t\t\t\t\treqEmpty0.push(reqEmpty[i]);\n\t\t\t\tposs.push({ pos: pos1, reqEmpty: reqEmpty0 });\n\t\t\t}\n\t\t\tpos1=aGame.g.Graph[pos1][dir];\n\t\t\tdist++;\n\t\t}\n\t\treturn true;\n\t});\n\treturn poss;\n}\n\n\nModel.Game.YohohoEachDirection = function(pos,fnt) {\n\tfor(var i=0;i<6;i++) {\n\t\tvar npos=this.g.Graph[pos][i];\n\t\tif(npos!=null)\n\t\t\tif(fnt(npos,i)==false)\n\t\t\t\treturn;\n\t}\n}\n\nModel.Game.YohohoEachDirectionWind = function(pos,fnt) {\n\tfor(var i=1;i<6;i++) {\n\t\tvar npos=this.g.Graph[pos][i];\n\t\tif(npos!=null)\n\t\t\tif(fnt(npos,i)==false)\n\t\t\t\treturn;\n\t}\n}\n\nModel.Board.YohohoAmiralCapture=function(aGame,who) {\n\tvar $this=this;\n\tvar capture={ risk: false };\n\t\n\t// check whether the amiral is in capture\n\t\n\tvar amiralPos=this.pieces[this.amirals[who]].pos;\n\tvar strength=0;\n\tvar attackers=[];\n\taGame.YohohoEachDirection(amiralPos,function(pos1) {\n\t\tvar index=$this.board[pos1];\n\t\tif(index>=0 && $this.pieces[index].alive && $this.pieces[index].s==-who) {\n\t\t\tvar strength0=aGame.g.GetStrengthByType($this.pieces[index].type);\n\t\t\tif(strength0>0)\n\t\t\t\tattackers.push(index);\n\t\t\tstrength+=strength0;\n\t\t}\n\t\treturn true;\n\t});\n\t//JocLog(\"YohohoAmiralDanger\", strength>5);\n\tif(strength<=5)\n\t\treturn capture;\n\t\n\t// check saving amiral by capturing ennemy\n\t\n\tcapture.risk=true;\n\t\n\tcapture.attackers=attackers;\n\tcapture.capture=[];\n\tfor(var i=0; i<attackers.length; i++) {\n\t\tvar index=attackers[i];\n\t\tvar attackerStrength=aGame.g.GetStrengthByType(this.pieces[index].type);\n\t\tif(strength-attackerStrength<=5) {\n\t\t\tvar strength1=0;\n\t\t\tvar attackers1=[];\n\t\t\taGame.YohohoEachDirection(this.pieces[index].pos,function(pos1) {\n\t\t\t\tvar index0=$this.board[pos1];\n\t\t\t\tif(index0>=0 && $this.pieces[index0].alive && $this.pieces[index0].s==who) {\n\t\t\t\t\tvar strength0=aGame.g.GetStrengthByType($this.pieces[index0].type);\n\t\t\t\t\tif(strength0>0)\n\t\t\t\t\t\tattackers1.push($this.pieces[index0].pos);\n\t\t\t\t\tstrength1+=strength0;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\tif(strength1>attackerStrength)\n\t\t\t\tcapture.capture.push({ af: attackers1, at: this.pieces[index].pos });\n\t\t}\n\t}\n\t\n\t// check saving amiral by moving the piece\n\t\n\tcapture.escape=[];\n\taGame.YohohoEachDirectionWind(amiralPos,function(pos1) {\n\t\tvar index=$this.board[pos1];\n\t\tif(index==-1) {\n\t\t\tvar strength1=0;\n\t\t\taGame.YohohoEachDirection(pos1,function(pos2) {\n\t\t\t\tvar index1=$this.board[pos2];\n\t\t\t\tif(index1>=0 && $this.pieces[index1].alive && $this.pieces[index1].s==-who) {\n\t\t\t\t\tvar strength0=aGame.g.GetStrengthByType($this.pieces[index1].type);\n\t\t\t\t\tstrength1+=strength0;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(strength1<=5)\n\t\t\t\tcapture.escape.push({ f: amiralPos, t: pos1 });\n\t\t}\n\t\treturn true;\n\t});\n\t\n\tcapture.end = capture.escape.length==0 && capture.capture.length==0;\n\n\treturn capture;\n}\n\nModel.Board.YohohoCaptures=function(aGame,who) {\n\tvar $this=this;\n\tvar captures=[];\n\tfor(var i=0; i<$this.pieces.length; i++) {\n\t\tvar piece=$this.pieces[i];\n\t\tif(piece.s==-who && piece.alive) {\n\t\t\tvar attackeeStrength=aGame.g.GetStrengthByType(piece.type);\n\t\t\tvar attackers=[];\n\t\t\tif(attackeeStrength>0) { // not a rock\n\t\t\t\tvar strength1=0;\n\t\t\t\taGame.YohohoEachDirection(piece.pos,function(pos) {\n\t\t\t\t\tvar index=$this.board[pos];\n\t\t\t\t\tif(index>=0 && $this.pieces[index].alive && $this.pieces[index].s==who) {\n\t\t\t\t\t\tvar strength0=aGame.g.GetStrengthByType($this.pieces[index].type);\n\t\t\t\t\t\tif(strength0>0)\n\t\t\t\t\t\t\tattackers.push(pos);\n\t\t\t\t\t\tstrength1+=strength0;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tif(strength1>attackeeStrength)\n\t\t\t\t\tcaptures.push({ t: 'a', af: attackers, at: piece.pos });\n\t\t\t}\n\t\t}\n\t}\n\treturn captures;\n}\n"],"file":"yohoho-model.js"}