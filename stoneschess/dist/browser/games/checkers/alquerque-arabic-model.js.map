{"version":3,"names":[],"mappings":"","sources":["checkersbase-model.js"],"sourcesContent":["/*\n *\n * Copyright (c) 2012 - Jocly - www.jocly.com\n * \n * This file is part of the Jocly game platform and cannot be used outside of this context without the written permission of Jocly.\n * \n */\n\n(function() {\n\n\tvar boardWidth,boardHeight,invertNotation=false;\n\t\n\tfunction PosToString(pos) {\n\t\tif(!invertNotation) {\n\t\t\tvar p1=boardWidth*boardHeight-pos-1;\n\t\t\tvar p2=p1%boardWidth;\n\t\t\treturn (p1-p2)+boardWidth-p2;\n\t\t} else {\n\t\t\tvar col=pos%boardWidth;\n\t\t\tvar row=(pos-col)/boardWidth;\n\t\t\treturn row*boardWidth+boardWidth-col;\n\t\t}\n\t}\n\t\n\tModel.Game.checkersPosToString = PosToString;\n\t\n\tModel.Game.InitGameInfo = function() {\n\t\t// overload to set game feature options\n\t}\n\t\n\tModel.Game.BuildGraphCoord = function() {\n\t\tvar WIDTH=this.mOptions.width;\n\t\tvar HEIGHT=this.mOptions.height;\n\t\n\t\tvar g=[];\n\t\tvar coord=[];\n\t\tthis.g.Graph=g;\n\t\tthis.g.Coord=coord;\n\t}\n\t\n\t/* Optional method.\n\t * Called when the game is created.\n\t */\n\tModel.Game.InitGame = function() {\n\t\tvar WIDTH=this.mOptions.width;\n\t\tvar HEIGHT=this.mOptions.height;\n\t\tboardWidth=WIDTH;\n\t\tboardHeight=HEIGHT;\n\t\tinvertNotation=this.mOptions.invertNotation || false;\n\t\n\t\tthis.g.compulsoryCatch=true;\n\t\tthis.g.canStepBack=true;\n\t\tthis.g.mustMoveForward=false;\n\t\tthis.g.mustMoveForwardStrict=false;\n\t\tthis.g.lastRowFreeze=false;\t\n\t\tthis.g.lastRowCrown=false;\n\t\tthis.g.captureLongestLine=false;\n\t\tthis.g.noMove=\"lose\";\n\t\tthis.g.kingCaptureShort=false;\n\t\tthis.g.kingValue=5;\n\t\tthis.g.lastRowFactor=0;\n\t\tthis.g.canCaptureBackward=true;\n\t\tthis.g.captureInstantRemove=false;\n\t\tthis.g.longRangeKing=true;\n\t\tthis.g.drawKvsK=true;\n\t\tthis.g.drawKvs2K=true;\n\t\tthis.g.whiteStarts=true;\n\t\tthis.g.king180deg=false;\n\t\tthis.g.suicide=false;\n\t\t\n\t\tif(this.mOptions.variant)\n\t\t\tfor(var k in this.mOptions.variant)\n\t\t\t\tif(this.mOptions.variant.hasOwnProperty(k))\n\t\t\t\t\tthis.g[k]=this.mOptions.variant[k];\n\t\t\n\t\tthis.BuildGraphCoord();\n\t\n\t\tthis.zobrist=new JocGame.Zobrist({\n\t\t\tboard: {\n\t\t\t\ttype: \"array\",\n\t\t\t\tsize: this.g.Graph.length,\n\t\t\t\tvalues: [\"1/0\",\"1/1\",\"-1/0\",\"-1/1\"],\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/* Optional method.\n\t * Called when the game is over.\n\t */\n\tModel.Game.DestroyGame = function() {\n\t}\n\t\n\tModel.Game.CheckersDirections = 4;\n\tModel.Game.Checkers2WaysDirections = [ 0,1,1,0 ]; \n\t\n\t// walk through neighbor positions\n\tModel.Game.CheckersEachDirection = function(pos,fnt) {\n\t\tfor(var i=0;i<this.CheckersDirections;i++) {\n\t\t\tvar npos=this.g.Graph[pos][i];\n\t\t\tif(npos!=null)\n\t\t\t\tif(fnt(npos,i)==false)\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\t\n\t/* Constructs an instance of the Move object for the game.\n\t * args is either an empty object ({}), or contains the data passed to the InitUI parameter.\n\t */\n\tModel.Move.Init = function(args) {\n\t\t//JocLog(\"Move.Init\",args);\n\t\tthis.pos=[];\n\t\tvar argsPos = args.pos ? Object.keys(args.pos).sort() : [];\n\t\tfor(var i=0; i<argsPos.length; i++)\n\t\t\tthis.pos.push(args.pos[i]);\n\t\tthis.capt=[];\n\t\tvar captPos = args.capt ? Object.keys(args.capt).sort() : [];\n\t\tfor(var i=0; i<captPos.length; i++)\n\t\t\tthis.capt.push(args.capt[i]);\n\t}\n\t\n\t/* Optional method.\n\t * Copy the given board data to self.\n\t * Even if optional, it is better to implement the method for performance reasons. \n\t */\n\t/*\n\tModel.Move.CopyFrom = function(aMove) {\n\t\tthis.row=aMove.row;\n\t\tthis.col=aMove.col;\n\t}\n\t*/\n\t\n\t/* Optional method.\n\t * Verify move equality. If not defined, comparison is performed from JSON stringification of move objects.\n\t */\n\t/*\n\tModel.Move.Equals = function(move) {\n\t\treturn this.fc==move.fc && this.tc==move.tc && this.fr==move.fr && this.tr==move.tr;\n\t}\n\t*/\n\t\n\t/* Optional method.\n\t * Returns a string to represent the move for display to human. If not defined JSON is used.\n\t */\n\tModel.Move.ToString = function(format) {\n\t\tformat = format || \"natural\";\n\t\tvar self = this;\n\n\t\tfunction NaturalFormat() {\n\t\t\tvar posses=[PosToString(self.pos[0]),PosToString(self.pos[self.pos.length-1])];\n\t\t\tvar sep='-';\n\t\t\tfor(var i=1;i<self.capt.length;i++)\n\t\t\t\tif(self.capt[i]!=null) {\n\t\t\t\t\tsep='x';\n\t\t\t\t\tif(self.capt.length>3)\n\t\t\t\t\t\tposses.push(PosToString(self.capt[i]));\n\t\t\t\t}\n\t\t\treturn posses.join(sep);\n\t\t}\n\n\t\tfunction HubFormat() {\n\t\t\tvar sep = \"-\";\n\t\t\tvar parts = [PosToString(self.pos[0]), PosToString(self.pos[self.pos.length - 1])];\n\t\t\tif (self.capt[1]) {\n\t\t\t\tsep = \"x\";\n\t\t\t\tvar capts = self.capt.slice(1).map(function(pos) {\n\t\t\t\t\treturn PosToString(pos);\n\t\t\t\t});\n\t\t\t\tcapts.sort();\n\t\t\t\tparts = parts.concat(capts);\n\t\t\t}\n\t\t\treturn parts.join(sep);\n\t\t}\n\n\t\tfunction DxpFormat() {\n\t\t\tvar parts = [PosToString(self.pos[0]), PosToString(self.pos[self.pos.length - 1])];\n\t\t\tif(self.capt[1]) {\n\t\t\t\tparts.push(self.capt.length-1);\n\t\t\t\tvar capts = [];\n\t\t\t\tfor(var i=1;i<self.capt.length;i++)\n\t\t\t\t\tcapts.push(PosToString(self.capt[i]));\n\t\t\t\tcapts.sort();\n\t\t\t\tparts = parts.concat(capts);\n\t\t\t} else\n\t\t\t\tparts.push(0);\n\t\t\treturn parts.map(function(num) {\n\t\t\t\treturn num<10 ? \"0\"+num : num;\n\t\t\t}).join(\"\");\n\t\t}\n\n\t\tswitch(format) {\n\t\t\tcase \"natural\":\n\t\t\t\treturn NaturalFormat();\n\t\t\tcase \"hub\":\n\t\t\t\treturn HubFormat();\n\t\t\tcase \"dxp\":\n\t\t\t\treturn DxpFormat();\n\t\t\tdefault:\n\t\t\t\treturn \"??\";\n\t\t}\n\t}\n\t\n\t/* Board object constructor.\n\t */\n\tModel.Board.Init = function(aGame) {\n\t\tthis.zSign=0;\n\t}\n\t\n\tModel.Board.InitialPosition = function(aGame) {\n\t\tvar WIDTH=aGame.mOptions.width;\n\t\tvar HEIGHT=aGame.mOptions.height;\n\t\tvar INITIAL=aGame.mOptions.initial;\n\t\t\n\t\tthis.board=[]; // access pieces by position\n\t\tfor(var r=0;r<HEIGHT;r++) {\n\t\t\tfor(var c=0;c<WIDTH;c++)\n\t\t\t\tthis.board[r*WIDTH+c]=-1;\n\t\t}\n\t\n\t\tthis.pieces=[]; // access pieces by index\n\t\tvar index=0;\n\t\tif(aGame.mInitial) {\n\t\t\tthis.pCount=[0,0];\n\t\t\tthis.spCount=[0,0];\n\t\t\tthis.kpCount=[0,0];\n\t\t\tfor(var i=0;i<aGame.mInitial.pieces.length;i++) {\n\t\t\t\tvar piece=aGame.mInitial.pieces[i];\n\t\t\t\tthis.board[piece.p]=i;\n\t\t\t\tthis.pieces.push({\n\t\t\t\t\ts: piece.s, \n\t\t\t\t\tp: piece.p, \n\t\t\t\t\tl: -1, \n\t\t\t\t\tt: piece.t,\n\t\t\t\t\tplp: piece.p,  \t\t\t\t\t\n\t\t\t\t});\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.s+\"/\"+piece.t,piece.p);\n\t\t\t\tvar index01=-(piece.s-1)/2;\n\t\t\t\tthis.pCount[index01]++;\n\t\t\t\tif(piece.t==0)\n\t\t\t\t\tthis.spCount[index01]++;\n\t\t\t\telse\n\t\t\t\t\tthis.kpCount[index01]++;\n\t\t\t}\n\t\t} else {\n\t\t\tfor(var i in INITIAL.a) \n\t\t\t\tif(INITIAL.a.hasOwnProperty(i)) {\n\t\t\t\t\tvar p=INITIAL.a[i];\n\t\t\t\t\tvar pos=p[0]*WIDTH+p[1];\n\t\t\t\t\tvar piece={\n\t\t\t\t\t\ts: JocGame.PLAYER_A, // side\n\t\t\t\t\t\tp: pos, // position\n\t\t\t\t\t\tl: -1, // last position for this piece\n\t\t\t\t\t\tt: 0, // piece type\n\t\t\t\t\t\tplp: pos, // last position in move (for piece angle calculation) \n\t\t\t\t\t};\n\t\t\t\t\tthis.pieces.push(piece);\n\t\t\t\t\tthis.board[pos]=index++;\n\t\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",\"1/0\",pos);\n\t\t\t\t}\n\t\t\tfor(var i in INITIAL.b) \n\t\t\t\tif(INITIAL.b.hasOwnProperty(i)) {\n\t\t\t\t\tvar p=INITIAL.b[i];\n\t\t\t\t\tvar pos=p[0]*WIDTH+p[1];\n\t\t\t\t\tvar piece={\n\t\t\t\t\t\ts: JocGame.PLAYER_B, // side\n\t\t\t\t\t\tp: pos, // position\n\t\t\t\t\t\tl: -1, // last position for this piece\n\t\t\t\t\t\tt: 0, // piece type\n\t\t\t\t\t\tplp: pos, // last position in move (for piece angle calculation) \n\t\t\t\t\t};\n\t\t\t\t\tthis.pieces.push(piece);\n\t\t\t\t\tthis.board[pos]=index++;\n\t\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",\"-1/0\",pos);\n\t\t\t\t}\n\t\t\tthis.pCount=[INITIAL.a.length,INITIAL.b.length];\n\t\t\tthis.spCount=[INITIAL.a.length,INITIAL.b.length];\n\t\t\tthis.kpCount=[INITIAL.a.length,INITIAL.b.length];\n\t\t}\n\t}\n\t\n\t/* Push into the mMoves array, every possible move\n\t */\n\tModel.Board.GenerateMoves = function(aGame) {\n\t\ttry {\n\t\t\tthis._GenerateMoves(aGame);\n\t\t} catch(e) {\n\t\t\tdebugger;\n\t\t}\n\t}\n\t\n\tModel.Board._GenerateMoves = function(aGame) {\n\t\tvar HEIGHT=aGame.mOptions.height;\n\t\tvar $this=this;\n\n\t\tthis.mMoves = [];\n\n\t\tfunction EachPiece(fnt) {\n\t\t\tfor(var i=0;i<$this.pieces.length;i++) {\n\t\t\t\tvar piece=$this.pieces[i];\n\t\t\t\tif(piece && piece.s==$this.mWho)\n\t\t\t\t\tfnt(i,piece.p);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfunction catchPieces(pos,poss,capts,dirs,king) {\n\t\t\twhile(true) {\n\t\t\t\tvar nextPoss=[];\n\t\t\t\tvar nextCapts=[];\n\t\t\t\tvar nextDirs=[];\n\t\t\t\taGame.CheckersEachDirection(pos,function(pos0,dir) {\n\t\t\t\t\tvar r;\n\t\t\t\t\tif(aGame.g.canCaptureBackward==false)\n\t\t\t\t\t\tr=aGame.g.Coord[pos][0];\n\t\t\t\t\tvar dir0=aGame.Checkers2WaysDirections[dir];\n\t\t\t\t\tif(!king) {\n\t\t\t\t\t\tif($this.board[pos0]>=0 && $this.pieces[$this.board[pos0]].s==-$this.mWho) {\n\t\t\t\t\t\t\tvar r0,forward;\n\t\t\t\t\t\t\tif(aGame.g.canCaptureBackward==false) {\n\t\t\t\t\t\t\t\tr0=aGame.g.Coord[pos0][0];\n\t\t\t\t\t\t\t\tforward=false;\n\t\t\t\t\t\t\t\tif(($this.mWho==JocGame.PLAYER_A && r0>=r) || ($this.mWho==JocGame.PLAYER_B && r0<=r))\n\t\t\t\t\t\t\t\t\t\tforward=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(aGame.g.canCaptureBackward || forward==true) {\n\t\t\t\t\t\t\t\tvar pos1=aGame.g.Graph[pos0][dir];\n\t\t\t\t\t\t\t\tif(pos1!=null && ($this.board[pos1]==-1 || pos1==poss[0] || (pos1!==null && aGame.g.captureInstantRemove && capts.indexOf(pos1)>=0))) {\n\t\t\t\t\t\t\t\t\tvar keep=true;\n\t\t\t\t\t\t\t\t\tfor(var i=0;i<dirs.length;i++)\n\t\t\t\t\t\t\t\t\t\tif((aGame.g.captureInstantRemove && capts[i]==pos0) ||\n\t\t\t\t\t\t\t\t\t\t\t\t(aGame.g.captureInstantRemove==false && capts[i]==pos0 && dirs[i]==dir0)) {\n\t\t\t\t\t\t\t\t\t\t\tkeep=false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(keep) {\n\t\t\t\t\t\t\t\t\t\tnextPoss.push(pos1);\n\t\t\t\t\t\t\t\t\t\tnextCapts.push(pos0);\n\t\t\t\t\t\t\t\t\t\tnextDirs.push(dir0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // king\n\t\t\t\t\t\tif(aGame.g.longRangeKing)\n\t\t\t\t\t\t\twhile($this.board[pos0]==-1 || \n\t\t\t\t\t\t\t\t\t(aGame.g.king180deg && pos0!=null && capts.indexOf(pos0)>=0))\n\t\t\t\t\t\t\t\tpos0=aGame.g.Graph[pos0][dir];\n\t\t\t\t\t\tif(pos0!=null) {\n\t\t\t\t\t\t\tif($this.board[pos0]>=0 && $this.pieces[$this.board[pos0]].s==-$this.mWho) {\n\t\t\t\t\t\t\t\tvar caught=pos0;\n\t\t\t\t\t\t\t\tpos0=aGame.g.Graph[pos0][dir];\n\t\t\t\t\t\t\t\tif(aGame.g.kingCaptureShort) {\n\t\t\t\t\t\t\t\t\tif($this.board[pos0]==-1 || pos0==poss[0]) {\n\t\t\t\t\t\t\t\t\t\tvar keep=true;\n\t\t\t\t\t\t\t\t\t\tfor(var i=0;i<dirs.length;i++)\n\t\t\t\t\t\t\t\t\t\t\tif(!aGame.g.king180deg) {\n\t\t\t\t\t\t\t\t\t\t\t\tif((aGame.g.captureInstantRemove && capts[i]==caught) ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(aGame.g.captureInstantRemove==false && capts[i]==caught && \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirs[i]==dir0)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tkeep=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} else if(capts[i]==caught) {\n\t\t\t\t\t\t\t\t\t\t\t\tkeep=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(keep) {\n\t\t\t\t\t\t\t\t\t\t\tnextPoss.push(pos0);\n\t\t\t\t\t\t\t\t\t\t\tnextCapts.push(caught);\n\t\t\t\t\t\t\t\t\t\t\tnextDirs.push(dir0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tpos0=aGame.g.Graph[pos0][dir];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile($this.board[pos0]==-1 || pos0==poss[0] || (pos0!==null && aGame.g.captureInstantRemove && capts.indexOf(pos0)>=0)) {\n\t\t\t\t\t\t\t\t\t\tvar keep=true;\n\t\t\t\t\t\t\t\t\t\tfor(var i=0;i<dirs.length;i++)\n\t\t\t\t\t\t\t\t\t\t\tif((aGame.g.captureInstantRemove && capts[i]==caught) ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t(aGame.g.captureInstantRemove==false && capts[i]==caught && dirs[i]==dir0)) {\n\t\t\t\t\t\t\t\t\t\t\t\tkeep=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(keep) {\n\t\t\t\t\t\t\t\t\t\t\tnextPoss.push(pos0);\n\t\t\t\t\t\t\t\t\t\t\tnextCapts.push(caught);\n\t\t\t\t\t\t\t\t\t\t\tnextDirs.push(dir0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tpos0=aGame.g.Graph[pos0][dir];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tif(nextPoss.length==0) {\n\t\t\t\t\tif(poss.length>1)\n\t\t\t\t\t\t$this.mMoves.push({ pos: poss, capt: capts });\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!aGame.g.compulsoryCatch && poss.length>1) {\n\t\t\t\t\tvar poss1=[];\n\t\t\t\t\tfor(var i=0;i<poss.length;i++)\n\t\t\t\t\t\tposs1.push(poss[i]);\n\t\t\t\t\tvar capts1=[];\n\t\t\t\t\tfor(var i=0;i<capts.length;i++)\n\t\t\t\t\t\tcapts1.push(capts[i]);\n\t\t\t\t\t$this.mMoves.push({ pos: poss1, capt: capts1 });\n\t\t\t\t}\n\t\t\t\tif(nextPoss.length==1) {\n\t\t\t\t\tpos=nextPoss[0];\n\t\t\t\t\tposs.push(pos);\n\t\t\t\t\tcapts.push(nextCapts[0]);\n\t\t\t\t\tdirs.push(nextDirs[0]);\n\t\t\t\t} else {\n\t\t\t\t\tfor(var i=0;i<nextPoss.length;i++) {\n\t\t\t\t\t\tvar poss1=[];\n\t\t\t\t\t\tfor(var j=0;j<poss.length;j++)\n\t\t\t\t\t\t\tposs1.push(poss[j]);\n\t\t\t\t\t\tposs1.push(nextPoss[i]);\n\t\t\t\t\t\tvar capts1=[];\n\t\t\t\t\t\tfor(var j=0;j<capts.length;j++)\n\t\t\t\t\t\t\tcapts1.push(capts[j]);\n\t\t\t\t\t\tcapts1.push(nextCapts[i]);\n\t\t\t\t\t\tvar dirs1=[];\n\t\t\t\t\t\tfor(var j=0;j<dirs.length;j++)\n\t\t\t\t\t\t\tdirs1.push(dirs[j]);\n\t\t\t\t\t\tdirs1.push(nextDirs[i]);\n\t\t\t\t\t\tcatchPieces(nextPoss[i],poss1,capts1,dirs1,king);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEachPiece(function(index,pos) {\n\t\t\tif($this.pieces[index].t==0) \n\t\t\t\tcatchPieces(pos,[pos],[null],[null],false);\n\t\t\telse if($this.pieces[index].t==1)\n\t\t\t\tcatchPieces(pos,[pos],[null],[null],true);\n\t\t});\n\t\tif(aGame.g.compulsoryCatch==false || this.mMoves.length==0)\n\t\t\tEachPiece(function(index,pos) {\n\t\t\t\tvar r;\n\t\t\t\tif($this.pieces[index].t==0) {\n\t\t\t\t\tif(aGame.g.mustMoveForward || aGame.g.mustMoveForwardStrict || aGame.lastRowFreeze)\n\t\t\t\t\t\tr=aGame.g.Coord[pos][0];\n\t\t\t\t\taGame.CheckersEachDirection(pos,function(pos0,dir) {\n\t\t\t\t\t\tvar r0,forward,lastRow;\n\t\t\t\t\t\tif(aGame.g.mustMoveForwardStrict) {\n\t\t\t\t\t\t\tr0=aGame.g.Coord[pos0][0];\n\t\t\t\t\t\t\tforward=false;\n\t\t\t\t\t\t\tif(($this.mWho==JocGame.PLAYER_A && r0>r) || ($this.mWho==JocGame.PLAYER_B && r0<r))\n\t\t\t\t\t\t\t\t\tforward=true;\n\t\t\t\t\t\t} else if(aGame.g.mustMoveForward) {\n\t\t\t\t\t\t\tr0=aGame.g.Coord[pos0][0];\n\t\t\t\t\t\t\tforward=true;\n\t\t\t\t\t\t\tif(($this.mWho==JocGame.PLAYER_A && r0<r) || ($this.mWho==JocGame.PLAYER_B && r0>r))\n\t\t\t\t\t\t\t\t\tforward=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(aGame.g.lastRowFreeze) {\n\t\t\t\t\t\t\tlastRow=false;\n\t\t\t\t\t\t\tif(($this.mWho==JocGame.PLAYER_A && r==HEIGHT-1) || ($this.mWho==JocGame.PLAYER_B && r==0))\n\t\t\t\t\t\t\t\tlastRow=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif($this.board[pos0]==-1 && (aGame.g.canStepBack || pos0!=$this.pieces[index].l) && \n\t\t\t\t\t\t\t\t((aGame.g.mustMoveForward==false && aGame.g.mustMoveForwardStrict==false) || forward==true) &&\n\t\t\t\t\t\t\t\t(aGame.g.lastRowFreeze==false || lastRow==false))\n\t\t\t\t\t\t\t$this.mMoves.push({ pos: [ pos, pos0 ], capt: [ null, null ] });\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t});\n\t\t\t\t} else if($this.pieces[index].t==1) {\n\t\t\t\t\taGame.CheckersEachDirection(pos,function(pos0,dir) {\n\t\t\t\t\t\tif(aGame.g.longRangeKing) {\n\t\t\t\t\t\t\twhile($this.board[pos0]==-1) {\n\t\t\t\t\t\t\t\t$this.mMoves.push({ pos: [ pos, pos0 ], capt: [ null, null ] });\n\t\t\t\t\t\t\t\tpos0=aGame.g.Graph[pos0][dir];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif($this.board[pos0]==-1) {\n\t\t\t\t\t\t\t\t$this.mMoves.push({ pos: [ pos, pos0 ], capt: [ null, null ] });\n\t\t\t\t\t\t\t\tpos0=aGame.g.Graph[pos0][dir];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\tif(this.mMoves.length==0) {\n\t\t\tswitch(aGame.g.noMove) {\n\t\t\tcase \"count\":\n\t\t\t\tthis.mFinished=true;\n\t\t\t\tif(this.pCount[0]<this.pCount[1])\n\t\t\t\t\tthis.mWinner=JocGame.PLAYER_B;\n\t\t\t\telse if(this.pCount[1]<this.pCount[0])\n\t\t\t\t\tthis.mWinner=JocGame.PLAYER_A;\n\t\t\t\telse\n\t\t\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\t\tbreak;\n\t\t\tcase \"lose\":\n\t\t\t\tthis.mFinished=true;\n\t\t\t\tthis.mWinner=-this.mWho;\n\t\t\t\tbreak;\n\t\t\tcase \"win\":\n\t\t\t\tthis.mFinished=true;\n\t\t\t\tthis.mWinner=this.mWho;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.mFinished=true;\n\t\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(aGame.g.captureLongestLine) {\n\t\t\tvar moves0=this.mMoves;\n\t\t\tvar moves1=[];\n\t\t\tvar bestLength=0;\n\t\t\tfor(var i=0; i<moves0.length; i++) {\n\t\t\t\tvar move=moves0[i];\n\t\t\t\tif(move.pos.length==bestLength)\n\t\t\t\t\tmoves1.push(move);\n\t\t\t\telse if(move.pos.length>bestLength) {\n\t\t\t\t\tmoves1=[move];\n\t\t\t\t\tbestLength=move.pos.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.mMoves=moves1;\n\t\t}\n\t}\n\t\n\t/* Optional method.\n\t */\n\t/*\n\tModel.Board.QuickEvaluate = function(aGame) {\n\t\treturn this.EvaluateChessBoard(aGame);\n\t}\n\t*/\n\t\n\t/* The Evaluate method must:\n\t * - detects whether the game is finished by setting mFinished to true, and determine the winner by assigning\n\t * mWinner (to JocGame.PLAYER_A, JocGame.PLAYER_B, JocGame.DRAW).\n\t * - calculate mEvaluation to indicate apparent advantage to PLAYER_A (higher positive evaluation) or to\n\t * PLAYER_B (lower negative evaluation)\n\t * Parameters:\n\t * - aFinishOnly: it is safe to ignore this parameter value, but for better performance, the mEvaluation setting\n\t * can be skipped if aFinishOnly is true (function caller is only interested if the game is finished).\n\t * - aTopLevel: it is safe to ignore this parameter value. For convenience, if true, there is no performance involved \n\t * so it is safe to make additional calculation and storing data, for instance to simplify the display of the last move.\n\t */\n\tModel.Board.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\t\tif(aGame.mOptions.preventRepeat && aGame.GetRepeatOccurence(this)>2) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\treturn;\n\t\t}\n\t\tif(aGame.g.drawKvsK && this.spCount[0]==0 && this.spCount[1]==0 && this.kpCount[0]==1 && this.kpCount[1]==1) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\treturn;\n\t\t}\n\t\tif(aGame.g.drawKvs2K && this.spCount[0]==0 && this.spCount[1]==0 && this.kpCount[0]+this.kpCount[1]==3 &&\n\t\t\t\t(this.kpCount[0]==1 || this.kpCount[0]==2)) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\treturn;\n\t\t}\n\t\n\t\tif(this.pCount[1]==0) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=aGame.g.suicide ? JocGame.PLAYER_B : JocGame.PLAYER_A;\n\t\t\treturn;\n\t\t}\n\t\tif(this.pCount[0]==0) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=aGame.g.suicide ? JocGame.PLAYER_A : JocGame.PLAYER_B;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.mEvaluation=(this.spCount[0]-this.spCount[1])*10\n\t\t\t+(this.kpCount[0]-this.kpCount[1])*10*aGame.g.kingValue\n\t\t\t+this.pCount[0]/this.pCount[1]-this.pCount[1]/this.pCount[0];\n\t\tif(aGame.g.lastRowFactor!=0) {\n\t\t\tvar HEIGHT=aGame.mOptions.height;\n\t\t\tvar rowSumA=0;\n\t\t\tvar rowSumB=0;\n\t\t\tfor(var i=0; i<this.pieces.length; i++) {\n\t\t\t\tvar piece=this.pieces[i];\n\t\t\t\tif(piece && piece.t==0) {\n\t\t\t\t\tif(this.mWho==JocGame.PLAYER_A)\n\t\t\t\t\t\trowSumA+=aGame.g.Coord[piece.p][0];\n\t\t\t\t\telse\n\t\t\t\t\t\trowSumB+=HEIGHT-1-aGame.g.Coord[piece.p][0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.mEvaluation += (rowSumA-rowSumB) * aGame.g.lastRowFactor;\n\n\t\t\tif(aGame.g.suicide)\n\t\t\t\tthis.mEvaluation = -this.mEvaluation;\n\t\t}\n\t\n\t\t//JocLog(\"Evaluation\",this.mEvaluation,this.pCount);\n\t}\n\t\n\t/* \n\t * Copy the given board data to self.\n\t * Even if optional, it is better to implement the method for performance reasons. \n\t */\n\t\n\tModel.Board.CopyFrom = function(aBoard) {\n\t\tthis.board=[];\n\t\tfor(var i=0;i<aBoard.board.length;i++)\n\t\t\tthis.board[i]=aBoard.board[i];\n\t\tthis.pieces=[];\n\t\tfor(var i=0;i<aBoard.pieces.length;i++) {\n\t\t\tvar p=aBoard.pieces[i];\n\t\t\tif(p==null)\n\t\t\t\tthis.pieces[i]=null;\n\t\t\telse\n\t\t\t\tthis.pieces[i]={\n\t\t\t\t\ts: p.s,\n\t\t\t\t\tp: p.p,\n\t\t\t\t\tl: p.l,\n\t\t\t\t\tt: p.t,\n\t\t\t\t\tplp: p.plp, \n\t\t\t\t};\n\t\t}\n\t\tthis.pCount=[aBoard.pCount[0],aBoard.pCount[1]];\n\t\tthis.spCount=[aBoard.spCount[0],aBoard.spCount[1]];\n\t\tthis.kpCount=[aBoard.kpCount[0],aBoard.kpCount[1]];\n\t\tthis.mWho=aBoard.mWho;\n\t\tthis.zSign=aBoard.zSign;\n\t}\n\t\n\t/* Modify the current board instance to apply the move.\n\t */\n\tModel.Board.ApplyMove = function(aGame,move) {\n\t\tvar WIDTH=aGame.mOptions.width;\n\t\tvar HEIGHT=aGame.mOptions.height;\n\t\tvar pos0=move.pos[0];\n\t\tvar pIndex=this.board[pos0];\n\t\tvar piece=this.pieces[pIndex];\n\t\tvar player=piece.s;\n\t\tpiece.l=pos0;\n\t\tvar toBeRemoved={};\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.s+\"/\"+piece.t,piece.p);\n\t\tfor(var i=1;i<move.pos.length;i++) {\n\t\t\tvar pos=move.pos[i];\n\t\t\tthis.board[piece.p]=-1;\n\t\t\tpiece.p=pos;\n\t\t\tthis.board[pos]=pIndex;\n\t\t\tvar caught=move.capt[i];\n\t\t\tif(caught!=null) {\n\t\t\t\tif(this.board[caught]>=0)\n\t\t\t\t\ttoBeRemoved[this.board[caught]]=true;\n\t\t\t\tthis.board[caught]=-1;\n\t\t\t}\n\t\t\tpos0=pos;\n\t\t}\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.s+\"/\"+piece.t,pos);\n\t\tvar plp=move.capt[move.capt.length-1]\n\t\tpiece.plp=plp?plp:move.pos[move.pos.length-2];\n\t\tfor(var index in toBeRemoved) \n\t\t\tif(toBeRemoved.hasOwnProperty(index)) {\n\t\t\t\tvar piece0=this.pieces[index];\n\t\t\t\tvar other=(1-piece0.s)/2;\n\t\t\t\tthis.pCount[other]--;\n\t\t\t\tswitch(piece0.t) {\n\t\t\t\tcase 0: this.spCount[other]--; break;\n\t\t\t\tcase 1: this.kpCount[other]--; break;\n\t\t\t\t}\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece0.s+\"/\"+piece0.t,piece0.p);\n\t\t\t\tthis.pieces[index]=null;\n\t\t\t}\n\t\tif(aGame.g.lastRowCrown && this.pieces[pIndex].t==0) {\n\t\t\tvar r=aGame.g.Coord[move.pos[move.pos.length-1]][0];\n\t\t\tif((player==JocGame.PLAYER_A && r==HEIGHT-1) || (player==JocGame.PLAYER_B && r==0)) {\n\t\t\t\tvar piece0=this.pieces[pIndex];\n\t\t\t\tpiece0.t=1;\n\t\t\t\tvar self=(1-player)/2;\n\t\t\t\tthis.spCount[self]--;\n\t\t\t\tthis.kpCount[self]++;\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece0.s+\"/0\",piece0.p);\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece0.s+\"/1\",piece0.p);\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tModel.Board.IsValidMove = function(aGame,move) {\n\t\treturn true;\n\t}\n\t\n\tModel.Board.GetSignature = function() {\n\t\treturn this.zSign;\n\t}\n\t\n\tModel.Game.Import = function(format,data) {\n\t\tvar turn=1, pieces=[];\n\t\tvar boardSize=this.mOptions.width*this.mOptions.height;\n\t\tvar boardWidth=this.mOptions.width;\n\t\tfunction AddPiece(side,type,pos) {\n\t\t\tpos=boardSize-pos;\n\t\t\tvar posCol=pos%boardWidth;\n\t\t\tpos=pos-posCol+boardWidth-posCol-1;\n\t\t\tpieces.push({\n\t\t\t\ts: side,\n\t\t\t\tp: pos, \n\t\t\t\tl: -1, \n\t\t\t\tt: type,\n\t\t\t\tplp: pos,  \n\t\t\t});\n\t\t}\n\n\t\tif(format=='pjn') {\n\t\t\tvar result={\n\t\t\t\tstatus: false,\n\t\t\t\terror: 'parse',\n\t\t\t}\n\t\t\tvar parts=data.split(':');\n\t\t\tturn=parts[0]=='W'?1:-1;\n\t\t\tfor(var i=1;i<parts.length;i++) {\n\t\t\t\tif(parts[i].length==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar color=parts[i].substr(0,1)=='W'?1:-1;\n\t\t\t\tvar parts2=parts[i].substr(1).split(',');\n\t\t\t\tfor(var j=0;j<parts2.length;j++) {\n\t\t\t\t\tvar p=parts2[j];\n\t\t\t\t\tvar type=0;\n\t\t\t\t\tif(p.substr(0,1)=='K') {\n\t\t\t\t\t\ttype=1;\n\t\t\t\t\t\tp=p.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\tvar m=/^([0-9]+)-([0-9]+)$/.exec(p);\n\t\t\t\t\tif(m)\n\t\t\t\t\t\tfor(var pos=parseInt(m[1]);pos<=parseInt(m[2]);pos++)\n\t\t\t\t\t\t\tAddPiece(color,type,pos);\n\t\t\t\t\telse\n\t\t\t\t\t\tAddPiece(color,type,parseInt(p));\n\t\t\t\t}\n\t\t\t}\n\t\t\tpieces.sort(function(p1,p2) {\n\t\t\t\treturn p2.s-p1.s;\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tstatus: true,\n\t\t\t\tinitial: {\n\t\t\t\t\tpieces: pieces,\n\t\t\t\t\tturn: turn,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tstatus: false,\n\t\t\terror: 'unsupported',\n\t\t}\n\t}\n\t\n\tvar SuperGetBestMatchingMove = JocGame.prototype.GetBestMatchingMove;\n\t\n\tModel.Game.GetBestMatchingMove = function(moveStr,candidateMoves) {\n\t\tvar prettyMoves=[];\n\t\tvar $this = this;\n\t\tcandidateMoves.forEach(function(m) {\n\t\t\tif(typeof m.ToString==\"function\")\n\t\t\t\tprettyMoves.push(m.ToString());\n\t\t\telse\n\t\t\t\tprettyMoves.push($this.CreateMove(m).ToString());\n\t\t});\n\t\tmoveStr=moveStr.replace(/0([1-9])/g,\"$1\");\n\t\tvar dbm=/^([0-9]+)[\\-x]([0-9]+)([\\-x][0-9]+)*$/.exec(moveStr);\n\t\tif(dbm) {\n\t\t\tvar re=new RegExp('^'+dbm[1]+'[\\-x]'+dbm[2]+'([\\-x][0-9]+)*$');\n\t\t\t//console.log(\"re\",re.toString())\n\t\t\tvar bestMatchesMap={};\n\t\t\tcandidateMoves.forEach(function(candidate,index) {\n\t\t\t\tif(re.test(prettyMoves[index])) {\n\t\t\t\t\tvar key=prettyMoves[index];\n\t\t\t\t\tvar m=/^([0-9]+)x([0-9]+)x([0-9]+(x[0-9]+)*)/.exec(key);\n\t\t\t\t\tif(m) {\n\t\t\t\t\t\tvar arr=m[3].split('x');\n\t\t\t\t\t\tarr.sort(function(p1,p2) {\n\t\t\t\t\t\t\treturn parseInt(p1)-parseInt(p2);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tkey=m[1]+\"x\"+m[2]+\"x\"+arr.join(\"x\");\n\t\t\t\t\t}\n\t\t\t\t\tbestMatchesMap[key]=candidate;\n\t\t\t\t}\n\t\t\t});\n\t\t\tvar bestMatches=[];\n\t\t\tfor(var i in bestMatchesMap)\n\t\t\t\tif(bestMatchesMap.hasOwnProperty(i))\n\t\t\t\t\tbestMatches.push(bestMatchesMap[i]);\n\t\t\tif(bestMatches.length>0)\n\t\t\t\tcandidateMoves=bestMatches;\n\t\t}\n\t\treturn SuperGetBestMatchingMove.call(this,moveStr,candidateMoves);\n\t}\n\n\tModel.Board.ExportBoardState = function(aGame,format) {\n\t\tformat = format || \"natural\";\n\t\tvar self = this;\n\n\t\tfunction FenFormat() {\n\t\t\tvar colors={};\n\t\t\tvar fenParts=[];\n\t\t\tself.pieces.forEach(function(piece) {\n\t\t\t\tif(piece && piece.p!=null) {\n\t\t\t\t\tvar color=piece.s==1?'W':'B';\n\t\t\t\t\tif(colors[color]===undefined)\n\t\t\t\t\t\tcolors[color]={};\n\t\t\t\t\tvar abbrev=piece.t==1?'K':'';\n\t\t\t\t\tif(colors[color][abbrev]===undefined)\n\t\t\t\t\t\tcolors[color][abbrev]={\n\t\t\t\t\t\t\tgroup: piece.t==0,\n\t\t\t\t\t\t\tpos: [],\n\t\t\t\t\t\t}\n\t\t\t\t\tcolors[color][abbrev].pos.push(parseInt(PosToString(piece.p)));\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(var color in colors) \n\t\t\t\tif(colors.hasOwnProperty(color)) {\n\t\t\t\t\tvar fenColorParts=[];\n\t\t\t\t\tfor(var abbrev in colors[color]) \n\t\t\t\t\t\tif(colors[color].hasOwnProperty(abbrev)) {\n\t\t\t\t\t\t\tvar pieceType=colors[color][abbrev];\n\t\t\t\t\t\t\tif(pieceType.group) {\n\t\t\t\t\t\t\t\tpieceType.pos.sort(function(pos1,pos2) {\n\t\t\t\t\t\t\t\t\treturn parseInt(pos1)-parseInt(pos2);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tvar last=-2, end=-1, start=-1;\n\t\t\t\t\t\t\t\tpieceType.pos.forEach(function(pos) {\n\t\t\t\t\t\t\t\t\tif(parseInt(pos)==last+1) {\n\t\t\t\t\t\t\t\t\t\tend=pos;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif(end>=0) {\n\t\t\t\t\t\t\t\t\t\t\tfenColorParts.push(abbrev+start+\"-\"+end);\n\t\t\t\t\t\t\t\t\t\t\tend=-1;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tif(start>=0)\n\t\t\t\t\t\t\t\t\t\t\t\tfenColorParts.push(abbrev+start);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tstart=pos;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlast=parseInt(pos);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif(end>=0)\n\t\t\t\t\t\t\t\t\tfenColorParts.push(abbrev+start+\"-\"+end);\n\t\t\t\t\t\t\t\telse if(start>=0)\n\t\t\t\t\t\t\t\t\tfenColorParts.push(abbrev+start);\n\t\t\t\t\t\t\t} else \n\t\t\t\t\t\t\t\tpieceType.pos.forEach(function(pos) {\n\t\t\t\t\t\t\t\t\tfenColorParts.push(abbrev+pos);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\tfenParts.push(color+fenColorParts.join(\",\"));\n\t\t\t\t}\n\t\t\tvar fen=fenParts.join(\":\");\n\t\t\treturn fen;\n\t\t}\n\n\t\tfunction DxpHubFormat(black) {\n\t\t\tvar poss = [];\n\t\t\tfor(var pos = 0; pos<self.board.length; pos++) {\n\t\t\t\tvar col=pos%boardWidth;\n\t\t\t\tvar row=(pos-col)/boardWidth;\n\t\t\t\tvar posIndex = (boardHeight - row -1)* boardWidth + col;\n\t\t\t\tvar pieceIndex = self.board[pos];\n\t\t\t\tif(pieceIndex<0)\n\t\t\t\t\tposs[posIndex] = \"e\";\n\t\t\t\telse {\n\t\t\t\t\tvar piece = self.pieces[pieceIndex];\n\t\t\t\t\tvar t = piece.s == 1 ? 'w' : black;\n\t\t\t\t\tif(piece.t==1)\n\t\t\t\t\t\tt = t.toUpperCase();\n\t\t\t\t\tposs[posIndex] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn poss.join(\"\");\n\t\t}\n\n\t\tfunction DxpFormat() {\n\t\t\treturn DxpHubFormat('z');\n\t\t}\n\n\t\tfunction HubFormat() {\n\t\t\treturn DxpHubFormat('z');\n\t\t}\n\n\t\tswitch(format) {\n\t\t\tcase \"natural\":\n\t\t\tcase \"fen\":\n\t\t\t\treturn FenFormat();\n\t\t\tcase \"dxp\":\n\t\t\t\treturn DxpFormat();\n\t\t\tcase \"hub\":\n\t\t\t\treturn HubFormat();\n\t\t\tdefault:\n\t\t\t\treturn JSON.stringify(this);\n\t\t}\n\t}\n\n})();\n"],"file":"alquerque-arabic-model.js"}