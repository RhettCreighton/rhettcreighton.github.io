{"version":3,"names":[],"mappings":"","sources":["metamachy-model.js"],"sourcesContent":["/*\n * Copyright(c) 2013-2014 - jocly.com\n *\n * You are allowed to use and modify this source code as long as it is exclusively for use in the Jocly API. \n *\n * Original authors: Jocly team\n *\n */\n \n\n(function() {\n\t\n\tvar geometry = Model.Game.cbBoardGeometryGrid(12,12);\n\t\n\tModel.Game.cbDefine = function() {\n\t\t\n\t\tvar $this = this;\n\t\t\n\t\t/*\n\t\t * Movement/capture graph for the prince\n\t\t */\n\t\tfunction PrinceGraph(side) {\n\t\t\tvar graph={};\n\t\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\t\tgraph[pos]=[];\n\t\t\t\tvar forward=[]; // hold the pos line in front of the piece\n\t\t\t\tvar pos1=geometry.Graph(pos,[0,side]);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tforward.push(pos1 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE); // capture and move allowed at first forward position\n\t\t\t\t\tpos1=geometry.Graph(pos1,[0,side]);\n\t\t\t\t\tif(pos1!=null)\n\t\t\t\t\t\tforward.push(pos1 | $this.cbConstants.FLAG_MOVE); // move to second forward only, no capture\n\t\t\t\t\tgraph[pos].push($this.cbTypedArray(forward));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $this.cbMergeGraphs(geometry,\n\t\t\t\t$this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[-1,0],[1,0],[1,-1],[1,1],[0,-side]]), // direction other than forward\n\t\t\t\tgraph // forward direction\n\t\t\t);\n\t\t}\n\t\t\n\t\t/*\n\t\t * Movement/capture graph for the eagle\n\t\t */\n\t\tfunction EagleGraph() {\n\t\t\tvar flags = $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE;\n\t\t\tvar graph={};\n\t\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\t\tgraph[pos]=[];\n\t\t\t\t[[-1,-1],[-1,1],[1,-1],[1,1]].forEach(function(delta) { // loop on all 4 diagonals\n\t\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\t\tif(pos1!=null) {\n\t\t\t\t\t\tfor(var dir=0;dir<2;dir++) { // dir=0 for row, dir=1 for column\n\t\t\t\t\t\t\tvar away=[] // hold the sliding line\n\t\t\t\t\t\t\tfor(var n=1;n<11;n++) { // board is 12 cells long, so only consider max 11 cell displacements\n\t\t\t\t\t\t\t\tvar delta2=[];\n\t\t\t\t\t\t\t\tdelta2[dir]=delta[dir]*n;\n\t\t\t\t\t\t\t\tdelta2[1-dir]=0; // delta2 is now only about moving orthogonally, away from the piece\n\t\t\t\t\t\t\t\tvar pos2=geometry.Graph(pos1,delta2);\n\t\t\t\t\t\t\t\tif(pos2!=null) {\n\t\t\t\t\t\t\t\t\tif(n==1) // possible to slide at least 1 cell, make sure the diagonal cell is not occupied, but cannot move to this cell\n\t\t\t\t\t\t\t\t\t\taway.push(pos1 | $this.cbConstants.FLAG_STOP);\n\t\t\t\t\t\t\t\t\taway.push(pos2 | flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(away.length>0)\n\t\t\t\t\t\t\t\tgraph[pos].push($this.cbTypedArray(away));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn $this.cbMergeGraphs(geometry,\n\t\t\t   $this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1]]),\n\t\t\t   graph\n\t\t\t);\n\t\t}\n\t\t\n\t\treturn {\n\t\t\t\n\t\t\tgeometry: geometry,\n\t\t\t\n\t\t\tpieceTypes: {\n\n\t\t\t\t0: {\n\t\t\t\t\tname: 'pawn-w',\n\t\t\t\t\taspect: 'fr-pawn',\n\t\t\t\t\tgraph: this.cbPawnGraph(geometry,1),\n\t\t\t\t\tvalue: 1,\n\t\t\t\t\tabbrev: '',\n\t\t\t\t\tfenAbbrev: 'P',\n\t\t\t\t\tepCatch: true,\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t1: {\n\t\t\t\t\tname: 'ipawn-w',\n\t\t\t\t\taspect: 'fr-pawn',\n\t\t\t\t\tgraph: this.cbInitialPawnGraph(geometry,1),\n\t\t\t\t\tvalue: 1,\n\t\t\t\t\tabbrev: '',\n\t\t\t\t\tfenAbbrev: 'P',\n\t\t\t\t\tinitial: [{s:1,p:24},{s:1,p:25},{s:1,p:26},{s:1,p:27},{s:1,p:28},{s:1,p:29},{s:1,p:30},{s:1,p:31},{s:1,p:32},{s:1,p:33},{s:1,p:34},{s:1,p:35}],\n\t\t\t\t\tepTarget: true,\n\t\t\t\t\tepCatch: true,\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t2: {\n\t\t\t\t\tname: 'pawn-b',\n\t\t\t\t\taspect: 'fr-pawn',\n\t\t\t\t\tgraph: this.cbPawnGraph(geometry,-1),\n\t\t\t\t\tvalue: 1,\n\t\t\t\t\tabbrev: '',\n\t\t\t\t\tfenAbbrev: 'P',\n\t\t\t\t\tepCatch: true,\n\n\t\t\t\t},\n\n\t\t\t\t3: {\n\t\t\t\t\tname: 'ipawn-b',\n\t\t\t\t\taspect: 'fr-pawn',\n\t\t\t\t\tgraph: this.cbInitialPawnGraph(geometry,-1),\n\t\t\t\t\tvalue: 1,\n\t\t\t\t\tabbrev: '',\n\t\t\t\t\tfenAbbrev: 'P',\n\t\t\t\t\tinitial: [{s:-1,p:108},{s:-1,p:109},{s:-1,p:110},{s:-1,p:111},{s:-1,p:112},{s:-1,p:113},{s:-1,p:114},{s:-1,p:115},{s:-1,p:116},{s:-1,p:117},{s:-1,p:118},{s:-1,p:119}],\n\t\t\t\t\tepTarget: true,\n\t\t\t\t\tepCatch: true,\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t4: {\n\t\t\t\t\tname: 'knight',\n\t\t\t\t\taspect: 'fr-knight',\n\t\t\t\t\tgraph: this.cbKnightGraph(geometry),\n\t\t\t\t\tvalue: 2.5,\n\t\t\t\t\tabbrev: 'N',\n\t\t\t\t\tinitial: [{s:1,p:14},{s:1,p:21},{s:-1,p:122},{s:-1,p:129}],\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t5: {\n\t\t\t\t\tname: 'bishop',\n\t\t\t\t\taspect: 'fr-bishop',\n\t\t\t\t\tgraph: this.cbBishopGraph(geometry),\n\t\t\t\t\tvalue: 3.5,\n\t\t\t\t\tabbrev: 'B',\n\t\t\t\t\tinitial: [{s:1,p:15},{s:1,p:20},{s:-1,p:123},{s:-1,p:128}],\n\t\t\t\t},\n\n\t\t\t\t6: {\n\t\t\t\t\tname: 'rook',\n\t\t\t\t\taspect: 'fr-rook',\n\t\t\t\t\tgraph: this.cbRookGraph(geometry),\n\t\t\t\t\tvalue: 5,\n\t\t\t\t\tabbrev: 'R',\n\t\t\t\t\tinitial: [{s:1,p:13},{s:1,p:22},{s:-1,p:121},{s:-1,p:130}],\n\t\t\t\t\tcastle: true,\n\t\t\t\t},\n\n\t\t\t\t7: {\n\t\t\t\t\tname: 'queen',\n\t\t\t\t\taspect: 'fr-queen',\n\t\t\t\t\tgraph: this.cbQueenGraph(geometry),\n\t\t\t\t\tvalue: 9,\n\t\t\t\t\tabbrev: 'Q',\n\t\t\t\t\tinitial: [{s:1,p:18},{s:-1,p:126}],\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t8: {\n\t\t\t\t\tname: 'king',\n\t\t\t\t\taspect: 'fr-king',\n\t\t\t\t\tisKing: true,\n\t\t\t\t\tgraph: this.cbKingGraph(geometry),\n\t\t\t\t\tabbrev: 'K',\n\t\t\t\t\tinitial: [{s:1,p:17},{s:-1,p:125}],\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t9: {\n\t\t\t\t\tname: 'cannon',\n\t\t\t\t\taspect: 'fr-cannon2',\n\t\t\t\t\tgraph: this.cbXQCannonGraph(geometry),\n\t\t\t\t\tvalue: 3.5,\n\t\t\t\t\tabbrev: 'C',\n\t\t\t\t\tinitial: [{s:1,p:0},{s:1,p:11},{s:-1,p:132},{s:-1,p:143}],\n\t\t\t\t},\n\t\t\t\t\n\t            10: {\n\t            \tname: 'elephant',\n\t            \taspect: 'fr-elephant',\n\t            \tgraph: this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1],[-2,-2],[-2,2],[2,-2],[2,2]]),\n\t            \tvalue: 2.5,\n\t            \tabbrev: 'E',\n\t            \tinitial: [{s:1,p:12},{s:1,p:23},{s:-1,p:120},{s:-1,p:131}],\n\t            },\t\t\t\t\n\t\t\t\n\t\t\t 11: {\n\t            \tname: 'prince-w',\n\t            \taspect: 'fr-admiral',\n\t            \tgraph: PrinceGraph(1),\n\t            \tvalue: 3,\n\t            \tepTarget: true,\n\t            \tabbrev: 'I',\n                    initial: [{s:1,p:16},{s:1,p:19}],\n\t            },\n\n\t\t\t12: {\n\t            \tname: 'prince-b',\n\t            \taspect: 'fr-admiral',\n\t            \tgraph: PrinceGraph(-1),\n\t\t\t\t\tepTarget: true,\n\t            \tvalue: 3,\n\t            \tabbrev: 'I',\n\t            \tinitial: [{s:-1,p:124},{s:-1,p:127}],\n\t            },\n\n\n\t\t\t13: {\n\t            \tname: 'camel',\n\t            \taspect: 'fr-camel',\n\t            \tgraph: this.cbShortRangeGraph(geometry,[[-3,-1],[-3,1],[3,-1],[3,1],[1,3],[1,-3],[-1,3],[-1,-3]]),\n\t            \tvalue: 2,\n\t            \tabbrev: 'M',\n\t            \tinitial: [{s:1,p:1},{s:1,p:10},{s:-1,p:133},{s:-1,p:142}],\n\t            },\t\n\n\t\t\t14: {\n\t            \tname: 'lion',\n\t            \taspect: 'fr-lion',\n\t            \tgraph: this.cbShortRangeGraph(geometry,[\n\t\t\t\t\t\t[-1,-1],[-1,1],[1,-1],[1,1],[1,0],[0,1],[-1,0],[0,-1],\n\t\t\t\t\t\t[-2,0],[-2,-1],[-2,-2],[-1,-2],[0,-2],\n\t\t\t\t\t\t[1,-2],[2,-2],[2,-1],[2,0],[2,1],\n\t\t\t\t\t\t[2,2],[1,2],[0,2],[-1,2],[-2,2],[-2,1]]),\n\t            \tvalue: 7.5,\n\t            \tabbrev: 'L',\n\t            \tinitial: [{s:1,p:5},{s:-1,p:137}],\n\t            },\t\n\t\t\t15: {\n\t            \tname: 'eagle',\n\t            \taspect: 'fr-eagle',\n\t            \tgraph: EagleGraph(),\n\t            \tvalue: 8,\n\t            \tabbrev: 'A',\n\t            \tinitial: [{s:1,p:6},{s:-1,p:138}],\n\t            },\t\n\n\n\n\t\t\t\t\n\t\t\t},\n\n\t\t\tpromote: function(aGame,piece,move) {\n\t\t\t\tif(piece.t==1 && geometry.R(move.t)==11)\n\t\t\t\t\treturn [7,14,15];\n\t\t\t\telse if(piece.t==3 && geometry.R(move.t)==0)\n\t\t\t\t\treturn [7,14,15];\n\t\t\telse if(piece.t==11 && geometry.R(move.t)==11)\n\t\t\t\t\treturn [7,14,15];\n\t\t\telse if(piece.t==12 && geometry.R(move.t)==0)\n\t\t\t\t\treturn [7,14,15];\n\t\t\t\treturn [];\n\t\t\t},\n\n\t\t};\n\t}\n\n\t/*\n\t * Model.Board.GenerateMoves:\n\t *   - handle setup phase \n\t *   - handle king special move: a kind of castle involving only the king\n\t */\n\tvar kingLongMoves={\n\t\t\"1\": {\n\t\t\t17: [ [15,16],[19,18],[41,29],[39,28],[43,30],[3,4,16],[27,16,28],[40,28,29],[42,29,30],[31,18,30],[7,18,6] ],\n\t\t\t5: [ [3,4],[7,8],[29,17],[27,16],[31,18],[15,4,6],[28,16,17],[30,17,18],[19,6,18] ],\n\t\t},\n\t\t\"-1\": {\n\t\t\t125: [ [127,126],[123,124],[101,113],[99,112],[103,114],[135,124,136],[111,112,124],[100,112,113],[102,113,114],[115,114,126],[139,126,138] ],\n\t\t\t137: [ [139,138],[135,136],[113,125],[115,126],[111,124],[127,126,138],[114,125,126],[112,124,125],[123,124,136] ],\n\t\t},\n\t}\n\tvar SuperModelBoardGenerateMoves=Model.Board.GenerateMoves;\n\tModel.Board.GenerateMoves = function(aGame) {\n\t\t// first moves (white and black) are managed specifically to setup K,Q,E,L initial position \n\t\tif(this.setupState===undefined)  {\n\t\t\tthis.mMoves=[{}];\n\t\t\treturn;\n\t\t}\n\t\tif(this.setupState==\"setup\")  {\n\t\t\tthis.mMoves=[];\n\t\t\tfor(var i=0;i<12;i++)\n\t\t\t\tthis.mMoves.push({setup:i});\n\t\t\treturn;\n\t\t}\n\t\tSuperModelBoardGenerateMoves.apply(this,arguments); // call regular GenerateMoves method\n\t\t// now consider special 2 cases king moves\n\t\tvar kPiece=this.pieces[this.board[this.kings[this.mWho]]];\n\t\tif(!kPiece.m && !this.check) {\n\t\t\tvar lMoves=kingLongMoves[this.mWho][kPiece.p];\n\t\t\tfor(var i=0;i<lMoves.length;i++) {\n\t\t\t\tvar lMove=lMoves[i];\n\t\t\t\tif(this.board[lMove[0]]>=0)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar canMove=true;\n\t\t\t\tvar oppInCheck=false;\n\t\t\t\tfor(var j=0;j<lMove.length;j++) {\n\t\t\t\t\tvar pos=lMove[j];\n\t\t\t\t\tvar tmpOut=this.board[pos];\n\t\t\t\t\tthis.board[pos]=-1; // remove possible piece to prevent problems when quick-applying/unapplying\n\t\t\t\t\tvar undo=this.cbQuickApply(aGame,{\n\t\t\t\t\t\tf: kPiece.p,\n\t\t\t\t\t\tt: pos,\n\t\t\t\t\t});\n\t\t\t\t\tvar inCheck=this.cbGetAttackers(aGame,pos,this.mWho,true).length>0;\n\t\t\t\t\tif(!inCheck && j==0)\n\t\t\t\t\t\toppInCheck=this.cbGetAttackers(aGame,this.kings[-this.mWho],-this.mWho,true).length>0;\n\t\t\t\t\tthis.cbQuickUnapply(aGame,undo);\n\t\t\t\t\tthis.board[pos]=tmpOut;\n\t\t\t\t\tthis.cbIntegrity(aGame);\n\t\t\t\t\tif(inCheck) {\n\t\t\t\t\t\tcanMove=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(canMove)\n\t\t\t\t\tthis.mMoves.push({\n\t\t\t\t\t\tf: kPiece.p,\n\t\t\t\t\t\tt: lMove[0],\n\t\t\t\t\t\tc: null,\n\t\t\t\t\t\tck: oppInCheck,\n\t\t\t\t\t\ta: 'K',\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\t * Model.Board.CopyFrom overriding to copy setupState property\n\t */\n\tvar SuperModelBoardCopyFrom = Model.Board.CopyFrom;\n\tModel.Board.CopyFrom = function(aBoard) {\n\t\tSuperModelBoardCopyFrom.apply(this,arguments);\n\t\tthis.setupState = aBoard.setupState;\n\t}\n\t\n\t/*\n\t * Model.Board.Evaluate overriding: in setup phase, no evaluation \n\t */\n\tvar SuperModelBoardEvaluate = Model.Board.Evaluate;\n\tModel.Board.Evaluate = function(aGame) {\n\t\tif(this.setupState===undefined || this.setupState==\"setup\")\n\t\t\treturn;\n\t\tSuperModelBoardEvaluate.apply(this,arguments);\n\t}\n\t\n\t/*\n\t * Model.Board.ApplyMove overriding: setup phase and king special move\n\t */\n\tvar SuperModelBoardApplyMove=Model.Board.ApplyMove;\n\tModel.Board.ApplyMove = function(aGame,move) {\n\t\tif(this.setupState===undefined)\n\t\t\tthis.setupState=\"setup\";\n\t\telse if(this.setupState==\"setup\") {\n\t\t\tvar $this=this;\n\t\t\t// at this point, KQLE have arbitrary positions. remember those piece indexes so we can move them\n\t\t\tvar starting={\n\t\t\t\t\"1\": { K: 17, Q: 18, L: 5, E: 6 },\n\t\t\t\t\"-1\": { K: 125, Q: 126, L: 137, E: 138 },\n\t\t\t}\n\t\t\tvar indexes={ \"1\": {}, \"-1\": {}\t};\n\t\t\t[\"1\",\"-1\"].forEach(function(side) {\n\t\t\t\tfor(var p in starting[side])\n\t\t\t\t\tindexes[side][p]=$this.board[starting[side][p]];\n\t\t\t});\n\t\t\t// remove KQLE from the board\n\t\t\t[5,6,17,18,125,126,137,138].forEach(function(pos) {\n\t\t\t\tvar pIndex=$this.board[pos];\n\t\t\t\t$this.board[pos]=-1;\n\t\t\t\t$this.pieces[pIndex].p=-1;\n\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",pIndex,pos);\n\t\t\t});\n\t\t\t// setup KQLE positions according to the setup\n\t\t\tvar setup=move.setup;\n\t\t\tvar remaining={};\n\t\t\tif(setup/6<1) {\n\t\t\t\tthis.board[17]=indexes[1].K;\n\t\t\t\tthis.pieces[indexes[1].K].p=17;\n\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[1].K,17);\n\t\t\t\tthis.kings[1]=17;\n\t\t\t\tremaining[1]=[18,5,6];\n\t\t\t\tthis.board[125]=indexes[-1].K;\n\t\t\t\tthis.pieces[indexes[-1].K].p=125;\n\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[-1].K,125);\n\t\t\t\tthis.kings[-1]=125;\n\t\t\t\tremaining[-1]=[126,137,138];\n\t\t\t} else {\n\t\t\t\tthis.board[5]=indexes[1].K;\n\t\t\t\tthis.pieces[indexes[1].K].p=5;\n\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[1].K,5);\n\t\t\t\tthis.kings[1]=5;\n\t\t\t\tremaining[1]=[17,18,6];\n\t\t\t\tthis.board[137]=indexes[-1].K;\n\t\t\t\tthis.pieces[indexes[-1].K].p=137;\n\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[-1].K,137);\n\t\t\t\tthis.kings[-1]=137;\n\t\t\t\tremaining[-1]=[125,126,138];\n\t\t\t}\n\t\t\tsetup%=6;\n\t\t\tvar queen=Math.floor(setup/2);\n\t\t\tthis.board[remaining[1][queen]]=indexes[1].Q;\n\t\t\tthis.pieces[indexes[1].Q].p=remaining[1][queen];\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[1].Q,remaining[1][queen]);\n\t\t\tremaining[1].splice(queen,1);\n\t\t\tthis.board[remaining[-1][queen]]=indexes[-1].Q;\n\t\t\tthis.pieces[indexes[-1].Q].p=remaining[-1][queen];\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[-1].Q,remaining[-1][queen]);\t\t\t\t\n\t\t\tremaining[-1].splice(queen,1);\n\t\t\tvar eagle,lion;\n\t\t\tsetup%=2;\n\t\t\tif(setup==0) {\n\t\t\t\teagle=0;\n\t\t\t\tlion=1;\n\t\t\t} else {\n\t\t\t\teagle=1;\n\t\t\t\tlion=0;\t\t\t\t\n\t\t\t}\n\t\t\tthis.board[remaining[1][eagle]]=indexes[1].E;\n\t\t\tthis.pieces[indexes[1].E].p=remaining[1][eagle];\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[1].E,remaining[1][eagle]);\n\t\t\tthis.board[remaining[1][lion]]=indexes[1].L;\n\t\t\tthis.pieces[indexes[1].L].p=remaining[1][lion];\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[1].L,remaining[1][lion]);\n\n\t\t\tthis.board[remaining[-1][eagle]]=indexes[-1].E;\n\t\t\tthis.pieces[indexes[-1].E].p=remaining[-1][eagle];\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[-1].E,remaining[-1][eagle]);\n\t\t\tthis.board[remaining[-1][lion]]=indexes[-1].L;\n\t\t\tthis.pieces[indexes[-1].L].p=remaining[-1][lion];\n\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",indexes[-1].L,remaining[1][lion]);\t\t\n\t\t\t\n\t\t\tthis.setupState=\"done\";\n\t\t} else\n\t\t\tSuperModelBoardApplyMove.apply(this,arguments);\n\t}\n\n\t/*\n\t * Model.Move.ToString overriding for setup notation\n\t */\n\tvar SuperModelMoveToString = Model.Move.ToString;\n\tModel.Move.ToString = function() {\n\t\tif(this.f===undefined) {\n\t\t\tif(this.setup===undefined)\n\t\t\t\treturn \"--\";\n\t\t\telse\n\t\t\t\treturn \"#\"+this.setup;\n\t\t}\n\t\treturn SuperModelMoveToString.apply(this,arguments);\n\t}\n\t\n\t/*\n\t * Model.Board.CompactMoveString overriding to help reading PJN game transcripts\n\t */\n\tvar SuperModelBoardCompactMoveString = Model.Board.CompactMoveString; \n\tModel.Board.CompactMoveString = function(aGame,aMove,allMoves) {\n\t\tif(typeof aMove.ToString!=\"function\") // ensure proper move object, if necessary\n\t\t\taMove=aGame.CreateMove(aMove);\n\t\tif(this.setupState===undefined || this.setupState==\"setup\")\n\t\t\treturn aMove.ToString();\n\t\treturn SuperModelBoardCompactMoveString.apply(this,arguments);\n\t}\n\n\t/*\n\t * Model.Board.StaticGenerateMoves overriding to prevent using AI during the setup phase\n\t */\n\tModel.Board.StaticGenerateMoves = function(aGame) {\n\t\tif(this.setupState==\"setup\")\n\t\t\treturn [aGame.CreateMove({setup:Math.floor(Math.random()*12)})];\n\t\treturn null;\n\t}\n\t\n})();"],"file":"metamachy-chess-model.js"}