{"version":3,"names":[],"mappings":"","sources":["hex-geo-model.js"],"sourcesContent":["\n(function() {\n\t\n\tModel.Game.cbBoardGeometryHex = function(boardLayout,posNames) {\n\t\t\n\t\tvar posNamesInv={};\n\t\tif(!posNames)\n\t\t\tposNames = {};\n\t\telse for(pos in posNames)\n\t\t\tposNamesInv[posNames[pos]]=pos;\n\t\t\n\t\tvar height=boardLayout.length;\n\t\tvar width=0;\n\t\tvar SHIFTMOD2,SHIFTRIGHT=false;\n\t\tvar maxLength=0;\n\t\tvar confine={};\n\t\t\n\t\tfor(var i=0;i<boardLayout.length;i++) {\n\t\t\tif(boardLayout[i].length%2==1)\n\t\t\t\tboardLayout[i]+\" \";\n\t\t\tif(boardLayout[i].length>maxLength)\n\t\t\t\tmaxLength=boardLayout[i].length;\n\t\t}\n\t\tfor(var i=0;i<boardLayout.length;i++)\n\t\t\twhile(boardLayout[i].length<maxLength)\n\t\t\t\tboardLayout[i]+=\" \";\n\n\t\tboardLayout.forEach(function(line,index) {\n\t\t\tif(line[0]!=' ') {\n\t\t\t\tSHIFTMOD2=(index)%2;\n\t\t\t}\n\t\t\tvar length=Math.ceil(line.length/2);\n\t\t\tif(length>width)\n\t\t\t\twidth=length;\n\t\t});\n\t\tboardLayout.forEach(function(line,index) {\n\t\t\tif((boardLayout.length-1-index)%2==1-SHIFTMOD2) {\n\t\t\t\tif(line[line.length-1]!=' ' || line[line.length-2]!=' ')\n\t\t\t\t\tSHIFTRIGHT=true;\n\t\t\t}\n\t\t\tfor(var i=0;i<line.length;i+=2)\n\t\t\t\tif(line[i]!=' ' || (i+1<line.length && line[i+1]!=' ')) {\n\t\t\t\t\tvar pos = index*width+i/2;\n\t\t\t\t\tconfine[pos]=1;\n\t\t\t\t}\n\t\t});\n\t\t\n\t\tfunction Graph(pos,delta) {\n\t\t\tvar c0=C(pos);\n\t\t\tvar r0=R(pos);\n\t\t\tvar c=c0,r=r0;\n\n\t\t\tfor(var d=0;d<3;d++) {\n\t\t\t\tvar ad=Math.abs(delta[d]);\n\t\t\t\tvar si=ad==0?0:delta[d]/ad;\n\t\t\t\tfor(var i=0;i<ad;i++) {\n\t\t\t\t\tif(r%2==SHIFTMOD2) {\n\t\t\t\t\t\tif(d==1 && si<0)\n\t\t\t\t\t\t\tc--;\n\t\t\t\t\t\tif(d==2 && si>0)\n\t\t\t\t\t\t\tc--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(d==1 && si>0)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\tif(d==2 && si<0)\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t\tif(d==1 || d==2)\n\t\t\t\t\t\tr+=si;\n\t\t\t\t\tif(d==0)\n\t\t\t\t\t\tc+=si;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c<0 || c>=width || r<0 || r>=height)\n\t\t\t\treturn null;\n\t\t\tvar pos=POS(c,r);\n\t\t\tif(pos in confine)\n\t\t\t\treturn pos;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t\t\n\t\tvar distance={};\n\t\tfor(var pos in confine) {\n\t\t\tdistance[pos]={};\n\t\t\tdistance[pos][pos]=0;\n\t\t}\n\t\tvar steps=[[1,0,0],[0,1,0],[0,0,1],[-1,0,0],[0,-1,0],[0,0,-1]];\n\t\tvar modifs=true;\n\t\twhile(modifs) {\n\t\t\tmodifs=false;\n\t\t\tfor(var pos in confine) {\n\t\t\t\tsteps.forEach(function(delta) {\n\t\t\t\t\tvar pos1=Graph(pos,delta);\n\t\t\t\t\tif(pos1==null)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif(distance[pos][pos1]!=1) {\n\t\t\t\t\t\tdistance[pos][pos1]=1;\n\t\t\t\t\t\tdistance[pos1][pos]=1;\n\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t} \n\t\t\t\t\tfor(var pos2 in confine) {\n\t\t\t\t\t\tif(pos2==pos)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(distance[pos1][pos2]===undefined && distance[pos][pos2]!==undefined) {\n\t\t\t\t\t\t\tdistance[pos1][pos2]=distance[pos][pos2]+1;\n\t\t\t\t\t\t\tdistance[pos2][pos1]=distance[pos][pos2]+1;\n\t\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t\t} else if(distance[pos1][pos2]!==undefined && distance[pos][pos2]!==undefined && distance[pos1][pos2]>distance[pos][pos2]+1) {\n\t\t\t\t\t\t\tdistance[pos1][pos2]=distance[pos][pos2]+1;\n\t\t\t\t\t\t\tdistance[pos2][pos1]=distance[pos][pos2]+1;\n\t\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar cornerDist=0;\n\t\tvar corners={};\n\t\t\n\t\tfor(var pos in confine) {\n\t\t\tvar d2sum=0;\n\t\t\tfor(var pos1 in confine) {\n\t\t\t\tvar d=distance[pos][pos1];\n\t\t\t\td2sum+=d*d;\n\t\t\t}\n\t\t\tif(d2sum>cornerDist) {\n\t\t\t\tcorners={};\n\t\t\t\tcorners[pos]=1;\n\t\t\t\tcornerDist=d2sum;\n\t\t\t} else if(d2sum==cornerDist)\n\t\t\t\tcorners[pos]=1;\n\t\t}\n\t\t\n\t\tvar distEdges={};\n\t\tvar modifs=true;\n\t\twhile(modifs) {\n\t\t\tmodifs=false;\n\t\t\tfor(var pos in confine) {\n\t\t\t\tif(pos in distEdges)\n\t\t\t\t\tcontinue;\n\t\t\t\tsteps.forEach(function(delta) {\n\t\t\t\t\tvar pos1=Graph(pos,delta);\n\t\t\t\t\tif(pos1==null)\n\t\t\t\t\t\tdistEdges[pos]=1;\n\t\t\t\t\telse if(pos1 in distEdges) {\n\t\t\t\t\t\tif(!(pos in distEdges) || distEdges[pos]>distEdges[pos1]+1) {\n\t\t\t\t\t\t\tdistEdges[pos]=distEdges[pos1]+1;\n\t\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction C(pos) {\n\t\t\treturn pos%width;\n\t\t}\n\t\tfunction R(pos) {\n\t\t\treturn Math.floor(pos/width);\n\t\t}\n\t\tfunction POS(c,r) {\n\t\t\treturn r*width+c;\n\t\t}\n\t\tfunction PosName(pos) {\n\t\t\tif(posNames[pos]!==undefined)\n\t\t\t\treturn posNames[pos];\n\t\t\treturn String.fromCharCode((\"a\".charCodeAt(0))+C(pos)) + (R(pos)+1);\n\t\t}\n\t\tfunction PosByName(str) {\n\t\t\tif(posNamesInv[str]!==undefined)\n\t\t\t\treturn posNamesInv[str];\n\t\t\tvar m=/^([a-z])([0-9]+)$/.exec(str);\n\t\t\tif(!m)\n\t\t\t\treturn -1;\n\t\t\tvar c=m[1].charCodeAt(0)-\"a\".charCodeAt(0);\n\t\t\tvar r=parseInt(m[2])-1;\n\t\t\treturn POS(c,r);\n\t\t}\n\t\tfunction CompactCrit(pos,index) {\n\t\t\tif(index==0)\n\t\t\t\treturn String.fromCharCode((\"a\".charCodeAt(0))+C(pos));\n\t\t\telse if(index==1)\n\t\t\t\treturn (R(pos)+1);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t\tfunction GetDistances() {\n\t\t\treturn distance;\n\t\t}\n\t\tfunction CellType(col,row) {\n\t\t\tvar cellType=boardLayout[boardLayout.length-1-row][col*2];\n\t\t\tif(cellType==' ')\n\t\t\t\tcellType=boardLayout[boardLayout.length-1-row][col*2+1] || ' ';\n\t\t\treturn cellType;\n\t\t}\n\t\t\n\t\treturn {\n\t\t\tboardSize: width*height,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tC: C,\n\t\t\tR: R,\n\t\t\tPOS: POS,\n\t\t\tGraph: Graph, \n\t\t\tPosName: PosName,\n\t\t\tPosByName: PosByName,\n\t\t\tCompactCrit: CompactCrit,\n\t\t\tGetDistances: GetDistances,\n\t\t\tdistEdge: distEdges,\n\t\t\tcorners: corners,\n\t\t\tSHIFTMOD2: SHIFTMOD2,\n\t\t\tSHIFTRIGHT: SHIFTRIGHT,\n\t\t\tCellType: CellType,\n\t\t\tconfine: confine,\n\t\t};\n\t}\n\t\n\tvar CT = Model.Game.cbConstants;\n\n\tvar lineDeltas=[[1,0,0],[0,1,0],[0,0,1],[-1,0,0],[0,-1,0],[0,0,-1]];\n\tvar edgeDeltas=[[1,1,0],[0,1,1],[-1,0,1],[-1,-1,0],[0,-1,-1],[1,0,-1]];\n\tvar knightDeltas=[[2,1,0],[1,2,0],[0,2,1],[0,1,2],[-1,0,2],[-2,0,1],[-2,-1,0],[-1,-2,0],[0,-2,-1],[0,-1,-2],[1,0,-2],[2,0,-1]];\n\n\tModel.Game.cbGLKingGraph = function(geometry) {\n\t\treturn this.cbShortRangeGraph(geometry,edgeDeltas.concat(lineDeltas),geometry.confine);\n\t}\n\n\tModel.Game.cbGLRookGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,lineDeltas,geometry.confine);\n\t}\n\n\tModel.Game.cbGLBishopGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,edgeDeltas,geometry.confine);\n\t}\n\n\tModel.Game.cbGLQueenGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,edgeDeltas.concat(lineDeltas),geometry.confine);\n\t}\n\n\tModel.Game.cbGLKnightGraph = function(geometry) {\n\t\treturn this.cbShortRangeGraph(geometry,knightDeltas,geometry.confine);\n\t}\n\n\tModel.Game.cbGLPawnGraph = function(geometry,side,range) {\n\t\tvar moveGraph = this.cbLongRangeGraph(geometry,[[side,0,0]],geometry.confine,CT.FLAG_MOVE,range);\n\t\tvar captDeltas = {\n\t\t\t'1': [[0,1,0],[0,0,-1]],\n\t\t\t'-1': [[0,0,1],[0,-1,0]],\n\t\t}\n\t\tvar captGraph = this.cbShortRangeGraph(geometry,captDeltas[side],geometry.confine,CT.FLAG_CAPTURE);\n\t\tvar graph = [];\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++)\n\t\t\tgraph[pos] = moveGraph[pos].concat(captGraph[pos]); \n\t\treturn graph;\n\t}\n\n\tModel.Game.cbBRInitialPawnGraph = function(geometry,side) {\n\t\tvar moveGraph = this.cbLongRangeGraph(geometry,[[0,-side,0],[0,0,-side]],geometry.confine,CT.FLAG_MOVE,2);\n\t\tvar captGraph = this.cbShortRangeGraph(geometry,[[-side,-side,0],[side,0,-side],[0,-side,-side]],geometry.confine,CT.FLAG_CAPTURE);\n\t\tvar graph = [];\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++)\n\t\t\tgraph[pos] = moveGraph[pos].concat(captGraph[pos]); \n\t\treturn graph;\n\t}\n\n\tModel.Game.cbDVInitialPawnGraph = function(geometry,side) {\n\t\tvar moveGraph = this.cbLongRangeGraph(geometry,[[0,-side,0],[0,0,-side]],geometry.confine,CT.FLAG_MOVE,2);\n\t\tvar captGraph = this.cbShortRangeGraph(geometry,[[-side,-side,0],[side,0,-side]],geometry.confine,CT.FLAG_CAPTURE);\n\t\tvar graph = [];\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++)\n\t\t\tgraph[pos] = moveGraph[pos].concat(captGraph[pos]); \n\t\treturn graph;\n\t}\n\n\tModel.Game.cbBRPawnGraph = function(geometry,side) {\n\t\tvar moveGraph = this.cbShortRangeGraph(geometry,[[0,-side,0],[0,0,-side]],geometry.confine,CT.FLAG_MOVE);\n\t\tvar captGraph = this.cbShortRangeGraph(geometry,[[-side,-side,0],[side,0,-side]],geometry.confine,CT.FLAG_CAPTURE);\n\t\tvar graph = [];\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++)\n\t\t\tgraph[pos] = moveGraph[pos].concat(captGraph[pos]); \n\t\treturn graph;\n\t}\n\n\tModel.Game.cbMCPawnGraph = function(geometry,side,range) {\n\t\tvar moveGraph = this.cbLongRangeGraph(geometry,[[side,0,0]],geometry.confine,CT.FLAG_MOVE,range);\n\t\tvar captGraph = this.cbShortRangeGraph(geometry,[[side,0,-side],[side,side,0]],geometry.confine,CT.FLAG_CAPTURE);\n\t\tvar graph = [];\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++)\n\t\t\tgraph[pos] = moveGraph[pos].concat(captGraph[pos]); \n\t\treturn graph;\n\t}\n\n\n\t\n\n\t\n})();\n"],"file":"devasa-chess-model.js"}