{"version":3,"names":[],"mappings":"","sources":["multiplan-board-view.js"],"sourcesContent":["\n(function() {\n\t\n\tvar JOCLY_FIELD_SIZE=12000; // physical space\n\n\tvar NBCOLS=0, NBROWS=0, NBFLOORS=0, CSIZES={};\n\n\tView.Game.cbTargetMesh = \"/res/ring-target-square-v2.js\";\n\t\n\tView.Game.cbEnsureConstants = function() {\n\t\tif(!NBFLOORS)\n\t\t\tNBFLOORS=this.cbView.boardLayout.length;\n\t\tif(!NBROWS)\n\t\t\tNBROWS=this.cbView.boardLayout[0].length;\n\t\tif(!NBCOLS)\n\t\t\tNBCOLS=this.cbView.boardLayout[0][0].length;\t\t\n\t}\n\t\n\t// 'this' is a Game object\n\tView.Game.cbCSize =function(boardSpec,floor) {\n\t\tvar margins=boardSpec.margins;\n\t\tif(floor!==undefined)\n\t\t\tif(boardSpec.boardFloorMargins!==undefined && boardSpec.boardFloorMargins[floor]!==undefined)\n\t\t\t\tmargins=boardSpec.boardFloorMargins[floor];\n\t\t\n\t\tvar cSize=CSIZES[boardSpec.flat+\"_\"+margins.x+\"_\"+margins.y];\n\t\tif(!cSize) {\n\t\t\tthis.cbEnsureConstants();\n\t\t\t\n\t\t\tvar ratio,width,height,cellSize;\n\t\t\t\n\t\t\tvar relWidth = NBCOLS+2*boardSpec.margins.x;\n\t\t\tvar relHeight = NBROWS+2*boardSpec.margins.y;\n\t\t\t\n\t\t\tratio =  relWidth / relHeight;\n\t\t\tif(ratio<1)\n\t\t\t\tcellSize = (JOCLY_FIELD_SIZE * ratio) / relWidth;\n\t\t\telse \n\t\t\t\tcellSize = (JOCLY_FIELD_SIZE / ratio) / relHeight;\n\t\t\twidth = (NBCOLS+2*boardSpec.margins.x) * cellSize;\n\t\t\theight= (NBROWS+2*boardSpec.margins.y) * cellSize;\n\t\t\t\n\n\t\t\tif(boardSpec.flat)\n\t\t\t\tcellSize = boardSpec.boardFloorSize / Math.max(NBCOLS+2*margins.x,NBCOLS+2*margins.y);\n\t\t\t\n\t\t\tcSize={\n\t\t\t\tcx:cellSize,\n\t\t\t\tcy:cellSize,\n\t\t\t\tpieceCx:cellSize,\n\t\t\t\tpieceCy:cellSize,\n\t\t\t\tratio: ratio,\n\t\t\t\twidth: (NBCOLS+2*margins.x) * cellSize,\n\t\t\t\theight: (NBROWS+2*margins.y) * cellSize,\n\t\t\t}\n\t\t\tCSIZES[boardSpec.flat+\"_\"+margins.x+\"_\"+margins.y]=cSize;\n\t\t}\n\t\treturn cSize;\n\t}\n\t\n\tView.Game.cbMultiplanBoard = $.extend({},View.Game.cbBaseBoard,{\n\t\t\n\t\tnotationMode: \"out\", // notation outside the board\n\t\tinterFloorsDist: 2500,\n\t\t\n\t\t// 'this' is a Game object\n\t\tcoordsFn: function(boardSpec) {\n\t\t\t\n\t\t\tboardSpec = boardSpec || {};\n\t\t\tboardSpec.margins = boardSpec.margins || {x:0,y:0};\n\t\t\t\n\t\t\treturn function(pos,floor) {\n\t\t\t\tthis.cbEnsureConstants();\n\t\t\t\tvar f=Math.floor(pos/(NBCOLS*NBROWS));\n\t\t\t\tvar c=pos%NBCOLS;\n\t\t\t\tvar r=((pos%(NBCOLS*NBROWS))-c)/NBCOLS;\n\t\t\t\tvar cSize = this.cbCSize(boardSpec,floor);\n\t\t\t\tif(this.mViewAs==1)\n\t\t\t\t\tr=NBROWS-1-r;\n\t\t\t\tif(this.mViewAs==-1)\n\t\t\t\t\tc=NBCOLS-1-c;\n\t\t\t\tvar coords={\n\t\t\t\t\tx:(c-(NBCOLS-1)/2)*cSize.cx,\n\t\t\t\t\ty:(r-(NBROWS-1)/2)*cSize.cy,\n\t\t\t\t};\n\t\t\t\tif(!boardSpec.flat)\n\t\t\t\t\tcoords.z = f*boardSpec.interFloorsDist;\n\t\t\t\telse {\n\t\t\t\t\tvar plan=boardSpec.boardFloor2dPos[f];\n\t\t\t\t\tcoords.x+=plan.x;\n\t\t\t\t\tcoords.y+=plan.y;\n\t\t\t\t}\n\t\t\t\treturn coords;\n\t\t\t}\n\t\t},\n\t\t\n\t\tcreateGeometry: function(spec,floor,callback) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tconsole.log(\"geometry\",floor,cSize)\n\t\t\tvar cx = cSize.width/1000;\n\t\t\tvar cy = cSize.height/1000;\n\t\t\t\n\t\t\tvar geo = new THREE.PlaneGeometry(cx,cy);\n\t\t\t\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\tmatrix.makeRotationX(-Math.PI/2)\n\t\t\tgeo.applyMatrix(matrix);\n\n\t\t\tvar uvs=geo.faceVertexUvs[0];\n\t\t\tfor (var u = 0 ; u < uvs.length ; u++){\n\t\t\t\tfor (var i = 0 ; i < uvs[u].length ; i++){\n\t\t\t\t\tif(cSize.ratio<1)\n\t\t\t\t\t\tuvs[u][i].x=uvs[u][i].x*cSize.ratio+(1-cSize.ratio)/2;\n\t\t\t\t\tif(cSize.ratio>1)\n\t\t\t\t\t\tuvs[u][i].y=uvs[u][i].y/cSize.ratio+(1-1/cSize.ratio)/2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcallback(geo);\n\t\t},\n\n\t\tpaintBackground: function(spec,ctx,images,floor,channel,bWidth,bHeight,x0,y0) {\n\t\t\tif (images['boardBG'])\n\t\t\t\tctx.drawImage(images['boardBG'],x0-bWidth/2,y0-bHeight/2,bWidth,bHeight);\t\t\t\t\n\t\t},\t\t\n\n\t\tpaintChannel: function(spec,ctx,images,floor,channel,x0,y0) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tspec.paintBackground.call(this,spec,ctx,images,floor,channel,cSize.width,cSize.height,x0,y0);\t\t\t\n\t\t},\n\t\t\n\t\tpaint: function(spec,canvas,images,floor,callback) {\n\t\t\tfor(var channel in canvas) {\n\t\t\t\tvar ctx=canvas[channel].getContext('2d');\n\t\t\t\tctx.scale(spec.TEXTURE_CANVAS_CX/JOCLY_FIELD_SIZE,spec.TEXTURE_CANVAS_CY/JOCLY_FIELD_SIZE);\n\t\t\t\tctx.translate(JOCLY_FIELD_SIZE/2,JOCLY_FIELD_SIZE/2);\n\t\t\t\tspec.paintChannel.call(this,spec,ctx,images,floor,channel,0,0);\n\t\t\t}\n\t\t\tcallback();\n\t\t},\n\n\t\tdisplay: function(spec, avatar, callback) {\n\t\t\tvar $this=this;\n\t\t\tspec.getResource=avatar.getResource;\n\t\t\tvar nbMeshesLeft=this.cbView.boardLayout.length;\n\t\t\tvar meshes={}\n\t\t\tfunction AddMesh(mesh,floor) {\n\t\t\t\tmesh.visible=true;\n\t\t\t\tmeshes[floor]=mesh;\n\t\t\t\tif(--nbMeshesLeft==0) {\n\t\t\t\t\tvar fullMesh=new THREE.Object3D();\n\t\t\t\t\tfor(var floor=0;floor<$this.cbView.boardLayout.length;floor++) {\n\t\t\t\t\t\tvar mesh=meshes[floor];\n\t\t\t\t\t\tfullMesh.add(mesh);\n\t\t\t\t\t\tmesh.translateY(floor*spec.interFloorsDist/1000);\n\t\t\t\t\t}\n\t\t\t\t\tcallback(fullMesh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var floor=0;floor<this.cbView.boardLayout.length;floor++) {\n\t\t\t\t(function(floor) {\n\t\t\t\t\tspec.createGeometry.call($this,spec,floor,function(geometry) {\n\t\t\t\t\t\tspec.createTextureImages.call($this,spec,function(images) {\n\t\t\t\t\t\t\tvar channels=['diffuse'].concat(spec.extraChannels || []);\n\t\t\t\t\t\t\tvar canvas={};\n\t\t\t\t\t\t\tchannels.forEach(function(channel) {\n\t\t\t\t\t\t\t\tvar canvas0=document.createElement('canvas');\n\t\t\t\t\t\t\t\tcanvas0.width=spec.TEXTURE_CANVAS_CX;\n\t\t\t\t\t\t\t\tcanvas0.height=spec.TEXTURE_CANVAS_CY;\n\t\t\t\t\t\t\t\tcanvas[channel]=canvas0;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tspec.createMaterial.call($this,spec,canvas,function(material) {\n\t\t\t\t\t\t\t\tif(spec.boardFloorOpacity!==undefined && spec.boardFloorOpacity[floor]!==undefined) {\n\t\t\t\t\t\t\t\t\tvar opacity=spec.boardFloorOpacity[floor];\n\t\t\t\t\t\t\t\t\tif(opacity!=1) {\n\t\t\t\t\t\t\t\t\t\tmaterial.opacity=opacity;\n\t\t\t\t\t\t\t\t\t\tmaterial.transparent=true;\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmaterial.side = THREE.DoubleSide;\n\t\t\t\t\t\t\t\tvar mesh=new THREE.Mesh(geometry,material);\n\t\t\t\t\t\t\t\tspec.modifyMesh.call($this,spec,mesh,floor,function(mesh) {\n\t\t\t\t\t\t\t\t\tspec.paint.call($this,spec,canvas,images,floor,function() {\n\t\t\t\t\t\t\t\t\t\tAddMesh(mesh,floor);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\t\t\t\t\t\n\t\t\t\t\t});\n\t\t\t\t})(floor);\n\t\t\t}\n\t\t},\n\t\t\n\t\tdraw: function(spec,avatar,ctx) {\n\t\t\tvar $this=this;\n\t\t\tspec.getResource=avatar.getResource;\n\t\t\tctx.save();\n\t\t\tspec.createTextureImages.call(this,spec,function(images) {\n\t\t\t\tfor(var floor=0;floor<$this.cbView.boardLayout.length;floor++) {\n\t\t\t\t\tvar plan=spec.boardFloor2dPos[floor];\n\t\t\t\t\tspec.paintChannel.call($this,spec,ctx,images,floor,\"diffuse\",plan.x,plan.y);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t});\n\t\t},\n\n\n\t});\n\n\tView.Game.cbMultiplanBoardClassic = $.extend({},View.Game.cbMultiplanBoard,{\n\t\t'colorFill' : {\t\t\n\t\t\t\".\": \"rgba(160,150,150,0.9)\", // \"white\" cells\n\t\t\t\"#\": \"rgba(0,0,0,1)\", // \"black\" cells\n\t\t\t\" \": \"rgba(0,0,0,0)\",\n\t\t},\n\t\t'texturesImg' : {\n\t\t\t'boardBG' : '/res/images/wood.jpg',\n\t\t},\n\t\tmodifyMesh: function(spec,mesh,floor,callback) {\n\t\t\tif(spec.boardFloorFrames!==undefined && spec.boardFloorFrames[floor]!==undefined && \n\t\t\t\t\tspec.boardFloorFrames[floor]==false) {\n\t\t\t\tcallback(mesh);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tvar cx = cSize.width/1000;\n\t\t\tvar cy = cSize.height/1000;\n\n\t\t\t// add border frame\n\t\t\tfunction setupShapeSquare(cx,cy){\n\t\t\t\tvar sh = new THREE.Shape();\n\t\t\t\tsh.moveTo(-cx/2 , -cy/2);\n\t\t\t\tsh.lineTo(cx/2 , -cy/2);\n\t\t\t\tsh.lineTo(cx/2 , cy/2);\n\t\t\t\tsh.lineTo(-cx/2 , cy/2);\n\t\t\t\treturn sh;\t\t\n\t\t\t}\t\t\t\t\t\n\t\t\tvar bevelSize = .1;\n\t\t\tvar frameWidth=0.5;\n\t\t\tvar frameShape = setupShapeSquare(cx+frameWidth+bevelSize, cy+frameWidth+bevelSize);\n\t\t\tvar holeShape = setupShapeSquare(cx+bevelSize,cy+bevelSize);\n\t\t\tframeShape.holes.push(holeShape);\n\n\t\t\tvar extrudeSettings = {\n\t\t\t\tamount: .4 , // main extrusion thickness\n\t\t\t\tsteps: 1 , // nb of main extrusion steps\n\t\t\t\tbevelSize: bevelSize, \n\t\t\t\tbevelThickness:.04,\n\t\t\t\tbevelSegments: 1, // nb of bevel segment\n\t\t\t};\n\n\t\t\tvar frameGeo = new THREE.ExtrudeGeometry( frameShape, extrudeSettings );\n\t\t\t\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\tmatrix.makeRotationX(-Math.PI/2)\n\t\t\tframeGeo.applyMatrix(matrix);\n\t\t\t\n\t   \t \tblackMat = new THREE.MeshPhongMaterial({\n\t   \t\t\t color: '#000000',\n\t   \t\t\t shininess: 500,\n\t   \t\t\t specular: '#888888',\n\t   \t\t\t emissive: '#000000',\n\t   \t\t });\n\t\t\tvar frameObj = new THREE.Mesh( frameGeo , blackMat);\n\t\t\tframeObj.position.y=-extrudeSettings.amount-.01;\n\t\t\tmesh.add(frameObj);\n\t\t\tvar bottom = new THREE.Mesh(new THREE.BoxGeometry(cx,cy,0.1),blackMat);\n\t\t\tbottom.rotation.x=Math.PI/2;\n\t\t\tbottom.position.y=-.1;\n\t\t\tmesh.add(bottom);\n\t\t\tcallback(mesh);\n\t\t},\n\t\t\n\t\tpaintCell: function(spec,ctx,images,floor,channel,cellType,xCenter,yCenter,cx,cy) {\n\t\t\tctx.strokeStyle = \"rgba(0,0,0,1)\";\n\t\t\tctx.lineWidth = 15;\n\t\t\tif (channel=='bump')\n\t\t\t\tctx.fillStyle=\"#ffffff\";\n\t\t\telse\n\t\t\t\tctx.fillStyle=spec.colorFill[cellType];\n\t\t\tctx.fillRect(xCenter-cx/2,yCenter-cy/2,cx,cy);\n\t\t\tctx.rect(xCenter-cx/2,yCenter-cy/2,cx,cy);\n\t\t},\n\t\t\n\t\tpaintCells: function(spec,ctx,images,floor,channel,x0,y0) {\n\t\t\tvar cSize = this.cbCSize(spec,floor);\n\t\t\tvar getCoords=spec.coordsFn(spec);\n\t\t\tfor(var row=0;row<NBROWS;row++) {\n\t\t\t\tfor(var col=0;col<NBCOLS;col++) {\n\t\t\t\t\tvar pos = this.mViewAs==1 ?\n\t\t\t\t\t\tcol+row*NBCOLS+floor*NBCOLS*NBROWS :\n\t\t\t\t\t\tNBCOLS*NBROWS-(1+col+row*NBCOLS);\n\t\t\t\t\tvar coords=getCoords.call(this,pos,floor);\n\t\t\t\t\tvar cellType=this.cbView.boardLayout[floor][NBROWS-row-1][col];\n\t\t\t\t\tvar xCenter=coords.x;\n\t\t\t\t\tvar yCenter=coords.y;\n\t\t\t\t\tvar cx=cSize.cx;\n\t\t\t\t\tvar cy=cSize.cy;\n\t\t\t\t\t\n\t\t\t\t\tspec.paintCell.call(this,spec,ctx,images,floor,channel,cellType,xCenter,yCenter,cx,cy);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\tpaintLines: function(spec,ctx,images,floor,channel,x0,y0) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tctx.strokeStyle = \"#000000\";\n\t\t\tctx.lineWidth = 40;\n\t\t\tctx.strokeRect(x0-NBCOLS*cSize.cx/2,y0-NBROWS*cSize.cy/2,NBCOLS*cSize.cx,NBROWS*cSize.cy);\n\t\t},\n\n\t\tpaintChannel: function(spec,ctx,images,floor,channel,x0,y0) {\n\t\t\tvar cSize = this.cbCSize(spec,floor);\n\t\t\tif(spec.boardFloorFrames===undefined || spec.boardFloorFrames[floor])\n\t\t\t\tspec.paintBackground.call(this,spec,ctx,images,channel,floor,cSize.width,cSize.height,x0,y0);\n\t\t\tspec.paintCells.call(this,spec,ctx,images,floor,channel,x0,y0)\n\t\t\tspec.paintLines.call(this,spec,ctx,images,floor,channel,x0,y0);\n\t\t\tif(this.mNotation)\n\t\t\t\tspec.paintNotation.call(this,spec,ctx,floor,channel,x0,y0);\n\t\t},\n\t\t\n\t\tpaintNotation: function(spec,ctx,floor,channel,x0,y0) {\n\t\t\tvar cSize = this.cbCSize(spec,floor);\n\t\t\tctx.textAlign = 'center';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.fillStyle = \"#000000\";\n\t\t\tctx.font = Math.ceil(cSize.cx / 3) + 'px Monospace';\n\t\t\tswitch(spec.notationMode) {\n\t\t\tcase \"out\":\n\t\t\t\tspec.paintOutNotation.apply(this,arguments);\n\t\t\t\tbreak;\n\t\t\tcase \"in\":\n\t\t\t\tspec.paintInNotation.apply(this,arguments);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t\t\n\t\tpaintOutNotation: function(spec,ctx,floor,channel,x0,y0) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tfor (var row = 0; row < NBROWS; row++) {\n\t\t\t\tvar displayedRow = NBROWS - row;\n\t\t\t\tif(this.mViewAs<0)\n\t\t\t\t\tdisplayedRow=row+1;\n\t\t\t\tvar x = -(NBCOLS/2 + spec.margins.x/2) * cSize.cx;\n\t\t\t\tvar y = (row-NBROWS/2+.5) * cSize.cy;\n\t\t\t\tctx.fillText(displayedRow, x+x0, y+y0);\t\n\t\t\t}\n\t\t\tfor (var col = 0; col < NBCOLS; col++) {\n\t\t\t\tvar displayedCol=col;\n\t\t\t\tif(this.mViewAs<0)\n\t\t\t\t\tdisplayedCol = NBCOLS - col -1;\n\t\t\t\tvar x = (col-NBCOLS/2+.5) * cSize.cx;\n\t\t\t\tvar y = (NBROWS/2 + spec.margins.y/2) * cSize.cy;\n\t\t\t\tctx.fillText(String.fromCharCode(97 + displayedCol), x+x0 , y+y0);\n\t\t\t}\n\t\t},\n\t\t\n\t\tpaintInNotation: function(spec,ctx,floor,channel,x0,y0) {\n\t\t\tvar cSize = this.cbCSize(spec);\n\t\t\tvar getCoords=spec.coordsFn(spec);\n\t\t\tvar fills=spec.colorFill;\n\t\t\tctx.font = Math.ceil(cSize.cx / 5) + 'px Monospace';\n\t\t\tfor (var row = 0; row < NBROWS; row++) {\n\t\t\t\tfor (var col = 0; col < NBCOLS; col++) {\n\t\t\t\t\tvar displayedRow=NBROWS - row;\n\t\t\t\t\tvar displayedCol=col;\n\t\t\t\t\tif(this.mViewAs<0)\n\t\t\t\t\t\tdisplayedCol = NBCOLS - col -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tdisplayedRow=row+1;\t\t\t\t\t\t\t\t\n\t\t\t\t\tvar pos = this.mViewAs==1 ?\n\t\t\t\t\t\t\tcol+row*NBCOLS :\n\t\t\t\t\t\t\tNBCOLS*NBROWS-(1+col+row*NBCOLS);\n\t\t\t\t\tpos+=floor*NBCOLS*NBROWS;\n\t\t\t\t\tvar coords;\n\t\t\t\t\tif(spec.flat) {\n\t\t\t\t\t\tcoords=getCoords.call(this,pos);\n\t\t\t\t\t\tcoords.x-=x0;\n\t\t\t\t\t\tcoords.y-=y0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcoords=getCoords.call(this,pos,floor);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillStyle=\"rgba(0,0,0,0)\";\n\t\t\t\t\tif(channel==\"bump\")\n\t\t\t\t\t\tctx.fillStyle = fills[\".\"];\n\t\t\t\t\tswitch(this.cbView.boardLayout[floor][NBROWS-row-1][col]) {\n\t\t\t\t\tcase \".\":\n\t\t\t\t\t\tctx.fillStyle= (channel==\"bump\") ? fills[\".\"] : fills[\"#\"];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"#\":\n\t\t\t\t\t\tctx.fillStyle=fills[\".\"];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvar x = coords.x-cSize.cx / 3.5;\n\t\t\t\t\tvar y = coords.y-cSize.cy / 3;\n\t\t\t\t\tif(spec.notationDebug)\n\t\t\t\t\t\tctx.fillText(pos,x,y);\n\t\t\t\t\telse\n\t\t\t\t\t\tctx.fillText(this.cbVar.geometry.PosName(pos),x+x0,y+y0);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n\n\tView.Game.cbMultiplanBoardClassic2D = $.extend({},View.Game.cbMultiplanBoardClassic,{\n\t\t'colorFill' : {\t\t\n\t\t\t\".\": \"rgba(231,208,167,1)\", // \"white\" cells\n\t\t\t\"#\": \"rgba(152,113,82,1)\", // \"black\" cells\n\t\t\t\" \": \"rgba(0,0,0,0)\",\n\t\t},\n\t\t'flat': true,\n\t});\n\n\tView.Game.cbMultiplanBoardClassic3D = $.extend({},View.Game.cbMultiplanBoardClassic,{\n\t\t'flat': false,\n\t});\n\t\n\tView.Game.cbMultiplanBoardClassic3DMargin = $.extend({},View.Game.cbMultiplanBoardClassic3D,{\n\t\t'margins' : {x:.67,y:.67},\n\t\t'extraChannels':[ // in addition to 'diffuse' which is default\n\t\t\t'bump'\n\t\t],\n\t\t/*\n\t\t'mesh': { // not implemented yet\n\t\t\tjsfile:\"/res/xd-view/meshes/taflboard.js\",\n\t\t\tmeshScale:1.32,\n\t\t\tboardMaterialName:\"board\",\n\t\t}\n\t\t*/\n\t});\n\t\n\tView.Game.cbMultiplanBoardClassic2DMargin = $.extend({},View.Game.cbMultiplanBoardClassic2D,{\n\t\t'margins' : {x:.67,y:.67},\n\t});\n\n\tView.Game.cbMultiplanBoardClassic2DNoMargin = $.extend({},View.Game.cbMultiplanBoardClassic2D,{\n\t\t'margins' : {x:0.0,y:0.0},\n\t\t'notationMode': 'in',\n\t});\n\n\t\n\t\n})();\n"],"file":"raumschach-view.js"}