{"version":3,"sources":["jocly.util.js","jocly.uct.js","jocly.game.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACttBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC36BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jocly.game.js","sourcesContent":["/*    Copyright 2017 Jocly\n *\n *    This program is free software: you can redistribute it and/or  modify\n *    it under the terms of the GNU Affero General Public License, version 3,\n *    as published by the Free Software Foundation.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU Affero General Public License for more details.\n *\n *    You should have received a copy of the GNU Affero General Public License\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *    As a special exception, the copyright holders give permission to link the\n *    code of portions of this program with the OpenSSL library under certain\n *    conditions as described in each individual source file and distribute\n *    linked combinations including the program with the OpenSSL library. You\n *    must comply with the GNU Affero General Public License in all respects\n *    for all of the code used other than as permitted herein. If you modify\n *    file(s) with this exception, you may extend this exception to your\n *    version of the file(s), but you are not obligated to do so. If you do not\n *    wish to do so, delete this exception statement from your version. If you\n *    delete this exception statement from all source files in the program,\n *    then also delete it in the license file.\n */\n\nfunction JocLog() {\n\tif(typeof jQuery!=\"undefined\") {\n\t\tvar strs=[];\n\t\tfor(var i=0;i<arguments.length;i++) {\n\t\t\tvar str=arguments[i];\n\t\t\tif(typeof(str)!=\"string\")\n\t\t\t\tstr=JSON.stringify(str);\t\t\n\t\t\tstrs.push(\"\"+str);\n\t\t}\n\t\tjQuery(\"<p/>\").text(strs.join(\" \")).appendTo(jQuery(\"#jocly-log\"));\n\t} else\n\t\tconsole.warn.apply(console,arguments);\n}\n\nvar JocUtil = {\n\tJSON: JSON\n}\n\nJocUtil.reload = function() {\n\twindow.location.reload();\n}\n\nJocUtil.setTimeout=function(fnt,timeout) {\n\treturn setTimeout(fnt,timeout);\n}\n\nJocUtil.setInterval=function(fnt,timeout) {\n\treturn setInterval(fnt,timeout);\n}\n\nJocUtil.clearTimeout=function(timer) {\n\tclearTimeout(timer);\n}\n\nJocUtil.schedule=function(target,method,args) {\n\tJocUtil.setTimeout(function() { target[method](args); }, 0);\n}\n\nJocUtil.setPref=function(aPrefName,aValue,options) {\n\tvar prefName='jocly_pref';\n\tif(arguments.length<3)\n\t\toptions={}\n\tif(options.appId)\n\t\tprefName+=\"_\"+options.appId;\n\tif(options.game)\n\t\tprefName+=\"_\"+options.game;\n\tprefName+=\"_\"+aPrefName;\n\tif(typeof(aValue)==\"boolean\")\n\t\taValue=\"$#@\"+aValue;\n\tif(typeof(aValue)==\"object\" || typeof(aValue)==\"array\")\n\t\taValue=\"$#@JSON@\"+JSON.stringify(aValue);\n\t//alert(\"setPref(\"+prefName+\",\"+aValue+\") \"+typeof(aValue));\n\twindow.localStorage.setItem(prefName,aValue);\n}\n\nJocUtil.getPref=function(aPrefName,options) {\n\tvar prefName='jocly_pref';\n\tif(arguments.length<2)\n\t\toptions={}\n\tif(options.appId)\n\t\tprefName+=\"_\"+options.appId;\n\tif(options.game)\n\t\tprefName+=\"_\"+options.game;\n\tprefName+=\"_\"+aPrefName;\n\tvar value=window.localStorage.getItem(prefName);\n\tif(value==\"$#@true\")\n\t\tvalue=true;\n\telse if(value==\"$#@false\")\n\t\tvalue=false;\n\telse if(typeof(value)==\"string\" && value.substr(0,8)==\"$#@JSON@\")\n\t\tvalue=JSON.parse(value.substr(8));\n\tif(value==null && typeof options.defaultValue!=\"undefined\")\n\t\tvalue=options.defaultValue;\n\t//alert(\"getPref(\"+prefName+\") => \"+value+\" \"+typeof(value));\n\treturn value;\n}\n\nJocUtil.filterLevels=function(levels,maxLevel,defaultLevel) {\n\tfunction Calibrate() {\n\t\tvar timer0=new Date().getTime();\n\t\tvar n=1000;\n\t\tvar m=100;\n\t\tvar a=[];\n\t\tvar b=[];\n\t\tfor(var i=0;i<m;i++) {\n\t\t\ta.push(i);\n\t\t}\n\t\tfor(var i=0;i<n;i++) {\n\t\t\twhile(a.length>0)\n\t\t\t\tb.push(a.shift());\n\t\t\tvar c=a;\n\t\t\ta=b;\n\t\t\tb=c;\n\t\t}\n\t\tvar timer1=new Date().getTime();\n\t\treturn timer1-timer0;\n\t}\n\tvar calibration=parseInt(JocUtil.getPref(\"calibration\",{defaultValue:0}));\n\tvar calibrationDate=parseInt(JocUtil.getPref(\"calibrationDate\",{defaultValue:0}));\n\tif(calibrationDate<new Date().getTime()-24*60*60*1000)\n\t\tcalibration=0;\n\tvar maxTime=60000;\n\tvar bestDefaultMaxTime=3000;\n\tvar levels0=[];\n\tif(levels) {\n\t\tvar bestLevel=null;\n\t\tvar bestLevelTime=0;\n\t\tvar bestLevelForced=false;\n\t\tfor(var k in levels) {\n\t\t\tvar level=levels[k];\n\t\t\tif(level.isDefault) {\n\t\t\t\tbestLevel=level;\n\t\t\t\tbestLevelFound=true;\n\t\t\t}\n\t\t\tlevel.isDefault=false;\n\t\t\tlevel.fullLabel=strings[\"comp-level\"]+\" \"+level.label;\n\t\t\tlevel.optionValue=k;\n\t\t\tif(level.calRatio) {\n\t\t\t\tif(!calibration) {\n\t\t\t\t\tcalibration=Calibrate();\n\t\t\t\t\tJocLog(\"Calibration\",calibration);\n\t\t\t\t\tJocUtil.setPref(\"calibration\",calibration,{});\n\t\t\t\t\tJocUtil.setPref(\"calibrationDate\",new Date().getTime(),{});\n\t\t\t\t}\n\t\t\t\tvar levelTime=calibration*level.calRatio;\n\t\t\t\tif(levelTime>maxTime && levels0.length>=2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(bestLevelForced==false) {\n\t\t\t\t\tif(bestLevel==null || (levelTime<bestDefaultMaxTime && levelTime>bestLevelTime)) {\n\t\t\t\t\t\tbestLevel=level;\n\t\t\t\t\t\tbestLevelTime=levelTime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(bestLevel==null)\n\t\t\t\tbestLevel=level;\n\t\t\tlevels0.push(level);\n\t\t}\n\t\tif(bestLevel)\n\t\t\tbestLevel.isDefault=true;\n\t} else {\n\t\tvar maxLevel0=9;\n\t\tif(maxLevel)\n\t\t\tmaxLevel0=maxLevel;\n\t\tfor(var i=0;i<=maxLevel0;i++) {\n\t\t\tvar level={\n\t\t\t\tfullLabel: strings[\"comp-level\"]+\" \"+(i+1),\n\t\t\t\toptionValue: \"machine-\"+i,\n\t\t\t\tisDefault: false\n\t\t\t};\n\t\t\tif(typeof(defaultLevel)!=\"undefined\" && i==defaultLevel)\n\t\t\t\tlevel.isDefault=true;\n\t\t\tlevels0.push(level);\n\t\t}\n\t}\n\treturn levels0;\n}\n\nJocUtil.cookieSupportTested=false;\nJocUtil.cookieSupport=true;\nJocUtil.hasCookieSupport=function() {\n\tif(JocUtil.cookieSupportTested)\n\t\treturn JocUtil.cookieSupport;\n\tif(document.cookie.length==0) {\n\t\tvar date=new Date();\n\t\tdate.setTime(date.getTime()+365*24*60*60*1000);\n\t\tdocument.cookie=\"jocly=\"+escape(\"{}\")+\"; path=/; expires=\"+date.toGMTString()+\";\";\n\t\tif(document.cookie.length==0)\n\t\t\tJocUtil.cookieSupport=false;\n\t}\n\tJocUtil.cookieSupportTested=true;\n\treturn JocUtil.cookieSupport;\t\n}\n\nJocUtil.getCookieData=function() {\n\tif(JocUtil.hasCookieSupport()) {\n\t\tvar cookies=document.cookie.split(\";\");\n\t\tfor(var i in cookies) {\n\t\t\tvar c=/^ *(.*)$/.exec(cookies[i])[1];\n\t\t\tif(c.indexOf(\"jocly=\")==0) {\n\t\t\t\ttry {\n\t\t\t\t\treturn JSON.parse(unescape(c.substring(6)));\n\t\t\t\t} catch(e) {\n\t\t\t\t\tJocLog(\"Unable to parse cookie\",c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {};\n\t} else {\n\t\tvar value=window.localStorage.getItem(\"jocly\");\n\t\tif(value==null)\n\t\t\treturn {};\n\t\telse\n\t\t\treturn JSON.parse(value);\n\t}\n}\n\nJocUtil.setCookieData=function(name,value) {\n\tif(JocUtil.hasCookieSupport()) {\n\t\tvar jocly=JocUtil.getCookieData();\n\t\tif(value==null)\n\t\t\tdelete jocly[name];\n\t\telse\n\t\t\tjocly[name]=value;\n\t\tvar date=new Date();\n\t\tdate.setTime(date.getTime()+365*24*60*60*1000);\n\t\tvar cookie=\"jocly=\"+escape(JSON.stringify(jocly))+\"; path=/; expires=\"+date.toGMTString()+\";\";\n\t\tdocument.cookie=cookie;\n\t} else {\n\t\tvar jocly=window.localStorage.getItem(\"jocly\");\n\t\tif(jocly==null)\n\t\t\tjocly={};\n\t\telse\n\t\t\tjocly=JSON.parse(jocly);\n\t\tjocly[name]=value;\n\t\twindow.localStorage.setItem(\"jocly\",JSON.stringify(jocly));\t\n\t}\n}\n\nJocUtil.extend=function(target,obj) {\n\tfor(var i in obj)\n\t\ttarget[i]=obj[i];\n}\n\nJocUtil.md5=function(string) {\n\tfunction RotateLeft(lValue, iShiftBits) {\n\t\treturn (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n\t}\n\tfunction AddUnsigned(lX,lY) {\n\t\tvar lX4,lY4,lX8,lY8,lResult;\n\t\tlX8 = (lX & 0x80000000);\n\t\tlY8 = (lY & 0x80000000);\n\t\tlX4 = (lX & 0x40000000);\n\t\tlY4 = (lY & 0x40000000);\n\t\tlResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n\t\tif (lX4 & lY4) {\n\t\t\treturn (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n\t\t}\n\t\tif (lX4 | lY4) {\n\t\t\tif (lResult & 0x40000000) {\n\t\t\t\treturn (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n\t\t\t} else {\n\t\t\t\treturn (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n\t\t\t}\n\t\t} else {\n\t\t\treturn (lResult ^ lX8 ^ lY8);\n\t\t}\n \t}\n \tfunction F(x,y,z) { return (x & y) | ((~x) & z); }\n \tfunction G(x,y,z) { return (x & z) | (y & (~z)); }\n \tfunction H(x,y,z) { return (x ^ y ^ z); }\n\tfunction I(x,y,z) { return (y ^ (x | (~z))); }\n\tfunction FF(a,b,c,d,x,s,ac) {\n\t\ta = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n\t\treturn AddUnsigned(RotateLeft(a, s), b);\n\t};\n\tfunction GG(a,b,c,d,x,s,ac) {\n\t\ta = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n\t\treturn AddUnsigned(RotateLeft(a, s), b);\n\t};\n\tfunction HH(a,b,c,d,x,s,ac) {\n\t\ta = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n\t\treturn AddUnsigned(RotateLeft(a, s), b);\n\t};\n\tfunction II(a,b,c,d,x,s,ac) {\n\t\ta = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n\t\treturn AddUnsigned(RotateLeft(a, s), b);\n\t};\n\tfunction ConvertToWordArray(string) {\n\t\tvar lWordCount;\n\t\tvar lMessageLength = string.length;\n\t\tvar lNumberOfWords_temp1=lMessageLength + 8;\n\t\tvar lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n\t\tvar lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n\t\tvar lWordArray=Array(lNumberOfWords-1);\n\t\tvar lBytePosition = 0;\n\t\tvar lByteCount = 0;\n\t\twhile ( lByteCount < lMessageLength ) {\n\t\t\tlWordCount = (lByteCount-(lByteCount % 4))/4;\n\t\t\tlBytePosition = (lByteCount % 4)*8;\n\t\t\tlWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n\t\t\tlByteCount++;\n\t\t}\n\t\tlWordCount = (lByteCount-(lByteCount % 4))/4;\n\t\tlBytePosition = (lByteCount % 4)*8;\n\t\tlWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n\t\tlWordArray[lNumberOfWords-2] = lMessageLength<<3;\n\t\tlWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n\t\treturn lWordArray;\n\t};\n\tfunction WordToHex(lValue) {\n\t\tvar WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n\t\tfor (lCount = 0;lCount<=3;lCount++) {\n\t\t\tlByte = (lValue>>>(lCount*8)) & 255;\n\t\t\tWordToHexValue_temp = \"0\" + lByte.toString(16);\n\t\t\tWordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n\t\t}\n\t\treturn WordToHexValue;\n\t};\n\tfunction Utf8Encode(string) {\n\t\tstring = string.replace(/\\r\\n/g,\"\\n\");\n\t\tvar utftext = \"\";\n\t\tfor (var n = 0; n < string.length; n++) {\n\t\t\tvar c = string.charCodeAt(n);\n\t\t\tif (c < 128) {\n\t\t\t\tutftext += String.fromCharCode(c);\n\t\t\t}\n\t\t\telse if((c > 127) && (c < 2048)) {\n\t\t\t\tutftext += String.fromCharCode((c >> 6) | 192);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tutftext += String.fromCharCode((c >> 12) | 224);\n\t\t\t\tutftext += String.fromCharCode(((c >> 6) & 63) | 128);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t}\n\t\treturn utftext;\n\t};\n\tvar x=Array();\n\tvar k,AA,BB,CC,DD,a,b,c,d;\n\tvar S11=7, S12=12, S13=17, S14=22;\n\tvar S21=5, S22=9 , S23=14, S24=20;\n\tvar S31=4, S32=11, S33=16, S34=23;\n\tvar S41=6, S42=10, S43=15, S44=21;\n\tstring = Utf8Encode(string);\n\tx = ConvertToWordArray(string);\n\ta = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\tfor (k=0;k<x.length;k+=16) {\n\t\tAA=a; BB=b; CC=c; DD=d;\n\t\ta=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n\t\td=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n\t\tc=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n\t\tb=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n\t\ta=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n\t\td=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n\t\tc=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n\t\tb=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n\t\ta=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n\t\td=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n\t\tc=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n\t\tb=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n\t\ta=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n\t\td=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n\t\tc=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n\t\tb=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n\t\ta=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n\t\td=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n\t\tc=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n\t\tb=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n\t\ta=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n\t\td=GG(d,a,b,c,x[k+10],S22,0x2441453);\n\t\tc=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n\t\tb=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n\t\ta=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n\t\td=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n\t\tc=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n\t\tb=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n\t\ta=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n\t\td=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n\t\tc=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n\t\tb=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n\t\ta=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n\t\td=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n\t\tc=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n\t\tb=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n\t\ta=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n\t\td=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n\t\tc=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n\t\tb=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n\t\ta=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n\t\td=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n\t\tc=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n\t\tb=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n\t\ta=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n\t\td=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n\t\tc=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n\t\tb=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n\t\ta=II(a,b,c,d,x[k+0], S41,0xF4292244);\n\t\td=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n\t\tc=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n\t\tb=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n\t\ta=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n\t\td=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n\t\tc=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n\t\tb=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n\t\ta=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n\t\td=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n\t\tc=II(c,d,a,b,x[k+6], S43,0xA3014314);\n\t\tb=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n\t\ta=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n\t\td=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n\t\tc=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n\t\tb=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n\t\ta=AddUnsigned(a,AA);\n\t\tb=AddUnsigned(b,BB);\n\t\tc=AddUnsigned(c,CC);\n\t\td=AddUnsigned(d,DD);\n\t}\n\tvar temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n\treturn temp.toLowerCase();\n}\n\nJocUtil.sha1=function(msg) {\n\tfunction rotate_left(n,s) {\n\t\tvar t4 = ( n<<s ) | (n>>>(32-s));\n\t\treturn t4;\n\t};\n\tfunction lsb_hex(val) {\n\t\tvar str=\"\";\n\t\tvar i;\n\t\tvar vh;\n\t\tvar vl;\n\t\tfor( i=0; i<=6; i+=2 ) {\n\t\t\tvh = (val>>>(i*4+4))&0x0f;\n\t\t\tvl = (val>>>(i*4))&0x0f;\n\t\t\tstr += vh.toString(16) + vl.toString(16);\n\t\t}\n\t\treturn str;\n\t};\n\tfunction cvt_hex(val) {\n\t\tvar str=\"\";\n\t\tvar i;\n\t\tvar v;\n\t\tfor( i=7; i>=0; i-- ) {\n\t\t\tv = (val>>>(i*4))&0x0f;\n\t\t\tstr += v.toString(16);\n\t\t}\n\t\treturn str;\n\t};\n\tfunction Utf8Encode(string) {\n\t\tstring = string.replace(/\\r\\n/g,\"\\n\");\n\t\tvar utftext = \"\";\n\t\tfor (var n = 0; n < string.length; n++) {\n\t\t\tvar c = string.charCodeAt(n);\n\t\t\tif (c < 128) {\n\t\t\t\tutftext += String.fromCharCode(c);\n\t\t\t}\n\t\t\telse if((c > 127) && (c < 2048)) {\n\t\t\t\tutftext += String.fromCharCode((c >> 6) | 192);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tutftext += String.fromCharCode((c >> 12) | 224);\n\t\t\t\tutftext += String.fromCharCode(((c >> 6) & 63) | 128);\n\t\t\t\tutftext += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t}\n\t\treturn utftext;\n\t};\n\tvar blockstart;\n\tvar i, j;\n\tvar W = new Array(80);\n\tvar H0 = 0x67452301;\n\tvar H1 = 0xEFCDAB89;\n\tvar H2 = 0x98BADCFE;\n\tvar H3 = 0x10325476;\n\tvar H4 = 0xC3D2E1F0;\n\tvar A, B, C, D, E;\n\tvar temp;\n\tmsg = Utf8Encode(msg);\n\tvar msg_len = msg.length;\n\tvar word_array = new Array();\n\tfor( i=0; i<msg_len-3; i+=4 ) {\n\t\tj = msg.charCodeAt(i)<<24 | msg.charCodeAt(i+1)<<16 |\n\t\tmsg.charCodeAt(i+2)<<8 | msg.charCodeAt(i+3);\n\t\tword_array.push( j );\n\t}\n\tswitch( msg_len % 4 ) {\n\t\tcase 0:\n\t\t\ti = 0x080000000;\n\t\tbreak;\n\t\tcase 1:\n\t\t\ti = msg.charCodeAt(msg_len-1)<<24 | 0x0800000;\n\t\tbreak;\n \n\t\tcase 2:\n\t\t\ti = msg.charCodeAt(msg_len-2)<<24 | msg.charCodeAt(msg_len-1)<<16 | 0x08000;\n\t\tbreak;\n \n\t\tcase 3:\n\t\t\ti = msg.charCodeAt(msg_len-3)<<24 | msg.charCodeAt(msg_len-2)<<16 | msg.charCodeAt(msg_len-1)<<8\t| 0x80;\n\t\tbreak;\n\t}\n\tword_array.push( i );\n\twhile( (word_array.length % 16) != 14 ) word_array.push( 0 );\n\tword_array.push( msg_len>>>29 );\n\tword_array.push( (msg_len<<3)&0x0ffffffff );\n\tfor ( blockstart=0; blockstart<word_array.length; blockstart+=16 ) {\n\t\tfor( i=0; i<16; i++ ) W[i] = word_array[blockstart+i];\n\t\tfor( i=16; i<=79; i++ ) W[i] = rotate_left(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);\n\t\tA = H0;\n\t\tB = H1;\n\t\tC = H2;\n\t\tD = H3;\n\t\tE = H4;\n\t\tfor( i= 0; i<=19; i++ ) {\n\t\t\ttemp = (rotate_left(A,5) + ((B&C) | (~B&D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;\n\t\t\tE = D;\n\t\t\tD = C;\n\t\t\tC = rotate_left(B,30);\n\t\t\tB = A;\n\t\t\tA = temp;\n\t\t}\n\t\tfor( i=20; i<=39; i++ ) {\n\t\t\ttemp = (rotate_left(A,5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;\n\t\t\tE = D;\n\t\t\tD = C;\n\t\t\tC = rotate_left(B,30);\n\t\t\tB = A;\n\t\t\tA = temp;\n\t\t}\n\t\tfor( i=40; i<=59; i++ ) {\n\t\t\ttemp = (rotate_left(A,5) + ((B&C) | (B&D) | (C&D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;\n\t\t\tE = D;\n\t\t\tD = C;\n\t\t\tC = rotate_left(B,30);\n\t\t\tB = A;\n\t\t\tA = temp;\n\t\t}\n\t\tfor( i=60; i<=79; i++ ) {\n\t\t\ttemp = (rotate_left(A,5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;\n\t\t\tE = D;\n\t\t\tD = C;\n\t\t\tC = rotate_left(B,30);\n\t\t\tB = A;\n\t\t\tA = temp;\n\t\t}\n\t\tH0 = (H0 + A) & 0x0ffffffff;\n\t\tH1 = (H1 + B) & 0x0ffffffff;\n\t\tH2 = (H2 + C) & 0x0ffffffff;\n\t\tH3 = (H3 + D) & 0x0ffffffff;\n\t\tH4 = (H4 + E) & 0x0ffffffff;\n\t}\n\tvar temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);\n\treturn temp.toLowerCase();\n}\n\n/*\nA C-program for MT19937, with initialization improved 2002/1/26.\nCoded by Takuji Nishimura and Makoto Matsumoto.\nBefore using, initialize the state by using init_genrand(seed)\nor init_by_array(init_key, key_length).\nCopyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n3. The names of its contributors may not be used to endorse or promote\nproducts derived from this software without specific prior written\npermission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nAny feedback is very welcome.\nhttp://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\nemail: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n\tif (seed == undefined) {\n\t\tseed = new Date().getTime();\n\t}\n\t/* Period parameters */\n\tthis.N = 624;\n\tthis.M = 397;\n\tthis.MATRIX_A = 0x9908b0df; /* constant vector a */\n\tthis.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n\tthis.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n\tthis.mt = new Array(this.N); /* the array for the state vector */\n\tthis.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n\tthis.init_genrand(seed);\n}\n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n\tthis.mt[0] = s >>> 0;\n\tfor (this.mti=1; this.mti<this.N; this.mti++) {\n\t\tvar s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n\t\tthis.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n\t\t+ this.mti;\n\t\t/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n\t\t/* In the previous versions, MSBs of the seed affect */\n\t\t/* only MSBs of the array mt[]. */\n\t\t/* 2002/01/09 modified by Makoto Matsumoto */\n\t\tthis.mt[this.mti] >>>= 0;\n\t\t/* for >32 bit machines */\n\t}\n}\n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n\tvar i, j, k;\n\tthis.init_genrand(19650218);\n\ti=1; j=0;\n\tk = (this.N>key_length ? this.N : key_length);\n\tfor (; k; k--) {\n\t\tvar s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n\t\tthis.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n\t\t+ init_key[j] + j; /* non linear */\n\t\tthis.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n\t\ti++; j++;\n\t\tif (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n\t\tif (j>=key_length) j=0;\n\t}\n\tfor (k=this.N-1; k; k--) {\n\t\tvar s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n\t\tthis.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n\t\t- i; /* non linear */\n\t\tthis.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n\t\ti++;\n\t\tif (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n\t}\n\n\tthis.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n}\n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n\tvar y;\n\tvar mag01 = new Array(0x0, this.MATRIX_A);\n\t/* mag01[x] = x * MATRIX_A for x=0,1 */\n\n\tif (this.mti >= this.N) { /* generate N words at one time */\n\t\tvar kk;\n\n\t\tif (this.mti == this.N+1) /* if init_genrand() has not been called, */\n\t\t\tthis.init_genrand(5489); /* a default initial seed is used */\n\n\t\tfor (kk=0;kk<this.N-this.M;kk++) {\n\t\t\ty = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n\t\t\tthis.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n\t\t}\n\t\tfor (;kk<this.N-1;kk++) {\n\t\t\ty = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n\t\t\tthis.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n\t\t}\n\t\ty = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n\t\tthis.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n\t\tthis.mti = 0;\n\t}\n\n\ty = this.mt[this.mti++];\n\n\t/* Tempering */\n\ty ^= (y >>> 11);\n\ty ^= (y << 7) & 0x9d2c5680;\n\ty ^= (y << 15) & 0xefc60000;\n\ty ^= (y >>> 18);\n\n\treturn y >>> 0;\n}\n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function() {\n\treturn (this.genrand_int32()>>>1);\n}\n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function() {\n\treturn this.genrand_int32()*(1.0/4294967295.0);\n\t/* divided by 2^32-1 */\n}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n\treturn this.genrand_int32()*(1.0/4294967296.0);\n\t/* divided by 2^32 */\n}\n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function() {\n\treturn (this.genrand_int32() + 0.5)*(1.0/4294967296.0);\n\t/* divided by 2^32 */\n}\n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function() {\n\tvar a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;\n\treturn(a*67108864.0+b)*(1.0/9007199254740992.0);\n} \n\nif (typeof module !== 'undefined' && module.exports) {\n\texports.MersenneTwister = MersenneTwister;\n\texports.JocUtil = JocUtil;\n} else {\n\tthis.MersenneTwister = MersenneTwister;\n\tthis.JocUtil = JocUtil;\n}\n","/*    Copyright 2017 Jocly\n *\n *    This program is free software: you can redistribute it and/or  modify\n *    it under the terms of the GNU Affero General Public License, version 3,\n *    as published by the Free Software Foundation.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU Affero General Public License for more details.\n *\n *    You should have received a copy of the GNU Affero General Public License\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *    As a special exception, the copyright holders give permission to link the\n *    code of portions of this program with the OpenSSL library under certain\n *    conditions as described in each individual source file and distribute\n *    linked combinations including the program with the OpenSSL library. You\n *    must comply with the GNU Affero General Public License in all respects\n *    for all of the code used other than as permitted herein. If you modify\n *    file(s) with this exception, you may extend this exception to your\n *    version of the file(s), but you are not obligated to do so. If you do not\n *    wish to do so, delete this exception statement from your version. If you\n *    delete this exception statement from all source files in the program,\n *    then also delete it in the license file.\n */\n\nvar JoclyUCT={};\n\nif(typeof WorkerGlobalScope == 'undefined' && typeof SystemJS == 'undefined') {\n\tmodule.exports.JoclyUCT = JoclyUCT;\n\t(function() {\n\t\tvar r = require;\n\t\tvar ju = r(\"./jocly.util.js\");\n\t\tglobal.MersenneTwister = ju.MersenneTwister;\n\t\tglobal.JocUtil = ju.JocUtil;\n\t})();\n} else\n\tthis.JoclyUCT = JoclyUCT;\n\n(function() {\n\t\n\tfunction Node(parent,who) {\n\t\tthis.visits=1;\t\t\t\t\t\t\t// number of time the node has been visited\n\t\tthis.children=null;\t\t\t\t\t// node children if any\n\t\tthis.who=who;\t\t\t\t\t\t\t// 1 = first player, 2 = second player\n\t\tthis.parents=[];\t\t\t\t\t\t// parent nodes\n\t\tif(parent)\n\t\t\tthis.parents.push(parent);\n\t\tthis.known=false;\t\t\t\t\t\t// true if all the node and nodes below have been expanded and all leaves are terminal \n\t\tthis.evaluation=0;\t\t\t\t\t\t// the current minimax value\n\t\tthis.staticEvalSum=0;\t\t\t\t\t// the sum of the normalized playouts evaluations\n\t\tthis.staticEvalCount=0;\t\t\t\t// the number of playouts evaluations\n\t\tthis.depth=parent?parent.depth+1:0;\t\t// the node depth\n\t}\n\t\n\tNode.prototype={\n\t\taddParent: function(parent) {\n\t\t\tthis.parents.push(parent);\n\t\t\tif(parent.depth+1<this.depth)\n\t\t\t\tthis.depth=parent.depth+1;\n\t\t}\n\t}\n\t\n\tvar winnerMap={ // convert from Jocly convention (draw==2)\n\t\t\"-1\": -1,\n\t\t1: 1,\n\t\t2: 0,\n\t\t0: 0\n\t}\n\t\t\n\tJoclyUCT.startMachine = function(aGame,aOptions) {\n\t\tvar loopCount=0;\n\t\tvar nodeCount=0;\n\t\tvar redundantNodeCount=0;\n\t\tvar poDur=0,poCount=0;\t// playout stats\n\t\tvar skippedAlphaBeta=0; // alpha-beta stats\n\t\tvar maxDepth=0;\n\n\t\tvar uctParams={\n\t\t\t\tminVisitsExpand: aOptions.level.minVisitsExpand || 1,\n\t\t\t\tplayoutSpread: aOptions.level.playoutSpread || 2,\n\t\t\t\tplayoutDepth: (aOptions.level.playoutDepth!==undefined)?aOptions.level.playoutDepth:0,\n\t\t\t\tc: (aOptions.level.c!==undefined)?aOptions.level.c:.3,\n\t\t\t\tplayoutCeil: (aOptions.level.playoutCeil!==undefined)?aOptions.level.playoutCeil:0,\n\t\t\t\tlog: aOptions.level.log?true:false,\n\t\t\t\tmaxDuration: (aOptions.level.maxDuration!==undefined)?aOptions.level.maxDuration:2,\n\t\t\t\tmaxLoops: (aOptions.level.maxLoops!==undefined)?aOptions.level.maxLoops:0,\n\t\t\t\tmaxNodes: (aOptions.level.maxNodes!==undefined)?aOptions.level.maxNodes:0,\n\t\t\t\tshowMinimaxTree: aOptions.level.showMinimaxTree?true:false,\n\t\t\t\tshowBestLine: aOptions.level.showBestLine?true:false,\n\t\t\t\tignoreLeaf: aOptions.level.ignoreLeaf===undefined?false:aOptions.level.ignoreLeaf,\n\t\t\t\tpropagateMultiVisits: aOptions.level.propagateMultiVisits===undefined?true:aOptions.level.propagateMultiVisits,\n\t\t\t\tpropagation: aOptions.level.propagation===undefined?\"mixed\":aOptions.level.propagation,\n\t\t\t\tuseDepthWeights: aOptions.level.useDepthWeights===undefined?false:aOptions.level.useDepthWeights,\n\t\t\t\tproductRatio: aOptions.level.productRatio===undefined?0:aOptions.level.productRatio,\n\t\t\t\tuseAlphaBeta: aOptions.level.useAlphaBeta===undefined?false:aOptions.level.useAlphaBeta,\n\t\t\t\tuncertaintyFactor: aOptions.level.uncertaintyFactor===undefined?0:aOptions.level.uncertaintyFactor,\n\t\t\t\tdirectVisits: aOptions.level.directVisits===undefined?true:aOptions.level.directVisits,\n\t\t\t\tdistributeEval: aOptions.level.distributeEval===undefined?true:aOptions.level.distributeEval,\n\t\t\t\tpickMove: aOptions.level.pickMove===undefined?\"besteval\":aOptions.level.pickMove, // or maxvisits\n\t\t\t\tdebugRawEval: aOptions.level.debugRawEval===undefined?false:aOptions.level.debugRawEval,\n\t\t};\n\t\tvar uctNodes={};\n\t\tvar signatures; // the array of visited board signatures\n\n\t\tif(uctParams.log)\n\t\t\tconsole.log(\"Running UCT AI - \",aOptions.level.label,\"- Player\",aGame.mWho==1?\"A\":\"B\");\n\n\t\t/*\n\t\t * Normalize evaluations to get -1<eval<1\n\t\t * Handle negative and positive evaluations separately so 0 remains 0 \n\t\t */\n\t\tvar evalMapPositive={\n\t\t\tv: 0,\t\t\t\t\t\t// evaluation original value\n\t\t\tl: null,\t\t\t\t\t// \"less\" branch (for evaluations < v)\n\t\t\tm: {\t\t\t\t\t\t// \"more\" branch (for evaluations > v)\n\t\t\t\tv: Number.MAX_VALUE,\n\t\t\t\tl: null,\n\t\t\t\tm: null,\n\t\t\t},\n\t\t}\n\t\tvar evalMapNegative=JSON.parse(JSON.stringify(evalMapPositive)); // deep copy for the initial negative map\n\t\t\n\t\tfunction NormalizeEval(evaluation) {\n\t\t\tvar evalNode=evalMapPositive;\n\t\t\tvar negative=false;\n\t\t\tvar normEval=0, step=1;\n\t\t\tif(evaluation==0)\n\t\t\t\treturn 0;\n\t\t\tif(evaluation<0) {\n\t\t\t\tevaluation=-evaluation;\n\t\t\t\tevalNode=evalMapNegative;\n\t\t\t\tnegative=true;\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif(evaluation>evalNode.v) {\n\t\t\t\t\tnormEval+=step;\n\t\t\t\t\tif(!evalNode.m) {\n\t\t\t\t\t\tevalNode.m={\n\t\t\t\t\t\t\tv: evaluation,\n\t\t\t\t\t\t\tl: null,\n\t\t\t\t\t\t\tm: null\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tevalNode=evalNode.m;\n\t\t\t\t} else if(evaluation<evalNode.v) {\n\t\t\t\t\tnormEval-=step;\n\t\t\t\t\tif(!evalNode.l) {\n\t\t\t\t\t\tevalNode.l={\n\t\t\t\t\t\t\tv: evaluation,\n\t\t\t\t\t\t\tl: null,\n\t\t\t\t\t\t\tm: null\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tevalNode=evalNode.l;\n\t\t\t\t} else {\t// matching evaluation\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstep=step/2;\n\t\t\t}\n\t\t\tif(negative)\n\t\t\t\tnormEval=-normEval;\n\t\t\treturn normEval;\n\t\t}\n\t\t\n\t\t/*\n\t\t * Best evaluation (minimax)\n\t\t */\n\t\tfunction GetMinimaxEval(node,children) {\n\t\t\tvar evaluation=undefined;\n\t\t\tfor(var i=0;i<children.length;i++) {\n\t\t\t\tvar node1=children[i];\n\t\t\t\tif(evaluation===undefined || node1.evaluation*node1.who>evaluation*node1.who)\n\t\t\t\t\tevaluation=node1.evaluation;\n\t\t\t}\n\t\t\treturn evaluation;\n\t\t}\n\t\t/*\n\t\t * Minus worse opponent evaluation\n\t\t */\n\t\tfunction GetMaximinEval(node,children) {\n\t\t\tvar evaluation=undefined;\n\t\t\tfor(var i=0;i<children.length;i++) {\n\t\t\t\tvar node1=children[i];\n\t\t\t\tif(evaluation===undefined || node1.evaluation*node1.who<evaluation*node1.who)\n\t\t\t\t\tevaluation=node1.evaluation;\n\t\t\t}\n\t\t\treturn -evaluation;\n\t\t}\n\t\t/*\n\t\t * Probability product evaluation\n\t\t */\n\t\tfunction GetProductEval(node,children) {\n\t\t\tvar value=1;\n\t\t\tfor(var i=0;i<children.length;i++) {\n\t\t\t\tvar node1=children[i];\n\t\t\t\tvalue1=(node1.evaluation+1)/2;\n\t\t\t\tif(node.who==1)\n\t\t\t\t\tvalue*=1-node1.evaluation;\n\t\t\t\telse\n\t\t\t\t\tvalue*=node1.evaluation;\n\t\t\t}\n\t\t\tif(node.who==1)\n\t\t\t\treturn (1-value)*2-1;\n\t\t\telse\n\t\t\t\treturn value*2-1;\n\t\t}\n\t\t\n\t\tfunction PropagateEvalParent(node,visits,visited) {\n\t\t\tif(aGame.mOptions.uctTransposition && !aGame.mOptions.uctIgnoreLoop && (node.sign in visited))\n\t\t\t\treturn;\n\t\t\tvar children=[];\n\t\t\tif(uctParams.ignoreLeaf) {\n\t\t\t\tvar hasExpandedChildren=false;\n\t\t\t\tfor(var i=0;i<node.children.length;i++)\n\t\t\t\t\tif(node.children[i].n.children) {\n\t\t\t\t\t\thasExpandedChildren=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif(hasExpandedChildren) {\n\t\t\t\t\tfor(var i=0;i<node.children.length;i++) {\n\t\t\t\t\t\tvar node1=node.children[i].n;\n\t\t\t\t\t\tif(node1.known || node1.children)\n\t\t\t\t\t\t\tchildren.push(node1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(children.length==0)\n\t\t\t\tfor(var i=0;i<node.children.length;i++)\n\t\t\t\t\tchildren.push(node.children[i].n);\n\n\t\t\tvar evaluation;\n\t\t\tswitch(uctParams.propagation) {\n\t\t\tcase \"maximin\":\n\t\t\t\tevaluation=GetMaximinEval(node,children);\n\t\t\t\tbreak;\n\t\t\tcase \"minimax2min-avg\":\n\t\t\t\tvar evaluation1=GetMaximinEval(node,children);\n\t\t\t\tvar evaluation2=GetMinimaxEval(node,children);\n\t\t\t\tevaluation=(evaluation1+evaluation2)/2;\n\t\t\t\tbreak;\n\t\t\tcase \"minimax2min-best\":\n\t\t\t\tvar evaluation1=GetMaximinEval(node,children);\n\t\t\t\tvar evaluation2=GetMinimaxEval(node,children);\n\t\t\t\tif(node.who==1)\n\t\t\t\t\tevaluation=Math.max(evaluation1,evaluation2);\n\t\t\t\telse\n\t\t\t\t\tevaluation=Math.min(evaluation1,evaluation2);\n\t\t\t\tbreak;\n\t\t\tcase \"product\":\n\t\t\t\tevaluation=GetPropabilityProductEval(node,children);\n\t\t\t\tbreak;\n\t\t\tcase \"minimax\":\n\t\t\tcase \"mixed\":\n\t\t\tdefault:\n\t\t\t\tevaluation=GetMinimaxEval(node,children);\n\t\t\t\tif(uctParams.propagation==\"mixed\" && uctParams.productRatio>0) {\n\t\t\t\t\tevaluation2=GetProductEval(node,children);\n\t\t\t\t\tevaluation=uctParams.productRatio*evaluation2+(1-uctParams.productRatio)*evaluation;\n\t\t\t\t}\n\t\t\t\tif(uctParams.useDepthWeights)\n\t\t\t\t\tevaluation=WeightEval(evaluation,node.depth+1);\n\t\t\t}\n\t\t\tif(uctParams.uncertaintyFactor) // tend to do good things now rather than later\n\t\t\t\tevaluation*=1-Math.pow(10,-uctParams.uncertaintyFactor)*Math.log(node.depth+1);\n\t\t\tif(node.evaluation!==evaluation) { \n\t\t\t\tnode.evaluation=evaluation;\n\t\t\t\tif(!uctParams.directVisits)\n\t\t\t\t\tnode.visits+=visits;\n\t\t\t\tPropagateEval(node,visits,visited);\n\t\t\t} else if(!uctParams.directVisits)\n\t\t\t\tPropagateVisits(node,visits,visited);\n\t\t}\n\t\tfunction PropagateEval(node,visits,visited) {\n\t\t\tif(node.parents.length==0) // root node: stop here\n\t\t\t\treturn;\n\t\t\tif(aGame.mOptions.uctTransposition && !aGame.mOptions.uctIgnoreLoop) {\n\t\t\t\tif(!visited)\n\t\t\t\t\tvisited={};\n\t\t\t\tvisited[node.sign]=true;\n\t\t\t}\n\t\t\tfor(var i=0;i<node.parents.length;i++) {\n\t\t\t\tvar parent=node.parents[i];\n\t\t\t\tif(uctParams.useAlphaBeta) { // sort the parent children so alpha-beta will be more efficient\n\t\t\t\t\tparent.children.sort(function(c1,c2) {\n\t\t\t\t\t\treturn (c2.evaluation-c1.evaluation)*node.who;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tPropagateEvalParent(parent,visits,visited);\n\t\t\t}\n\t\t}\n\n\t\tfunction PropagateVisits(node,visits,visited) {\n\t\t\tif(node.parents.length==0) // root node: stop here\n\t\t\t\treturn;\n\t\t\tif(aGame.mOptions.uctTransposition && !aGame.mOptions.uctIgnoreLoop) {\n\t\t\t\tif(!visited)\n\t\t\t\t\tvisited={};\n\t\t\t\tvisited[node.sign]=true;\n\t\t\t}\n\t\t\tfor(var i=0;i<node.parents.length;i++) {\n\t\t\t\tvar parent=node.parents[i];\n\t\t\t\tif(!(parent.sign in visited)) {\n\t\t\t\t\tparent.visits+=visits;\n\t\t\t\t\tvisited[parent.sign]=true;\n\t\t\t\t\tPropagateVisits(parent,visits,visited);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\t * Propagates known boolean up \n\t\t */\n\t\tfunction PropagateKnownParent(node,visited) {\n\t\t\tif(aGame.mOptions.uctTransposition && !aGame.mOptions.uctIgnoreLoop && (node.sign in visited))\n\t\t\t\treturn;\n\t\t\tvar known=true;\n\t\t\tfor(var i=0;i<node.children.length;i++) {\n\t\t\t\tvar node1=node.children[i].n;\n\t\t\t\tif(node1.known==false) {\n\t\t\t\t\tknown=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(known==true) {\n\t\t\t\tnode.known=true;\n\t\t\t\tPropagateKnown(node,visited);\n\t\t\t}\n\t\t}\n\t\tfunction PropagateKnown(node,visited) {\n\t\t\tif(node.known==false || node.parents.length==0)\n\t\t\t\treturn;\n\t\t\tif(aGame.mOptions.uctTransposition && !aGame.mOptions.uctIgnoreLoop) {\n\t\t\t\tif(!visited)\n\t\t\t\t\tvisited={};\n\t\t\t\tvisited[node.sign]=true;\n\t\t\t}\n\t\t\tfor(var i=0;i<node.parents.length;i++)\n\t\t\t\tPropagateKnownParent(node.parents[i],visited);\n\t\t}\n\n\t\t/*\n\t\t * A simple 32 bits integer transformation function, so that zobrist board signatures can be XORed without side effect\n\t\t */\n\t\tfunction TransformInteger(v0) {\n\t\t\tvar ib=1;\n\t\t\tvar v=0;\n\t\t\tfor(var i=0;i<32;i++) {\n\t\t\t\tvar b=(v0>>>i)&1;\n\t\t\t\tif(ib)\n\t\t\t\t\tv=(v<<1)|b;\n\t\t\t\telse\n\t\t\t\t\tv=(v<<1)|(1-b);\n\t\t\t\tib=b;\n\t\t\t}\n\t\t\treturn v;\n\t\t}\n\t\t\n\t\t/*\n\t\t * Runs an iteration\n\t\t */\n\t\tfunction Step() {\n\t\t\tloopCount++;\n\n\t\t\t// Select\n\t\t\tvar board=new (aGame.GetBoardClass())(aGame);\n\t\t\tboard.CopyFrom(aGame.mBoard);\n\t\t\t\n\t\t\tvar pathSign=0; // keep track of the boards we've been through (order doesn't matter)\n\t\t\tvar node=rootNode;\n\t\t\tvar depth=0;\n\t\t\tvar descendMaxDepth=0;\n\t\t\tvar moves=[];\n\t\t\tvar nodePath=[];\n\t\t\tvar parentVisits=loopCount;\n\t\t\tvar visited={};\n\t\t\tvar alpha=-2;\n\t\t\tvar beta=2;\n\t\t\twhile(true) {\n\t\t\t\tnodePath.push(node);\n\t\t\t\tif(depth>descendMaxDepth) {\n\t\t\t\t\tdescendMaxDepth=depth;\n\t\t\t\t}\n\t\t\t\tif(node.children===null)\n\t\t\t\t\tbreak;\n\t\t\t\tvar candidateChildren;\n\t\t\t\tif(uctParams.useAlphaBeta) {\n\t\t\t\t\tcandidateChildren=[];\n\t\t\t\t\tfor(var i=0;i<node.children.length;i++) {\n\t\t\t\t\t\tvar child1=node.children[i];\n\t\t\t\t\t\tvar node1=child1.n;\n\t\t\t\t\t\tcandidateChildren.push(child1);\n\t\t\t\t\t\tif(node1.who==1 && // maximizing player \n\t\t\t\t\t\t\tnode1.evaluation>alpha)\n\t\t\t\t\t\t\talpha=node1.evaluation;\n\t\t\t\t\t\tif(node1.who==-1 && // minimizing player\n\t\t\t\t\t\t\tnode1.evaluation<beta)\n\t\t\t\t\t\t\tbeta=node1.evaluation;\n\t\t\t\t\t\tif(beta<alpha) {\n\t\t\t\t\t\t\tskippedAlphaBeta+=node.children.length-1-i;\n\t\t\t\t\t\t\t//console.log(\"alpha-beta skipped\",node.children.length-1-i,\"nodes\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else\n\t\t\t\t\tcandidateChildren=node.children;\n\t\t\t\tif(aGame.mOptions.uctTransposition && !aGame.mOptions.uctIgnoreLoop) {\n\t\t\t\t\tvar candidateChildren0=[];\n\t\t\t\t\tfor(var i=0;i<candidateChildren.length;i++)\n\t\t\t\t\t\tif(!(candidateChildren[i].n.sign in visited))\n\t\t\t\t\t\t\tcandidateChildren0.push(candidateChildren[i]);\n\t\t\t\t\tcandidateChildren=candidateChildren0;\n\t\t\t\t}\n\t\t\t\tvar bestChildren=[], bestUCB;\n\t\t\t\tvar parentVisitsLog;\n\t\t\t\tif(uctParams.directVisits)\n\t\t\t\t\tparentVisitsLog=Math.log(parentVisits);\n\t\t\t\telse\n\t\t\t\t\tparentVisitsLog=Math.log(node.visits);\n\t\t\t\t\n\t\t\t\tfunction PickBestChildren() {\n\t\t\t\t\tfor(var i=0;i<candidateChildren.length;i++) {\n\t\t\t\t\t\tvar child1=candidateChildren[i];\n\t\t\t\t\t\tvar node1=child1.n;\n\t\t\t\t\t\tif(node1.known)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar value=(node1.evaluation*node1.who+1)/2; // ensures value between 0 and 1\n\t\t\t\t\t\tvar ucb;\n\t\t\t\t\t\tif(uctParams.directVisits)\n\t\t\t\t\t\t\tucb=value+uctParams.c*Math.sqrt(parentVisitsLog/child1.f);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tucb=value+uctParams.c*Math.sqrt(parentVisitsLog/node1.visits);\n\t\t\t\t\t\tif(bestChildren.length==0 || ucb>=bestUCB) {\n\t\t\t\t\t\t\tif(bestChildren.length>0 && ucb>bestUCB)\n\t\t\t\t\t\t\t\tbestChildren=[];\n\t\t\t\t\t\t\tbestUCB=ucb;\n\t\t\t\t\t\t\tbestChildren.push(child1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t * redistribute evaluations uniformly between 0 and 1 (excluded) \n\t\t\t\t */\n\t\t\t\tfunction PickBestChildrenDistributeEval() {\n\n\t\t\t\t\tvar childrenDE={};\n\t\t\t\t\tvar values=[];\n\t\t\t\t\tfor(var i=0;i<candidateChildren.length;i++) {\n\t\t\t\t\t\tvar child1=candidateChildren[i];\n\t\t\t\t\t\tvar node1=child1.n;\n\t\t\t\t\t\tif(node1.known)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar value=(node1.evaluation*node1.who+1)/2; // ensures value between 0 and 1\n\t\t\t\t\t\tif(childrenDE[value]===undefined) {\n\t\t\t\t\t\t\tchildrenDE[value]=[];\n\t\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchildrenDE[value].push(child1);\n\t\t\t\t\t}\n\t\t\t\t\tvalues.sort(function(v1,v2) {\n\t\t\t\t\t\treturn v1-v2;\n\t\t\t\t\t});\n\t\t\t\t\tvar step=1/(values.length+1);\n\t\t\t\t\tvar index=0;\n\t\t\t\t\tfor(var vi=0; vi<values.length;vi++) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tvar value0=values[vi];\n\t\t\t\t\t\tvar children=childrenDE[value0];\n\t\t\t\t\t\tvar value1=step*index;\n\t\t\t\t\t\tfor(var i=0;i<children.length;i++) {\n\t\t\t\t\t\t\tvar child1=children[i];\n\t\t\t\t\t\t\tvar node1=child1.n;\n\t\t\t\t\t\t\tvar ucb;\n\t\t\t\t\t\t\tif(uctParams.directVisits)\n\t\t\t\t\t\t\t\tucb=value1+uctParams.c*Math.sqrt(parentVisitsLog/child1.f);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tucb=value1+uctParams.c*Math.sqrt(parentVisitsLog/node1.visits);\n\t\t\t\t\t\t\tif(bestChildren.length==0 || ucb>=bestUCB) {\n\t\t\t\t\t\t\t\tif(bestChildren.length>0 && ucb>bestUCB)\n\t\t\t\t\t\t\t\t\tbestChildren=[];\n\t\t\t\t\t\t\t\tbestUCB=ucb;\n\t\t\t\t\t\t\t\tbestChildren.push(child1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(uctParams.distributeEval)\n\t\t\t\t\tPickBestChildrenDistributeEval();\n\t\t\t\telse\n\t\t\t\t\tPickBestChildren()\n\t\t\t\t\n\t\t\t\tif(bestChildren.length==0) // all child nodes are known\n\t\t\t\t\treturn;\n\t\t\t\tvar child=bestChildren[Math.floor(Math.random()*bestChildren.length)];\n\t\t\t\tif(uctParams.directVisits) {\n\t\t\t\t\tchild.f++;\n\t\t\t\t\tparentVisits=child.f;\n\t\t\t\t}\n\t\t\t\tnode=child.n;\n\t\t\t\tif(aGame.mOptions.uctTransposition && !aGame.mOptions.uctIgnoreLoop)\n\t\t\t\t\tvisited[node.sign]=1;\n\t\t\t\tdepth++;\n\t\t\t\tmoves.push(child.m);\n\t\t\t\tboard.ApplyMove(aGame,child.m);\n\t\t\t\taGame.AddVisit(board);\n\t\t\t\tboard.mMoves=[];\n\t\t\t\tsignatures.push(board.GetSignature());\n\t\t\t\tif(aGame.mOptions.uctTransposition==\"states\")\n\t\t\t\t\tpathSign^=TransformInteger(board.GetSignature()); // consider the states we have been through but not their order\n\t\t\t\tboard.mWho=-board.mWho;\n\t\t\t}\n\t\t\t\n\t\t\t// Expand\n\t\t\tif(node==rootNode || node.visits>=uctParams.minVisitsExpand) {\n\t\t\t\tif(!board.mMoves || board.mMoves.length==0)\n\t\t\t\t\tboard.GenerateMoves(aGame);\n\t\t\t\tif(board.mFinished) { // in some game implementations, ending is detected while generating the moves\n\t\t\t\t\tnode.known=true;\n\t\t\t\t\tnode.evaluation=winnerMap[board.mWinner];\n\t\t\t\t\tPropagateKnown(node);\n\t\t\t\t} else {\n\t\t\t\t\tnode.children=[];\n\t\t\t\t\tvar bestEval=undefined;\n\t\t\t\t\tvar known=true;\n\t\t\t\t\tfor(var i=0;i<board.mMoves.length;i++) {\n\t\t\t\t\t\tvar move=board.mMoves[i];\n\t\t\t\t\t\tvar signatures1=[];\n\t\t\t\t\t\tvar board1=new (aGame.GetBoardClass())(aGame);\n\t\t\t\t\t\tboard1.CopyFrom(board);\n\t\t\t\t\t\tboard1.ApplyMove(aGame,move);\n\t\t\t\t\t\taGame.AddVisit(board1);\n\t\t\t\t\t\tboard1.mMoves=[];\n\t\t\t\t\t\tboard1.mWho=-board1.mWho;\n\t\t\t\t\t\tif(depth>maxDepth)\n\t\t\t\t\t\t\tmaxDepth=depth;\n\t\t\t\t\t\tvar signature=board1.GetSignature();\n\t\t\t\t\t\tsignatures1.push(signature);\n\t\t\t\t\t\tvar sign1;\n\t\t\t\t\t\tif(aGame.mOptions.uctTransposition==\"states\") {\n\t\t\t\t\t\t\tsign1=pathSign^signature; // board signature is not transformed to differentiate the leaf board\n\t\t\t\t\t\t\tsign1^=depth; // depth in signature\n\t\t\t\t\t\t} else if(aGame.mOptions.uctTransposition==\"state\")\n\t\t\t\t\t\t\tsign1=signature; // only final state counts\n\t\t\t\t\t\tvar node1=null;\n\t\t\t\t\t\tif(aGame.mOptions.uctTransposition)\n\t\t\t\t\t\t\tnode1=uctNodes[sign1];\n\t\t\t\t\t\tif(!node1) {\n\t\t\t\t\t\t\tnode1=new Node(node,-node.who);\n\t\t\t\t\t\t\tnodeCount++;\n\t\t\t\t\t\t\tif(aGame.mOptions.uctTransposition) {\n\t\t\t\t\t\t\t\tuctNodes[sign1]=node1;\n\t\t\t\t\t\t\t\tnode1.sign=sign1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tboard1.Evaluate(aGame);\n\t\t\t\t\t\t\tif(board1.mFinished) {\n\t\t\t\t\t\t\t\tnode1.known=true;\n\t\t\t\t\t\t\t\tnode1.evaluation=winnerMap[board1.mWinner]; // 1, -1 or 0\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(isNaN(board1.mEvaluation))\n\t\t\t\t\t\t\t\t\tconsole.error(\"Evaluation in not a number !\",board1.mEvaluation);\n\t\t\t\t\t\t\t\tnode1.evaluation=Playout(node1,board1,signatures1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnode1.staticEvalSum=node1.evaluation;\n\t\t\t\t\t\t\tnode1.staticEvalCount=1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tredundantNodeCount++;\n\t\t\t\t\t\t\tnode1.addParent(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(node1.known==false)\n\t\t\t\t\t\t\tknown=false;\n\t\t\t\t\t\tvar nodeChain={\n\t\t\t\t\t\t\tn: node1,\n\t\t\t\t\t\t\tm: (new (aGame.GetMoveClass())(move)).Strip(), // Save memory by stripping the stored move\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(uctParams.directVisits)\n\t\t\t\t\t\t\tnodeChain.f=1;\n\t\t\t\t\t\tnode.children.push(nodeChain);\n\t\t\t\t\t\tvar _eval=node1.evaluation*node1.who;\n\t\t\t\t\t\tif(bestEval===undefined || _eval>bestEval*node1.who)\n\t\t\t\t\t\t\tbestEval=node1.evaluation;\n\t\t\t\t\t\tfor(var j=0;j<signatures1.length;j++)\n\t\t\t\t\t\t\taGame.RemoveVisit(null,signatures1[j]);\n\t\t\t\t\t}\n\t\t\t\t\tnode.evaluation=bestEval;\n\t\t\t\t\tPropagateEval(node,uctParams.propagateMultiVisits?board.mMoves.length:1);\n\t\t\t\t\tif(uctParams.directVisits)\n\t\t\t\t\t\tfor(var i=0;i<nodePath.length;i++)\n\t\t\t\t\t\t\tnodePath[i].visits+=uctParams.propagateMultiVisits?board.mMoves.length:1;\n\t\t\t\t\t\n\t\t\t\t\tif(known) {\n\t\t\t\t\t\tnode.known=true;\n\t\t\t\t\t\tPropagateKnown(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(node.known)\n\t\t\t\treturn;\n\n\t\t\t// Simulate\n\t\t\tfunction Playout(node,board,signatures) {\n\t\t\t\tvar result=null;\n\t\t\t\tvar t0=Date.now();\n\t\t\t\tfor(var depth=0;depth<uctParams.playoutDepth || board.mWho==uctParams.playoutCeil*rootNode.who;depth++) {\n\t\t\t\t\tif(!board.mMoves || board.mMoves.length==0)\n\t\t\t\t\t\tboard.GenerateMoves(aGame);\n\t\t\t\t\tif(board.mFinished) {\n\t\t\t\t\t\tresult={\n\t\t\t\t\t\t\tfinished: true,\n\t\t\t\t\t\t\twinner: winnerMap[board.mWinner],\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvar weightedMoves=[];\n\t\t\t\t\tfor(var i=0;i<board.mMoves.length;i++) {\n\t\t\t\t\t\tvar board1=new (aGame.GetBoardClass())(aGame);\n\t\t\t\t\t\tboard1.CopyFrom(board);\n\t\t\t\t\t\tboard1.ApplyMove(aGame,board.mMoves[i]);\n\t\t\t\t\t\taGame.AddVisit(board1);\n\t\t\t\t\t\tboard1.mMoves=[];\n\t\t\t\t\t\tboard1.Evaluate(aGame);\n\t\t\t\t\t\tvar evaluation=board1.mEvaluation;\n\t\t\t\t\t\tif(board1.mFinished) {\n\t\t\t\t\t\t\tif(board1.mWinner==1)\n\t\t\t\t\t\t\t\tevaluation=Number.MAX_VALUE;\n\t\t\t\t\t\t\telse if(board1.mWinner==-1)\n\t\t\t\t\t\t\t\tevaluation=-Number.MAX_VALUE;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tevaluation=0;\n\t\t\t\t\t\t} else if(isNaN(board1.mEvaluation))\n\t\t\t\t\t\t\tconsole.error(\"Evaluation in not a number !\");\n\n\t\t\t\t\t\tweightedMoves.push({\n\t\t\t\t\t\t\tmove: board.mMoves[i],\n\t\t\t\t\t\t\tevaluation: evaluation,\n\t\t\t\t\t\t\tboard: board1,\n\t\t\t\t\t\t});\n\t\t\t\t\t\taGame.RemoveVisit(board1);\n\t\t\t\t\t}\n\t\t\t\t\tweightedMoves.sort(function(a1,a2) {\n\t\t\t\t\t\tvar ev1=a1.evaluation*board.mWho;\n\t\t\t\t\t\tvar ev2=a2.evaluation*board.mWho;\n\t\t\t\t\t\treturn ev2-ev1;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t/*\n\t\t\t\t\t * Pick the next move in the playout with a preference for the moves that seem the best.\n\t\t\t\t\t * For instance, with playoutSpread=2, the probability weight to pick the best move is 1/2,\n\t\t\t\t\t * the second best move 1/4, third best 1/8, ...\n\t\t\t\t\t * If several moves have the same quality, they have the same probability.\n\t\t\t\t\t */\n\t\t\t\t\tvar n=weightedMoves.length;\n\t\t\t\t\tvar r=1/uctParams.playoutSpread;\n\t\t\t\t\tvar max=(1-Math.pow(r,n+1))/(1-r)-1;\n\t\t\t\t\tvar rnd=Math.random()*max;\n\t\t\t\t\tvar equalMoves, lastEval=undefined, cursor=0, reached=false;\n\t\t\t\t\tfor(var i=0;i<n;i++) {\n\t\t\t\t\t\tvar wMove=weightedMoves[i];\n\t\t\t\t\t\tvar ev=wMove.evaluation;\n\t\t\t\t\t\tif(ev!==lastEval) {\n\t\t\t\t\t\t\tif(reached) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tequalMoves=[wMove];\n\t\t\t\t\t\t\t\tlastEval=ev;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tequalMoves.push(wMove);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcursor+=Math.pow(r,i+1);\n\t\t\t\t\t\tif(cursor>=rnd)\n\t\t\t\t\t\t\treached=true;\n\t\t\t\t\t}\n\t\t\t\t\tvar pickedMove=equalMoves[Math.floor(Math.random()*equalMoves.length)];\n\n\t\t\t\t\tboard=pickedMove.board;\n\t\t\t\t\taGame.AddVisit(board);\n\t\t\t\t\tsignatures.push(board.GetSignature()); // remember the board state signature so it can be removed later \n\t\t\t\t\tboard.mWho=-board.mWho;\n\t\t\t\t\tif(board.mFinished) {\n\t\t\t\t\t\tresult={\n\t\t\t\t\t\t\tfinished: true,\n\t\t\t\t\t\t\twinner: winnerMap[board.mWinner],\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(result===null) {\n\t\t\t\t\tresult={\n\t\t\t\t\t\tfinished: false,\n\t\t\t\t\t\teval: board.mEvaluation\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// update stats\n\t\t\t\tpoDur+=Date.now()-t0;\n\t\t\t\tpoCount++;\n\n\t\t\t\tvar nodeEval;\n\t\t\t\tif(result.finished)\n\t\t\t\t\tnodeEval=result.winner; // 1, -1 or 0\n\t\t\t\telse {\n\t\t\t\t\tif(uctParams.debugRawEval)\n\t\t\t\t\t\tnode.rawEval=result.eval;\n\t\t\t\t\tvar normEval=NormalizeEval(result.eval);\n\t\t\t\t\tUpdateDepthEval(normEval,node.depth);\n\t\t\t\t\tnodeEval=normEval;\n\t\t\t\t}\n\t\t\t\treturn nodeEval;\n\t\t\t}\n\t\t\tvar evaluation=Playout(node,board,signatures);\n\t\t\tnode.staticEvalSum+=evaluation;\n\t\t\tnode.staticEvalCount++;\n\t\t\tnode.evaluation=node.staticEvalSum/node.staticEvalCount; // averaging normalized evaluations might not be the best way to get an accurate result\n\t\t\tPropagateEval(node,1);\n\t\t\tif(uctParams.directVisits)\n\t\t\t\tfor(var i=0;i<nodePath.length;i++)\n\t\t\t\t\tnodePath[i].visits++;\n\t\t}\n\t\t\n\t\tvar evalWeights=[];\n\t\t/*\n\t\t * Update the evaluation weight for the given depth in order to balance evaluation propagation\n\t\t */\n\t\tfunction UpdateDepthEval(evaluation,depth) {\n\t\t\twhile(evalWeights.length<=depth) \n\t\t\t\tevalWeights.push({\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tsum: 0\n\t\t\t\t});\n\t\t\tvar weight=evalWeights[depth];\n\t\t\tweight.sum+=evaluation;\n\t\t\tweight.count++;\n\t\t}\n\t\t/*\n\t\t * \n\t\t */\n\t\tfunction WeightEval(evaluation,depth) {\n\t\t\tvar weight=evalWeights[depth];\n\t\t\tif(weight===undefined) { // why does this happen, even if very rare ? :(\n\t\t\t\twhile(evalWeights.length<depth) \n\t\t\t\t\tevalWeights.push({\n\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\tsum: 0\n\t\t\t\t\t});\n\t\t\t\tevalWeights.push({\n\t\t\t\t\tcount: 1,\n\t\t\t\t\tsum: evaluation\n\t\t\t\t});\n\t\t\t\treturn evaluation;\n\t\t\t}\n\t\t\tvar average=weight.count>0?weight.sum/weight.count:0;\n\t\t\tif(evaluation>average) {\n\t\t\t\tevaluation=(evaluation-average)/(1-average);\n\t\t\t} else if(evaluation<average) {\n\t\t\t\tevaluation=-(average-evaluation)/(average+1);\n\t\t\t}\n\t\t\treturn evaluation;\n\t\t}\n\n\t\tif(!aGame.mBoard.mMoves || aGame.mBoard.mMoves.length==0)\n\t\t\taGame.mBoard.GenerateMoves(aGame);\n\t\tif(aGame.mBoard.mMoves.length==1) { // only one possible move: pick it\n\t\t\taGame.mBestMoves=[aGame.mBoard.mMoves[0]];\n\t\t\tJocUtil.schedule(aGame, \"Done\", {});\n\t\t\treturn;\n\t\t}\n\t\tif(aGame.mBoard.mMoves.length==0) {\n\t\t\tconsole.error(\"No move available\",aGame);\n\t\t\tdebugger;\n\t\t}\n\t\tvar rootNode=new Node(null,-aGame.mWho);\n\t\tnodeCount++;\n\t\tif(aGame.mOptions.uctTransposition)\n\t\t\tuctNodes[aGame.mBoard.GetSignature()]=rootNode;\n\t\t\n\t\tvar t0=Date.now();\n\t\tvar lastProgressPercent=-1;\n\t\tfunction Run() {\n\t\t\tif(aGame.mAborted) {\n\t\t\t\taGame.mAbortCallback.call(aGame);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar now=Date.now();\n\t\t\tvar progressPercent=0;\n\t\t\tif(uctParams.maxDuration>0)\n\t\t\t\tprogressPercent=Math.round(100*(now-t0)/(uctParams.maxDuration*1000));\n\t\t\tif(uctParams.maxLoops>0)\n\t\t\t\tprogressPercent=Math.max(progressPercent,100*loopCount/uctParams.maxLoops);\n\t\t\tif(uctParams.maxNodes>0)\n\t\t\t\tprogressPercent=Math.max(progressPercent,100*nodeCount/uctParams.maxNodes);\n\t\t\tprogressPercent = Math.min(100,progressPercent);\n\t\t\tif(progressPercent!=lastProgressPercent) {\n\t\t\t\tlastProgressPercent=progressPercent;\n\t\t\t\tif(aGame.mProgressCallback)\n\t\t\t\t\taGame.mProgressCallback(progressPercent);\n\t\t\t}\n\t\t\tif(!rootNode.children || (rootNode.known==false &&\n\t\t\t\t\t(uctParams.maxDuration<=0 || now<uctParams.maxDuration*1000+t0) &&\n\t\t\t\t\t(uctParams.maxLoops<=0 || loopCount<uctParams.maxLoops) &&\n\t\t\t\t\t(uctParams.maxNodes<=0 || nodeCount<uctParams.maxNodes)\n\t\t\t\t)) {\n\t\t\t\tdo {\n\t\t\t\t\tsignatures=[];\n\t\t\t\t\ttry {\n\t\t\t\t\t\tStep();\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tconsole.error(\"UCT step\",e);\n\t\t\t\t\t\tdebugger;\n\t\t\t\t\t}\n\t\t\t\t\tfor(var i=0;i<signatures.length;i++)\n\t\t\t\t\t\taGame.RemoveVisit(null,signatures[i]);\n\t\t\t\t} while(Date.now()-100<now);\n\t\t\t\tsetTimeout(Run,0);\n\t\t\t} else {\n\t\t\t\tif(uctParams.log) {\n\t\t\t\t\tReportStats(rootNode);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar bestEval=undefined;\n\t\t\t\taGame.mBestMoves=[];\n\t\t\t\tif(uctParams.pickMove==\"maxvisits\" && uctParams.directVisits) {\n\t\t\t\t\tfor(var i=0;i<rootNode.children.length;i++) {\n\t\t\t\t\t\tvar child=rootNode.children[i];\n\t\t\t\t\t\tvar node=child.n;\n\t\t\t\t\t\tif(node.evaluation==node.who) {\n\t\t\t\t\t\t\taGame.mBestMoves.push(child.m);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(aGame.mBestMoves.length==0) {\n\t\t\t\t\t\tfor(var i=0;i<rootNode.children.length;i++) {\n\t\t\t\t\t\t\tvar child=rootNode.children[i];\n\t\t\t\t\t\t\tif(bestEval===undefined || bestEval<=child.f) {\n\t\t\t\t\t\t\t\tif(bestEval===undefined || bestEval<child.f)\n\t\t\t\t\t\t\t\t\taGame.mBestMoves=[];\n\t\t\t\t\t\t\t\tbestEval=child.f;\n\t\t\t\t\t\t\t\taGame.mBestMoves.push(child.m);\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar bestEval2=undefined;\n\t\t\t\t\tvar candidateChildren=[];\n\t\t\t\t\tif(uctParams.pickMove==\"besteval-multivisits\")\n\t\t\t\t\t\trootNode.children.forEach(function(child) {\n\t\t\t\t\t\t\tif(child.n.visits>1 || child.n.known==true)\n\t\t\t\t\t\t\t\tcandidateChildren.push(child);\n\t\t\t\t\t\t});\n\t\t\t\t\tif(candidateChildren.length==0)\n\t\t\t\t\t\tcandidateChildren=rootNode.children;\n\t\t\t\t\tfor(var i=0;i<candidateChildren.length;i++) {\n\t\t\t\t\t\tvar child=candidateChildren[i];\n\t\t\t\t\t\tvar node=child.n;\n\t\t\t\t\t\tvar staticEval=node.staticEvalSum/node.staticEvalCount;\n\t\t\t\t\t\tif(bestEval===undefined || bestEval>=node.evaluation*rootNode.who) {\n\t\t\t\t\t\t\tif(bestEval===undefined || bestEval>node.evaluation*rootNode.who || (\n\t\t\t\t\t\t\t\tbestEval==node.evaluation*rootNode.who && (\n\t\t\t\t\t\t\t\t\t\tbestEval2===undefined || bestEval2>rootNode.who*staticEval\n\t\t\t\t\t\t\t\t\t\t))) {\n\t\t\t\t\t\t\t\tbestEval2=staticEval;\n\t\t\t\t\t\t\t\taGame.mBestMoves=[];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbestEval=node.evaluation*rootNode.who;\n\t\t\t\t\t\t\taGame.mBestMoves.push(child.m);\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tJocUtil.schedule(aGame, \"Done\", {});\n\t\t\t}\n\t\t}\n\t\tRun();\n\t\n\t\tfunction ReportStats(node) {\n\t\t\tconsole.log(\"  duration\",Date.now()-t0);\n\t\t\tconsole.log(\"  evaluation:\",node.evaluation);\n\t\t\tconsole.log(\"  fully explored:\",node.known);\n\t\t\tconsole.log(\"  node count:\",nodeCount);\n\t\t\tconsole.log(\"  redundant node count:\",redundantNodeCount);\n\t\t\tconsole.log(\"  max depth:\",maxDepth);\n\t\t\tconsole.log(\"  alpha-beta\",uctParams.useAlphaBeta,\"skipped\",skippedAlphaBeta);\n\t\t\tconsole.log(\" \",loopCount,\"steps, per step\",(Date.now()-t0)/loopCount,\"ms\");\n\t\t\tconsole.log(\" \",poCount,\"playouts\",poDur,\"ms, per playout\",poDur/poCount,\"ms\");\n\t\t\tconsole.log(\"  UCT c\",uctParams.c);\n\t\t\tconsole.log(\"  tree\",rootNode);\n\n\t\t\tfunction ShowMinimax(node,depth) {\n\t\t\t\tif(uctParams.propagation!=\"minimax\" && (uctParams.propagation!=\"mixed\" || uctParams.productRatio>0)) {\n\t\t\t\t\tconsole.warn(\"Cannot display minimax tree on propagation\",uctParams.propagation,\"pp ratio\",uctParams.productRatio);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar indent=\"\";\n\t\t\t\tfor(var i=0;i<depth;i++)\n\t\t\t\t\tindent+=\"  \";\n\t\t\t\tconsole.log(indent+\"*\",depth,\"*\",-node.who,\"eval\",node.evaluation);\n\t\t\t\tfor(var i=0;i<node.children.length;i++) {\n\t\t\t\t\tvar child1=node.children[i];\n\t\t\t\t\tvar node1=child1.n;\n\t\t\t\t\tconsole.log(indent,\"  \"+(node1.evaluation==node.evaluation?\"*\":\" \")+\" move\",(new (aGame.GetMoveClass())(child1.m)).ToString(),\n\t\t\t\t\t\t\t\"visits\",node1.visits,\n\t\t\t\t\t\t\t\"eval\",node1.evaluation,\n\t\t\t\t\t\t\t\"known\",node1.known,\n\t\t\t\t\t\t\t\"sev\",node1.staticEvalSum+\"/\"+node1.staticEvalCount,\n\t\t\t\t\t\t\t\"who\",node1.who,\n\t\t\t\t\t\t\t\"children\",node1.children?node1.children.length:\"no\");\n\t\t\t\t\tif(node1.children && node1.evaluation==node.evaluation)\n\t\t\t\t\t\tShowMinimax(node1,depth+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(uctParams.showMinimaxTree) {\n\t\t\t\tconsole.log(\"Minimax tree\");\n\t\t\t\tShowMinimax(node,0);\n\t\t\t}\n\t\t\t\n\t\t\tif(uctParams.checkSide) {\n\t\t\t\tvar checkSideNodeCount=0;\n\t\t\t\tvar checkSideError=0;\n\t\t\t\tfunction CheckSide(node) {\n\t\t\t\t\tcheckSideNodeCount++;\n\t\t\t\t\tif(node.children)\n\t\t\t\t\t\tfor(var i=0;i<node.children.length;i++) {\n\t\t\t\t\t\t\tvar child1=node.children[i];\n\t\t\t\t\t\t\tif(child1.n.who!=-node.who)\n\t\t\t\t\t\t\t\tcheckSideError++;\n\t\t\t\t\t\t\tCheckSide(child1.n);\n\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t}\n\t\t\t\tCheckSide(rootNode);\n\t\t\t\tconsole.log(\"  tree side alternance\",\"node\",checkSideNodeCount,\"errors\",checkSideError);\n\t\t\t}\n\t\t}\n\t}\n\n})();\n\n","/*    Copyright 2017 Jocly\n *\n *    This program is free software: you can redistribute it and/or  modify\n *    it under the terms of the GNU Affero General Public License, version 3,\n *    as published by the Free Software Foundation.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU Affero General Public License for more details.\n *\n *    You should have received a copy of the GNU Affero General Public License\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *    As a special exception, the copyright holders give permission to link the\n *    code of portions of this program with the OpenSSL library under certain\n *    conditions as described in each individual source file and distribute\n *    linked combinations including the program with the OpenSSL library. You\n *    must comply with the GNU Affero General Public License in all respects\n *    for all of the code used other than as permitted herein. If you modify\n *    file(s) with this exception, you may extend this exception to your\n *    version of the file(s), but you are not obligated to do so. If you do not\n *    wish to do so, delete this exception statement from your version. If you\n *    delete this exception statement from all source files in the program,\n *    then also delete it in the license file.\n */\n\ntry {\n\n\texports.Game = JocGame = function() {}\n\texports.Board = JocBoard = function() {}\n\texports.Move = JocMove = function() {}\n\n} catch(e) {\n\tglobal.JocGame = exports.Game = function() {};\n\tglobal.JocBoard = exports.Board = function() {};\n\tglobal.JocMove = exports.Move = function() {};\n\n\t(function() {\n\t\tvar r = require;\n\t\tvar ju = r(\"./jocly.util.js\");\n\t\tglobal.MersenneTwister = ju.MersenneTwister;\n\t\tglobal.JocUtil = ju.JocUtil;\n\t\tglobal.JoclyUCT = r(\"./jocly.uct.js\").JoclyUCT;\n\t})();\n}\n\nJocGame.PLAYER_A = 1;\nJocGame.PLAYER_B = -1;\nJocGame.DRAW = 2;\n\nif(typeof document!=\"undefined\")\n\tJocGame.CLICK=('ontouchstart' in document.documentElement)?\"touchstart\":\"click\";\nelse\n\tJocGame.CLICK=\"click\";\n/*\nJocGame.MOUSEMOVE_EVENT=('ontouchstart' in document.documentElement)?\"touchmove\":\"mousemove\";\nJocGame.MOUSEDOWN_EVENT=('ontouchstart' in document.documentElement)?\"touchstart\":\"mousedown\";\nJocGame.MOUSEUP_EVENT=('ontouchstart' in document.documentElement)?\"touchend\":\"mouseup\";\n*/\n\nJocGame.MOUSEMOVE_EVENT=\"touchmove mousemove\";\nJocGame.MOUSEDOWN_EVENT=\"touchstart mousedown\";\nJocGame.MOUSEUP_EVENT=\"touchend mouseup joclyclick\";\n\n/* biggest integer with unit precision: \n   Math.pow(2,53)-1 < Math.pow(2,53) is true \n   Math.pow(2,54)-1 < Math.pow(2,54) is false */\nJocGame.MAX_VALUE = Math.pow(2,53); \n\nJocGame.prototype = {}\n\nJocGame.prototype.Init = function(aOptions) {\n\tthis.mWho = JocGame.PLAYER_A;\n\tthis.mViewAs = JocGame.PLAYER_A;\n\tthis.mTopLevel = 3;\n\tthis.mLoopMax = 300;\n\tthis.mPreventRepeat = false;\n\tif(aOptions) {\n\t\tthis.mOptions = aOptions.game;\n\t\tthis.mViewOptions = aOptions.view;\n\t\tthis.mSkin = this.mViewOptions.skins[0].name; // TODO check if 3D not supported\n\t\tthis.mNotation=false;\n\t\tthis.mShowMoves=this.mViewOptions.useShowMoves;\n\t\tthis.mSounds=!!this.mViewOptions.sounds;\n\t\tthis.mAutoComplete=false;\n\n\t\tif(typeof(this.mOptions.level)!=\"undefined\")\n\t\t\tthis.mTopLevel = this.mOptions.level;\n\t\tif (typeof(this.mOptions.loopMax)!=\"undefined\")\n\t\t\tthis.mLoopMax = this.mOptions.loopMax;\n\t\tthis.mVisitedBoards = {};\n\t\tif(typeof(this.mOptions.viewAs)!=\"undefined\")\n\t\t\tthis.mViewAs = this.mOptions.viewAs;\n\t\telse\n\t\t\tthis.mOptions.viewAs = this.mViewAs;\n\t}\n\tthis.mNextSchedule = null;\n\tthis.mPlayedMoves = [];\n\tthis.mFullPlayedMoves = [];\n\tthis.mViewInited = false;\n\tthis.mGameInited = false;\n\tif(aOptions && aOptions.initial)\n\t\tthis.GameInitGame(aOptions.initial);\n\telse\n\t\tthis.GameInitGame();\n\tthis.mBoard = new (this.GetBoardClass())(this);\n\tif(this.mBoard.InitialPosition)\n\t\tthis.mBoard.InitialPosition(this);\n\tthis.mBoard.mMoves=[];\n\tthis.mBoard.mWho = this.mWho;\n\tthis.listeners = [];\n\n}\n\nJocGame.prototype.AddListener = function(listener) {\n\tthis.listeners.push(listener);\n}\n\nJocGame.prototype.RemoveListener = function(listener) {\n\tfor(var i=this.listeners.length-1;i>=0;i--)\n\t\tif(this.listeners[i]==listener)\n\t\t\tthis.listeners.splice(i,1);\n}\n\nJocGame.prototype.DispatchMessage = function(message) {\n\tvar self = this;\n\tthis.listeners.forEach(function(listener) {\n\t\tlistener.call(self,message);\n\t});\n}\n\nJocGame.prototype.HumanMove = function(move) {\n\tthis.DispatchMessage({\n\t\ttype: \"human-move\",\n\t\tmove: move\n\t});\n}\n\nJocGame.prototype.MakeMove = function(move) {\n\tthis.HumanMove(move);\n}\n\nJocGame.prototype.MachineMove = function(result) {\n\tthis.DispatchMessage({\n\t\ttype: \"machine-move\",\n\t\tresult: result\n\t});\n}\n\nJocGame.prototype.MachineProgress = function(progress) {\n\tthis.DispatchMessage({\n\t\ttype: \"machine-progress\",\n\t\tprogress: progress\n\t});\n}\n\nJocGame.prototype.PlayMove = function(move) {\n\tvar self = this;\n\tvar promise = new Promise(function(resolve,reject) {\n\t\tself.mOldBoard=new (self.GetBoardClass())(self);\n\t\tself.mOldBoard.CopyFrom(self.mBoard);\n\t\tself.ApplyMove(move);\n\t\tself.MoveShown = function() {\n\t\t\tdelete self.MoveShown;\n\t\t\tresolve();\n\t\t}\n\t\tvar moveShown = self.mBoard.PlayedMove(self,move);\n\t\tif(moveShown) {\n\t\t\tdelete self.MoveShown;\n\t\t\tresolve();\n\t\t}\n\t});\n\treturn promise;\n}\n\nJocGame.prototype.InvertWho = function() {\n\tvar who = this.GetWho();\n\tthis.SetWho(-who);\n}\n\nJocGame.prototype.AttachElement = function (element, options) {\n\toptions = options || {};\n\tvar game = this;\n\tthis.widget = element;\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tif (game.gamePreAttachProto)\n\t\t\treject(new Error(\"Game already attached\"));\n\t\telse {\n\t\t\tvar systemJSConfig = {\n\t\t\t\tmeta: {\n\t\t\t\t\t\"jocly-xdview.js\": {\n\t\t\t\t\t\tglobals: {\n\t\t\t\t\t\t\tjQuery: \"jquery.js\",\n\t\t\t\t\t\t\tTHREE: \"three.js\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsystemJSConfig.meta[\"games/\" + game.module + \"/\" + game.name + \"-view.js\"] = {\n\t\t\t\tglobals: {\n\t\t\t\t\txdview: \"jocly-xdview.js\",\n\t\t\t\t\tjQuery: \"jquery.js\",\n\t\t\t\t\tTHREE: \"three.js\"\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tSystemJS.config(systemJSConfig);\n\n\t\tPromise.all([\n\t\t\tSystemJS.import(\"jocly-xdview.js\"),\n\t\t\tSystemJS.import(\"games/\" + game.module + \"/\" + game.name + \"-view.js\")\n\t\t]).then(function(args) {\n\t\t\tvar xdview = args[0], view = args[1];\n\t\t\tgame.gamePreAttachProto = Object.getPrototypeOf(game);\n\t\t\tvar gameProto = Object.assign({}, game.gamePreAttachProto, xdview.view.Game, view.view.Game);\n\t\t\tObject.setPrototypeOf(game, gameProto);\n\n\t\t\tvar Board = game.mBoardClass;\n\t\t\tgame.boardPreAttachProto = Board.prototype;\n\t\t\tObject.assign(Board.prototype, game.boardPreAttachProto, xdview.view.Board, view.view.Board);\n\n\t\t\tvar Move = game.mMoveClass;\n\t\t\tgame.movePreAttachProto = Move.prototype;\n\t\t\tObject.assign(Move.prototype, game.movePreAttachProto, view.view.Move);\n\n\t\t\tgame.mGeometry = {\n\t\t\t\twidth: game.widget.clientWidth,\n\t\t\t\theight: game.widget.clientHeight\n\t\t\t}\n\t\t\tgame.mWidget = jQuery(game.widget);\n\n\t\t\tvar defaultViewOptions = game.mViewOptions && game.mViewOptions.defaultOptions;\n\t\t\tif(defaultViewOptions) {\n\t\t\t    const optDefs = {\n                    \"mSkin\": \"skin\",\n                    \"mNotation\": \"notation\",\n                    \"mSounds\": \"sounds\",\n                    \"mShowMoves\": \"moves\",\n                    \"mAutoComplete\": \"autocomplete\"\n                }\n\t\t\t\tfor(var opt in optDefs)\n\t\t\t\t\tif(typeof defaultViewOptions[optDefs[opt]]!=\"undefined\")\n\t\t\t\t\t\tgame[opt] = defaultViewOptions[optDefs[opt]];\n\t\t\t}\n\n\t\t\tgame.UpdateSounds();\n\t\t\tresolve();\n\t\t}, function(e) {\n\t\t\treject(e);\n\t\t});\n\t});\n\treturn promise;\n}\n\nJocGame.prototype.DetachElement = function () {\n\tvar game = this;\n\tthis.widget = element;\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tif (!game.gamePreAttachProto)\n\t\t\treject(new Error(\"Game not attached\"));\n\t\telse {\n\t\t\t// TODO\n\t\t\tresolve();\n\t\t}\n\t});\n\treturn promise;\n}\n\nJocGame.prototype.GetBoardClass = function() {\n\treturn this.mBoardClass;\n}\n\nJocGame.prototype.GetMoveClass = function() {\n\treturn this.mMoveClass;\n}\n\nJocGame.prototype.CreateMove = function(args) {\n\treturn new this.mMoveClass(args);\n}\n\nJocGame.prototype.CloneBoard = function(board) {\n\tvar newBoard=new (this.GetBoardClass())(this);\n\tnewBoard.CopyFrom(board);\n\treturn newBoard;\n}\n\nJocGame.prototype.InitView = function() {\n\tconsole.log(\"Abstract InitView called\");\n}\n\nJocGame.prototype.LoadCss = function() {\n\tvar styles = document.querySelectorAll(\"head link[class='jocly-css']\");\n\tstyles.forEach(function(style) {\n\t\tstyle.parentNode.removeChild(style);\n\t});\n\tvar self = this;\n\tvar head = document.querySelector(\"head\");\n\t(this.mViewOptions.css||[]).forEach(function(css) {\n\t\tvar style = document.createElement(\"link\");\n\t\tstyle.setAttribute(\"rel\",\"stylesheet\");\n\t\tstyle.setAttribute(\"type\",\"text/css\");\n\t\tstyle.setAttribute(\"class\",\"jocly-css\");\n\t\tstyle.setAttribute(\"href\",self.mViewOptions.fullPath+\"/\"+css);\n\t\thead.appendChild(style);\n\t});\n}\n\nJocGame.prototype.GameInitView = function() {\n\tif(this.mGeometry.width>0 && this.mGeometry.height>0) {\n\t\tthis.LoadCss();\n\t\tthis.InitView();\n\t\tthis.mViewInited=true;\n\t}\n}\n\nJocGame.prototype.DestroyView = function() {\n\tif(this.mWidget)\n\t\tthis.mWidget.empty();\n}\n\nJocGame.prototype.GameDestroyView = function() {\n\tif(this.mViewInited) {\n\t\tthis.DestroyView();\n\t\tthis.mViewInited=false;\n\t}\n}\n\nJocGame.prototype.CanPlaySound = function(tag) {\n\treturn true;\n}\n\nJocGame.prototype.UpdateSounds = function() {\n\tvar joclySounds = $(\"#jocly-sounds\");\n\tif(joclySounds.length==0)\n\t\tjoclySounds = $(\"<div/>\").attr(\"id\",\"jocly-sounds\").css({display:\"none\"}).appendTo($(\"body\"));\n\tfunction AddSound(tag, path, fname) {\n\t\tvar audio = $(\"<audio/>\").attr(\"id\", \"jocly-sound-\" + tag).attr(\"preload\",\"auto\");\n                $(\"<source/>\").attr(\"src\", path + \"/res/sounds/\" + fname + \".ogg\").attr(\"type\", \"audio/ogg\").appendTo(audio);\n\t\t$(\"<source/>\").attr(\"src\", path + \"/res/sounds/\" + fname + \".mp3\").attr(\"type\", \"audio/mp3\").appendTo(audio);\n\t\taudio.appendTo(joclySounds);\n\t}\n\tjoclySounds.empty();\n\tvar defaultSounds = {\n\t\tuseraction: \"bells1\",\n\t\tusermove: \"bells1\",\n\t\twin: \"winblues\",\n\t\tloss: \"lose\",\n\t\tend: \"draw\",\n\t}\n\tfor (var i in defaultSounds)\n\t\tAddSound(i, this.config.baseURL, defaultSounds[i]);\n\tif (this.config.view.sounds) {\n\t\tfor (var i in this.config.view.sounds) {\n\t\t\t$(\"#jocly-sound-\" + i).remove();\n\t\t\tif (this.config.view.sounds[i])\n\t\t\t\tif (this.config.view.sounds[i])\n\t\t\t\t\tAddSound(i, this.config.baseURL+\"games/\"+this.config.model.module, this.config.view.sounds[i]);\n\t\t}\n\t}\n}\n\nJocGame.prototype.PlaySound = function(tag) {\n\tif(!this.CanPlaySound(tag))\n\t\treturn;\n\tvar audio=document.getElementById(\"jocly-sound-\"+tag);\n\tif(audio && this.mSounds) {\n\t\tif(typeof this.mNeedPhonegapMedia==\"undefined\") {\n\t\t\tthis.mNeedPhonegapMedia=false;\n\t\t\tthis.mNeedPhonegapMedia = window && window.cordova && (typeof Media != \"undefined\");\n\t\t}\n\t\t\n\t\tif(this.mNeedPhonegapMedia) {\n\t\t\tif(typeof this.mPhonegapMediaLib==\"undefined\")\n\t\t\t\tthis.mPhonegapMediaLib={};\n\t\t\tif(typeof this.mPhonegapMediaLib[tag]==\"undefined\") {\n\t\t\t\tvar node=audio.firstChild;\n\t\t\t\twhile(node) {\n\t\t\t\t\tif(/source/i.test(node.nodeName) && node.getAttribute(\"type\")==\"audio/mp3\")\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tnode=node.nextSibling;\n\t\t\t\t}\n\t\t\t\tif(node) {\n\t\t\t\t\tvar src=node.getAttribute(\"src\");\n\t\t\t\t\t\n\t\t\t\t\tvar m=/^([^#\\?]*)\\/[^#\\?]+/.exec(window.location.pathname);\n\t\t\t\t\tif(m)\n\t\t\t\t\t\tsrc=src.replace(/^\\./,m[1]);\n\t\t\t\t\tsrc=src.replace(/%20/g,\" \");\n\t\t\t\t\tthis.mPhonegapMediaLib[tag]=new Media(src, function() {\n\t\t\t\t\t\t\t//console.info(\"PlaySound: Media played \"+src);\n\t\t\t\t\t\t},function(error) {\n\t\t\t\t\t\t\tconsole.warn(\"Jocly PlaySound: Media did not play \"+error.code);\n\t\t\t\t\t\t},function(status) {\n\t\t\t\t\t\t\t//console.info(\"PlaySound: mediaStatus \"+status);\n\t\t\t\t\t\t});\n\t\t\t\t} else\n\t\t\t\t\tthis.mPhonegapMediaLib[tag]=null;\n\t\t\t}\n\t\t\tif(this.mPhonegapMediaLib[tag]) {\n\t\t\t\tthis.mPhonegapMediaLib[tag].play();\n\t\t\t}\n\t\t} else\n\t\t\taudio.cloneNode(true).play();\n\t}\n}\n\nJocGame.prototype.InitGame = function() {\n}\n\nJocGame.prototype.GameInitGame = function() {\n\tif(this.mGameInited==false) {\n\t\tthis.mVisitedBoards={};\n\t\tif(arguments.length>0 && arguments[0])\n\t\t\tthis.mInitial=arguments[0];\n\t\telse\n\t\t\tthis.mInitial=null;\n\t\tthis.InitGame();\n\t\tthis.mGameInited=true;\n\t}\n}\n\nJocGame.prototype.DestroyGame = function() {\n}\n\nJocGame.prototype.GameDestroyGame = function() {\n\tif(this.mGameInited) {\n\t\tthis.DestroyGame();\n\t\tthis.mGameInited=false;\n\t}\n\tif(this.aiWorker) {\n\t\ttry {\n\t\t\tthis.aiWorker.terminate();\n\t\t\tdelete this.aiWorker;\n\t\t} catch(e) {\n\t\t\tconsole.warn(\"Cannot terminate worker\",e);\n\t\t}\n\t}\n}\n\nJocGame.prototype.DisplayBoard = function() {\n\tif(this.mBoard.Display)\n\t\tthis.mBoard.Display(this);\n}\n\nJocGame.prototype.SetWho = function(aWho) {\n\tthis.mWho = aWho;\n\tthis.mBoard.mWho = aWho;\n}\n\nJocGame.prototype.GetWho = function() {\n\treturn this.mWho;\n}\n\nJocGame.prototype.HumanTurn = function() {\n\tif(!this.mBoard.mMoves || this.mBoard.mMoves.length==0) {\n\t\tthis.mCurrentLevel=-1; \n\t\tthis.mBoard.GenerateMoves(this);\n\t}\n\tthis.mBoard.HumanTurn(this);\n}\n\nJocGame.prototype.HumanTurnEnd = function() {\n\tthis.mBoard.HumanTurnEnd(this);\n}\n\nJocGame.prototype.PlayedMove = function(aMove, aOldBoard) {\n\tthis.mOldBoard=aOldBoard;\n\treturn this.mBoard.PlayedMove(this,aMove);\n}\n\nJocGame.prototype.ShowEnd = function() {\n\treturn this.mBoard.ShowEnd(this);\n}\n\nJocGame.prototype.EvaluateBoard = function() {\n\tthis.mBoard.mFinished=false;\n\tthis.mBoard.mMoves=[];\n\tthis.mCurrentLevel=-1;\n\tthis.mBoard.GenerateMoves(this);\n\tif(this.mBoard.mFinished==false)\n\t\tthis.mBoard.Evaluate(this,true,true);\n\t//JocLog(\"EvaluatedBoard \"+JSON.stringify(this.mBoard));\n}\n\nJocGame.prototype.GetFinished = function() {\n\tthis.EvaluateBoard();\n\tif(this.mBoard.mFinished)\n\t\treturn this.mBoard.mWinner;\n\telse\n\t\treturn 0;\n\tthis.SetWho(-this.mWho);\n\tvar moves=this.mBoard.mMoves;\n\tthis.EvaluateBoard();\n\tthis.mBoard.mMoves=moves;\n\tthis.SetWho(-this.mWho);\n\tif(this.mBoard.mFinished)\n\t\treturn this.mBoard.mWinner;\n\telse\n\t\treturn 0;\n}\n\nJocGame.prototype.IsValidMove = function(args) {\n\tvar move = new (this.GetMoveClass())(args);\n\treturn this.mBoard.IsValidMove(this,move);\n}\n\nJocGame.prototype.AddVisit = function(board,sign) {\n\tif(board)\n\t\tsign=board.GetSignature();\n\tvar visits=this.mVisitedBoards[sign];\n\tif(visits===undefined)\n\t\tthis.mVisitedBoards[sign]=1;\n\telse\n\t\tthis.mVisitedBoards[sign]++;\n}\n\nJocGame.prototype.RemoveVisit = function(board,sign) {\n\tif(board)\n\t\tsign=board.GetSignature();\n\tvar visits=this.mVisitedBoards[sign];\n\tif(visits!==undefined) {\n\t\tif(visits>1)\n\t\t\tthis.mVisitedBoards[sign]--;\n\t\telse\n\t\t\tdelete this.mVisitedBoards[sign];\n\t}\n}\n\nvar engdbg_loops, engdbg_time, engdbg_t0;\n\nJocGame.prototype.StartMachine = function(aOptions) {\n\tengdbg_loops=0;\n\tengdbg_time=0;\n\tengdbg_t0=Date.now();\n\t\n\tthis.mDoneCallback=aOptions.Done || this.MachineMove;\n\tthis.mProgressCallback=aOptions.Progress || this.MachineProgress;\n\tif(typeof(aOptions.level)!=\"undefined\")\n\t\tthis.mTopLevel=aOptions.level;\n\tif(typeof(aOptions.maxDepth)!=\"undefined\")\n\t\tthis.mTopLevel=aOptions.maxDepth;\n\tthis.mStartTime = new Date().getTime();\n\tthis.mExploredCount = 0;\n\tthis.mPickedMoveIndex = 0;\n\tthis.mBestMoves = [];\n\tthis.mContexts = [];\n\tthis.mDuration = 0;\n\tthis.mAborted = false;\n\tthis.mRandomSeed = 0;\n\tif(aOptions.randomSeed && !isNaN(parseInt(aOptions.randomSeed)))\n\t\tthis.mRandomSeed = parseInt(aOptions.randomSeed);\n\tif(typeof this.mBoard.StaticGenerateMoves ==\"function\") {\n\t\tvar moves=this.mBoard.StaticGenerateMoves(this);\n\t\tif(moves && moves.length>0) {\n\t\t\tthis.mBestMoves=moves;\n\t\t\tJocUtil.schedule(this, \"Done\", {});\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif(this.mOptions.levelOptions) {\n\t\tthis.mOptions.levelOptionsSaved=JSON.parse(JSON.stringify(this.mOptions.levelOptions));\n\t\tif(aOptions.level)\n\t\t\tObject.assign(this.mOptions.levelOptions,aOptions.level);\n\t}\n\t\n\tvar aiThread = aOptions.threaded && typeof window==\"object\" && window.Worker;\n\tif(aOptions.level && aOptions.level.ai==\"uct\" && JoclyUCT) {\n\t\tif(aiThread)\n\t\t\tthis.StartThreadedMachine(aOptions,\"uct\");\n\t\telse\n\t\t\tJoclyUCT.startMachine(this,aOptions);\n\t}\n\telse { // default is legacy alpha-beta ai\n\t\tif(aiThread)\n\t\t\tthis.StartThreadedMachine(aOptions,\"alpha-beta\");\n\t\telse {\n\t\t\tthis.mSavedVisitedBoards={}\n\t\t\tfor(var s in this.mVisitedBoards)\n\t\t\t\tthis.mSavedVisitedBoards[s]=this.mVisitedBoards[s];\n\t\t\tthis.Engine(this.mBoard, this.mTopLevel, false, 0, aOptions.potential); // start algo\n\t\t\tthis.Run();\n\t\t}\n\t}\n}\n\nJocGame.prototype.StartThreadedMachine = function(aOptions,algo) {\n\tvar $this = this;\n\tdelete aOptions.Done;\n\tdelete aOptions.Progress;\n\tvar t0 = Date.now();\n\tif(!this.aiWorker) {\n\t\tthis.aiWorker = new Worker(this.config.baseURL+'jocly.aiworker.js');\n\t\tthis.aiWorker.postMessage({\n\t\t\ttype: \"Init\",\n\t\t\tbaseURL: this.config.baseURL,\n\t\t\t//modelURL: this.config.baseURL+\"games/\"+this.config.model.module+\"/\"+this.name+\"-model.js\",\n\t\t\toptions: aOptions,\n\t\t\tt0: t0\n\t\t});\n\t}\n\tthis.aiWorker.onmessage = function(e) {\n\t\tvar message = e.data;\n\t\tswitch(message.type) {\n\t\t\tcase \"Progress\":\n\t\t\t\t$this.mProgressCallback(message.percent);\n\t\t\t\tbreak;\n\t\t\tcase \"Done\":\n\t\t\t\t$this.mBestMoves = message.data.moves;\n\t\t\t\t$this.mPickedMoveIndex = message.data.moveIndex;\n\t\t\t\t$this.mExploredCount = message.data.explored;\n\t\t\t\t$this.mDuration = message.data.duration;\n\t\t\t\t$this.mBoard.evaluation = message.data.evaluation;\n\t\t\t\t$this.Done();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tthis.aiWorker.postMessage({\n\t\ttype: \"Play\",\n\t\tplayedMoves: this.mPlayedMoves,\n\t\tgameOptions: this.mOptions,\n\t\tgameName: this.name,\n\t\toptions: aOptions,\n\t\talgo: algo,\n\t\tt0: t0\n\t});\n}\n\nJocGame.prototype.StopThreadedMachine = function() {\n\tif(this.aiWorker) {\n\t\ttry {\n\t\t\tthis.aiWorker.terminate();\n\t\t\tdelete this.aiWorker;\n\t\t} catch(e) {\n\t\t\tconsole.warn(\"Cannot terminate worker\",e);\n\t\t}\n\t}\n}\n\nJocGame.prototype.ScheduleStep = function() {\n\tthis.mNextSchedule = this.ExecuteStep;\n}\n\nJocGame.prototype.Random = function(roof) {\n\tvar value;\n\tif(this.mRandomSeed)\n\t\tvalue = this.mRandomSeed % roof; \n\telse\n\t\tvalue = Math.floor(Math.random()*roof);\n\treturn value;\n}\n\nJocGame.prototype.ArrayShuffle = function(arr) {\n\tvar i = arr.length;\n\tif (i<=0) return;\n\twhile (--i) {\n\t\tvar j;\n\t\tif(this.mRandomSeed)\n\t\t\tj=this.mRandomSeed%(i+1);\n\t\telse\n\t\t\tj=Math.floor(Math.random()*(i+1));\n\t\tvar tmp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = tmp;\n\t}\n}\n\nJocGame.prototype.Done = function() {\n\tthis.mDuration = new Date().getTime() - this.mStartTime;\n\tif(this.mOptions.levelOptionsSaved) {\n\t\tthis.mOptions.levelOptions=this.mOptions.levelOptionsSaved;\n\t\tthis.mOptions.levelOptionsSaved=null;\n\t}\n\tif(this.mSavedVisitedBoards)\n\t\tthis.mVisitedBoards=this.mSavedVisitedBoards;\n\tif (this.mDoneCallback) {\n\t\tthis.mPickedMoveIndex = this.Random(this.mBestMoves.length);\n\t\ttry {\n\t\t\tif(this.mProgressCallback) {\n\t\t\t\tthis.mProgressCallback(100);\n\t\t\t}\n\t\t\tthis.mDoneCallback( {\n\t\t\t\tmoves : this.mBestMoves,\n\t\t\t\tmove : this.mBestMoves[this.mPickedMoveIndex],\n\t\t\t\tmoveIndex : this.mPickedMoveIndex,\n\t\t\t\texplored : this.mExploredCount,\n\t\t\t\tduration : this.mDuration,\n\t\t\t\tevaluation : this.mBoard.mEvaluation\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tJocLog(\"!!! Done:\" + e,e.stack?e.stack:\"\");\n\t\t}\n\t}\n}\n\nJocGame.prototype.Run = function() {\n\tvar t0=Date.now();\n\ttry {\n\t\tvar tNow = new Date().getTime();\n\t\twhile (this.mNextSchedule && new Date().getTime()-tNow<20 && this.mAborted==false) {\n\t\t\tvar fnt = this.mNextSchedule;\n\t\t\tthis.mNextSchedule = null;\n\t\t\tfnt.call(this);\n\t\t}\n\t\tif(this.mAborted) {\n\t\t\tthis.mAbortCallback();\n\t\t} else if (this.mNextSchedule) {\n\t\t\tJocUtil.schedule(this, \"Run\", {});\n\t\t}\n\t} catch(e) { \n\t\tJocLog(\"JocGame.Run \"+e+\"\\n\"+e.stack);\n\t}\n\tvar t1=Date.now();\n\tengdbg_loops++;\n\tengdbg_time+=t1-t0;\n}\n\nJocGame.prototype.Abort = function(aAbortCallback) {\n\tvar $this=this;\n\tthis.mAbortCallback=function() {\n\t\tif($this.mOptions.levelOptionsSaved) {\n\t\t\t$this.mOptions.levelOptions=$this.mOptions.levelOptionsSaved;\n\t\t\t$this.mOptions.levelOptionsSaved=null;\n\t\t}\n\t\tif($this.mSavedVisitedBoards) {\n\t\t\t$this.mVisitedBoards=$this.mSavedVisitedBoards;\n\t\t\t$this.mSavedVisitedBoards=null;\n\t\t}\n\t\taAbortCallback();\n\t}\n\tthis.mAborted=true;\n}\n\nJocGame.prototype.Engine = function(aBoard, aLevel, aBAlpha, aAlpha, aPotential) {\n\tvar context = {\n\t\tmBoard : aBoard,\n\t\tmLevel : aLevel,\n\t\tmBAlpha : aBAlpha,\n\t\tmAlpha : aAlpha,\n\t\tmBestEvaluation : 0,\n\t\tmMoveIndex : 0,\n\t\tmNextBoard : null,\n\t\tmNextBoards : null\n\t}\n\tthis.mContexts.push(context);\n\n\tcontext.mBoard.mFinished = false;\n\tcontext.mBoard.mWinner = JocGame.DRAW;\n\tthis.mCurrentLevel=aLevel; \n\tif(typeof context.mBoard.mMoves == \"undefined\")\n\t\tcontext.mBoard.mMoves = [];\n\tif(context.mBoard.mMoves.length==0)\n\t\tcontext.mBoard.GenerateMoves(this);\n\n\t//JocLog(\"Level \"+aLevel+\" \"+context.mBoard.mMoves.length+\" moves\");\n\tif (context.mBoard.mMoves.length == 0 && context.mBoard.mFinished == false) {\n\t\tcontext.mBoard.Evaluate(this,true,false);\n\t\tif(context.mBoard.mFinished == false) {\n\t\t\tJocLog(\"!!! No move possible while not finished - player\",this.mWho,\"board\",context.mBoard);\n\t\t\tcontext.mBoard.mFinished=true;\n\t\t}\n\t}\n\t\t\n\t//JocLog(\"No possible move level \"+aLevel+\" from \"+JSON.stringify(context.mBoard));\n\tif(context.mBoard.mFinished) {\n\t\tswitch (context.mBoard.mWinner) {\n\t\tcase JocGame.PLAYER_A:\n\t\t\tcontext.mBoard.mEvaluation = JocGame.MAX_VALUE - (this.mTopLevel - context.mLevel);\n\t\t\tbreak;\n\t\tcase JocGame.PLAYER_B:\n\t\t\tcontext.mBoard.mEvaluation = -JocGame.MAX_VALUE + (this.mTopLevel - context.mLevel);\n\t\t\tbreak;\n\t\t}\n\t\tcontext.mBestEvaluation = context.mBoard.mEvaluation;\n\t\tthis.ExecuteStep2();\n\t\treturn;\n\t}\n\n\tcontext.mExploCtrl={\n\t\texploFrom: this.mExploredCount,\n\t\texploTo: this.mExploredCount+aPotential,\n\t}\n\t\n\tif(context.mBoard.QuickEvaluate) {\n\t\tvar boardsMoves=[];\n\t\tfor(var i in context.mBoard.mMoves) {\n\t\t\tvar board=context.mBoard.MakeAndApply(this,i);\n\t\t\tvar quickEval=board.QuickEvaluate(this);\n\t\t\tboardsMoves.push({\n\t\t\t\tmove: context.mBoard.mMoves[i],\n\t\t\t\tboard: board,\n\t\t\t\tevaluation: quickEval\n\t\t\t});\n\t\t}\n\t\tfunction MoveSort(bm1,bm2) {\n\t\t\treturn (bm2.evaluation-bm1.evaluation)*context.mBoard.mWho;\n\t\t}\n\t\tboardsMoves.sort(MoveSort);\n\t\tcontext.mBoard.mMoves=[];\n\t\tcontext.mNextBoards=[];\n\t\tif(typeof this.mOptions.capMoves != \"undefined\")\n\t\t\tboardsMoves=boardsMoves.slice(0,this.mOptions.capMoves);\n\t\tfor(var i in boardsMoves) {\n\t\t\tcontext.mBoard.mMoves.push(boardsMoves[i].move);\n\t\t\tcontext.mNextBoards.push(boardsMoves[i].board);\n\t\t}\n\t}\n\tthis.ExecuteStep();\n}\n\nJocGame.prototype.ExecuteStep = function() {\n\tthis.mExploredCount++;\n\t// JocLog(\"# context: \"+this.mContexts.length);\n\tvar context = this.mContexts[this.mContexts.length - 1];\n\t//JocLog(\"ExecuteStep level \"+context.mLevel+\" index \"+context.mMoveIndex+\"/\"+context.mBoard.mMoves.length);\n\tif(context.mNextBoards) {\n\t\tcontext.mNextBoard = context.mNextBoards[context.mMoveIndex];\n\t} else {\n\t\tcontext.mNextBoard = context.mBoard.MakeAndApply(this,context.mMoveIndex);\n\t}\n\n\tif(this.mProgressCallback) {\n\t\tvar percent=null;\n\t\tif(context.mLevel==this.mTopLevel)\n\t\t\tpercent=Math.floor((context.mMoveIndex*100)/context.mBoard.mMoves.length);\n\t\telse if(context.mLevel==this.mTopLevel-1) {\n\t\t\tvar topContext=this.mContexts[0];\n\t\t\tvar topStep=1/topContext.mBoard.mMoves.length;\n\t\t\tpercent=Math.floor(100*(topContext.mMoveIndex*topStep+(context.mMoveIndex*topStep/context.mBoard.mMoves.length)));\n\t\t}\n\t\tif(percent!=null) \n\t\t\ttry {\n\t\t\t\tthis.mProgressCallback(percent);\n\t\t\t} catch(e) {}\n\t}\n\n\tvar nextBoard = context.mNextBoard;\n\tnextBoard.mFinished = false;\n\tnextBoard.mWinner = 0;\n\tnextBoard.Evaluate(this,context.mLevel==0,false,this);\n\t\n\tif(context.mLevel<0) // random mode\n\t\tnextBoard.mEvaluation=0;\n\t\n\t// JocLog(\"Eval2 \"+nextBoard.mFinished+\"/\"+nextBoard.mWinner+\"/\"+nextBoard.mEvaluation);\n\tif (nextBoard.mFinished) {\n\t\tswitch (nextBoard.mWinner) {\n\t\tcase JocGame.PLAYER_A:\n\t\t\tnextBoard.mEvaluation = JocGame.MAX_VALUE - (this.mTopLevel - context.mLevel);\n\t\t\tbreak;\n\t\tcase JocGame.PLAYER_B:\n\t\t\tnextBoard.mEvaluation = -JocGame.MAX_VALUE + (this.mTopLevel - context.mLevel);\n\t\t\tbreak;\n\t\tcase JocGame.DRAW:\n\t\t\tnextBoard.mEvaluation = 0;\n\t\t\tbreak;\n\t\t}\n\t} else if(context.mLevel==this.mTopLevel && context.mBoard.mMoves.length==1) {\n\t\t// one possible move at top level: no need to recurse\n\t} else if (context.mLevel > 0) {\n\t\tvar potential=(context.mExploCtrl.exploTo-this.mExploredCount)/context.mBoard.mMoves.length;\n\t\t//JocLog(\"ExecuteStep\",potential,context.mLevel,context.mExploCtrl);\n\t\tif(potential>=1) { \n\t\t\tnextBoard.mWho = -nextBoard.mWho; // player changes\n\t\t\tthis.Engine(nextBoard, context.mLevel - 1, (context.mMoveIndex != 0),\n\t\t\t\t\tcontext.mBestEvaluation,potential); // recurse algo\n\t\t\treturn;\n\t\t}\n\t}\n\tthis.ExecuteStep2();\n}\n\nJocGame.prototype.ExecuteStep2 = function() {\n\tvar context = this.mContexts[this.mContexts.length - 1];\n\t//JocLog(\"ExecuteStep2 level \"+context.mLevel+\" index \"+context.mMoveIndex+\" \"+JSON.stringify(context.mBoard.board));\n\tif(context.mBoard.mMoves.length>0) {\n\t\tif (context.mMoveIndex == 0) { // first evaluated move\n\t\t\tcontext.mBestEvaluation = context.mNextBoard.mEvaluation; // then it's the best one so far\n\t\t\tif (context.mLevel == this.mTopLevel) // if top level\n\t\t\t\tthis.SetBest(context.mBoard.mMoves[0], context.mBoard); // store move\n\t\t} else { // another move evaluated\n\t\t\tif (context.mNextBoard.mWho > 0) { // B plays\n\t\t\t\tif (context.mNextBoard.mEvaluation > context.mBestEvaluation) { // best move ?\n\t\t\t\t\tcontext.mBestEvaluation = context.mNextBoard.mEvaluation; // remember it\n\t\t\t\t\tif (context.mLevel == this.mTopLevel) // if top level\n\t\t\t\t\t\tthis.SetBest(context.mBoard.mMoves[context.mMoveIndex],\n\t\t\t\t\t\t\t\tcontext.mBoard); // then store\n\t\t\t\t} else if (context.mLevel == this.mTopLevel\n\t\t\t\t\t\t&& context.mNextBoard.mEvaluation == context.mBestEvaluation) { // top level and\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// another best\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// move\n\t\t\t\t\tthis.AddBest(context.mBoard.mMoves[context.mMoveIndex],\n\t\t\t\t\t\t\tcontext.mBoard); // add to best moves\n\t\t\t\t}\n\t\t\t} else { // A plays\n\t\t\t\tif (context.mNextBoard.mEvaluation < context.mBestEvaluation) { // best move\n\t\t\t\t\tcontext.mBestEvaluation = context.mNextBoard.mEvaluation; // keep it\n\t\t\t\t\tif (context.mLevel == this.mTopLevel)\n\t\t\t\t\t\tthis.SetBest(context.mBoard.mMoves[context.mMoveIndex],\n\t\t\t\t\t\t\t\tcontext.mBoard);\n\t\t\t\t} else if (context.mLevel == this.mTopLevel\n\t\t\t\t\t\t&& context.mNextBoard.mEvaluation == context.mBestEvaluation)\n\t\t\t\t\tthis.AddBest(context.mBoard.mMoves[context.mMoveIndex],\n\t\t\t\t\t\t\tcontext.mBoard);\n\t\t\t}\n\t\t}\n\t}\n\tcontext.mBoard.mEvaluation = context.mBestEvaluation; // assign best eval\n\tif (context.mBAlpha) { // alpha-beta pruning\n\t\tif ((context.mBoard.mWho == JocGame.PLAYER_A && context.mBestEvaluation > context.mAlpha)\n\t\t\t\t|| (context.mBoard.mWho == JocGame.PLAYER_B && context.mBestEvaluation < context.mAlpha)) {\n\t\t\tcontext.mMoveIndex = context.mBoard.mMoves.length - 1; \n\t\t\t//JocLog(\"Alpha-beta pruned level\");\n\t\t\t// ensure no more looking for other moves at this level\n\t\t}\n\t}\n\n\tcontext.mMoveIndex++;\n\tif (context.mMoveIndex < context.mBoard.mMoves.length) {\n\t\tthis.ScheduleStep();\n\t} else {\n\t\t//JocLog(\"BestEval level \"+context.mLevel+\": \"+context.mBestEvaluation+\" \"+context.mMoveIndex+\"/\"+context.mBoard.mMoves.length);\n\t\tthis.mContexts.pop();\n\t\tif (this.mContexts.length > 0) {\n\t\t\tvar context = this.mContexts[this.mContexts.length - 1];\n\t\t\tcontext.mNextBoard.mWho = -context.mNextBoard.mWho;\n\t\t\tthis.ExecuteStep2();\n\t\t} else {\n\t\t\tdelete context.mBoard.mMoves;\n\t\t\t//JocLog(\"Best eval \"+context.mBestEvaluation);\n\t\t\tthis.Done();\n\t\t}\n\t}\n}\n\nJocGame.prototype.SetBest = function(aMove, aBoard) {\n\tvar move = new (this.GetMoveClass())({});\n\tmove.CopyFrom(aMove);\n\tthis.mBestMoves = [ move ];\n}\n\nJocGame.prototype.AddBest = function(aMove, aBoard) {\n\tvar move = new (this.GetMoveClass())({});\n\tmove.CopyFrom(aMove);\n\tthis.mBestMoves.push(move);\n}\n\nJocGame.prototype.GetRepeatOccurence = function(board) {\n\tif(!this.mOptions.preventRepeat)\n\t\treturn -1;\n\tvar repOcc=this.mVisitedBoards[board.GetSignature()];\n\treturn repOcc;\n}\n\nJocGame.prototype.HandleRepeat = function(board) {\n\tif(this.mOptions.preventRepeat) {\n\t\tvar sign=board.GetSignature(true);\n\t\tif(this.mVisitedBoards[sign]===undefined)\n\t\t\tthis.mVisitedBoards[sign]=1;\n\t\telse\n\t\t\tthis.mVisitedBoards[sign]++;\n\t}\n}\n\nJocGame.prototype.UnhandleRepeat = function(board) {\n\tif(this.mOptions.preventRepeat) {\n\t\tvar sign=board.GetSignature(true);\n\t\tif(this.mVisitedBoards[sign]==1)\n\t\t\tdelete this.mVisitedBoards[sign];\n\t\telse if(this.mVisitedBoards[sign]>1)\n\t\t\tthis.mVisitedBoards[sign]--;\n\t}\n}\n\nJocGame.prototype.ApplyMove = function(aMove) {\n\tvar move = new (this.GetMoveClass())({});\n\tmove.CopyFrom(aMove);\n\tthis.mPlayedMoves.push(move);\n\tif(this.mFullPlayedMoves.length<this.mPlayedMoves.length)\n\t\tthis.mFullPlayedMoves.push(move);\n\telse if(!move.Equals(this.mFullPlayedMoves[this.mPlayedMoves.length-1])) {\n\t\tthis.mFullPlayedMoves=this.mFullPlayedMoves.slice(0,this.mPlayedMoves.length-1);\n\t\tthis.mFullPlayedMoves.push(move);\n\t}\n\tthis.mBoard.ApplyMove(this,aMove);\n\tthis.mBoard.mMoves=[];\n\tthis.HandleRepeat(this.mBoard);\n}\n\nJocGame.prototype.BackTo = function(aIndex,moves) {\n\tif(!moves)\n\t\tmoves=this.mFullPlayedMoves;\n\tthis.mWho = JocGame.PLAYER_A;\n\tthis.mBoard = new (this.GetBoardClass())(this);\n\tif(this.mBoard.InitialPosition)\n\t\tthis.mBoard.InitialPosition(this);\n\tif(this.mInitial && this.mInitial.turn)\n\t\tthis.mWho = this.mInitial.turn;\n\tthis.mBoard.mMoves=[];\n\tthis.mBoard.mWho = this.mWho;\n\tthis.mBestMoves = [];\n\tthis.mVisitedBoards={};\n\tthis.mPlayedMoves = [];\n\tfor(var i=0;i<aIndex;i++) {\n\t\tthis.mBoard.ApplyMove(this,moves[i]);\n\t\tthis.HandleRepeat(this.mBoard);\n\t\tthis.mBoard.mWho=-this.mBoard.mWho;\n\t\tthis.mPlayedMoves.push(moves[i]);\n\t}\n\tthis.mWho=this.mBoard.mWho;\n}\n\nJocGame.prototype.ExportInitialBoardState = function(format) {\n\tif(!this.mInitialString)\n\t\treturn null;\n\tif(typeof this.Import!=\"function\")\n\t\treturn null;\n\ttry {\n\t\tvar importResult=this.Import(\"pjn\",this.mInitialString);\n\t\tif(!importResult.status)\n\t\t\treturn null;\n\t\tvar board = new (this.GetBoardClass())(this);\n\t\tif(board.InitialPosition)\n\t\t\tboard.InitialPosition(this);\n\t\tvar boardState = board.ExportBoardState(this,format);\n\t\treturn {\n\t\t\tboardState: boardState,\n\t\t\tturn: board.mWho\n\t\t}\n\t} catch(e) {\n\t\treturn null;\n\t}\t\n}\n\nJocGame.prototype.Load = function(gameData) {\n\tthis.mWho = JocGame.PLAYER_A;\n\tthis.mBoard = new (this.GetBoardClass())(this);\n\tthis.mBoard.mMoves=[];\n\n\tif(gameData.initialBoard) {\n\t\tif(typeof this.Import!=\"function\")\n\t\t\tthrow new Error(\"Import not supported\");\n\t\tvar importResult=this.Import(\"pjn\",gameData.initialBoard);\n\t\tif(!importResult.status) {\n\t\t\tvar error = new Error(\"import failed\");\n\t\t\tswitch(importResult.error) {\n\t\t\t\tcase 'parse': error=new Error(\"import failed: parse error\"); break;\n\t\t\t\tcase 'unsupported': error=new Error(\"import failed: unsupported format\"); break;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t\tthis.mInitial=importResult.initial;\n\t\tif(this.mInitial.turn)\n\t\t\tthis.mWho = this.mInitial.turn;\n\t\tthis.mInitialString=gameData.initialBoard;\n\t}\n\tif(this.mBoard.InitialPosition)\n\t\tthis.mBoard.InitialPosition(this);\n\tthis.mBoard.mWho = this.mWho;\n\n\tthis.mBestMoves = [];\n\tthis.mVisitedBoards={};\n\tvar moves=gameData.playedMoves;\n\tthis.mPlayedMoves = [];\n\tthis.mFullPlayedMoves = [];\n\tfor(var i in moves) {\n\t\tvar move=new (this.GetMoveClass())(moves[i]);\n\t\tif(!this.IsValidMove(move))\n\t\t\tthrow \"invalid-move\";\t\t\n\t\tthis.mBoard.ApplyMove(this,move);\n\t\tthis.HandleRepeat(this.mBoard);\n\t\tthis.mBoard.mWho=-this.mBoard.mWho;\n\t\tthis.mPlayedMoves.push(move);\n\t\tthis.mFullPlayedMoves.push(move);\n\t\tthis.mBoard.mMoves=[];\n\t}\n\tthis.mWho=this.mBoard.mWho;\n\tif(this.mBoard.mFinished==false)\n\t\tthis.mBoard.Evaluate(this,true,true);\n}\n\nJocGame.prototype.CloseView = function() {\n}\n\nJocMove.prototype = {}\n\nJocMove.prototype.CopyFrom = function(aMove) {\n\tvar fields=JSON.parse(JSON.stringify(aMove));\n\tfor(var f in fields) {\n\t\tthis[f]=fields[f];\n\t}\n}\n\nJocMove.prototype.Equals = function(move) {\n\treturn JSON.stringify(this)==JSON.stringify(move);\n}\n\nJocMove.prototype.ToString = function() {\n\treturn JSON.stringify(this);\n}\n\nJocMove.prototype.Strip = function() {\n\treturn this;\n}\n\nJocBoard.prototype = {}\n\nJocBoard.prototype.Init = function(aGame) {\n}\n\nJocBoard.prototype.InitBoard = function(aGame) {\n\tthis.mDepth = 0; // no depth calc\n\tthis.mMoves = []; // move storage\n\tthis.mEvaluation = 0; // not evaluated yet\n\tthis.mFinished = false;\n\tthis.mWinner = 0;\n\tthis.Init(aGame);\n}\n\nJocBoard.prototype.CopyFrom = function(aBoard) {\n\tvar signature=aBoard.mSignature;\n\tdelete(aBoard.mSignature);\n\tvar fields=JSON.parse(JSON.stringify(aBoard));\n\tfor(var f in fields) {\n\t\tthis[f]=fields[f];\n\t}\n\taBoard.mSignature=signature;\n}\n\nJocBoard.prototype.GetSignature = function() {\n\tif(arguments[0] || !this.mSignature) {\n\t\tvar moves=this.mMoves;\n\t\tdelete(this.mMoves);\n\t\tdelete(this.mSignature);\n\t\tthis.mSignature=JocUtil.md5(JSON.stringify(this));\n\t\t//JocLog(\"signature\",this.mSignature,this);\n\t\tthis.mMoves=moves;\n\t}\n\treturn this.mSignature;\n}\n\nJocBoard.prototype.ApplyMove = function(aGame,aMove) {\n\tJocLog(\"Method JocBoard:ApplyMove() must be overloaded\");\n\t// must be overloaded\n}\n\nJocBoard.prototype.GenerateMoves = function(aGame) {\n\tJocLog(\"Method JocBoard:GenerateMoves() must be overloaded\");\n\t// must be overloaded\n}\n\nJocBoard.prototype.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\tJocLog(\"Method JocBoard:Evaluate() must be overloaded\");\n\tthis.mEvaluation = 0; // must be overloaded\n}\n\nJocBoard.prototype.HumanTurn = function() {\n}\n\nJocBoard.prototype.HumanTurnEnd = function() {\n}\n\nJocBoard.prototype.PlayedMove = function() {\n}\n\nJocBoard.prototype.ShowEnd = function() {\n}\n\nJocBoard.prototype.MakeAndApply = function(aGame,aIndex) {\n\tvar board = new (aGame.GetBoardClass())(aGame);\t\n\tboard.CopyFrom(this);\n\tboard.mWho = this.mWho;\n\tboard.mBoardClass = this.mBoardClass;\n\tboard.ApplyMove(aGame,this.mMoves[aIndex]); // apply move\n\tboard.mMoves=[];\n\treturn board;\n}\n\nJocBoard.prototype.IsValidMove = function(aGame,move) {\n\tif(typeof move.Equals != \"function\")\n\t\tmove=aGame.CreateMove(move);\n\tif(!this.mMoves || this.mMoves.length==0) {\n\t\tthis.mCurrentLevel=-1;\n\t\tthis.GenerateMoves(aGame);\n\t}\n\tfor(var i in this.mMoves) {\n\t\tif(move.Equals(this.mMoves[i]))\n\t\t\treturn true;\n\t}\n\tconsole.error(\"Invalid move \"+JSON.stringify(move)+\" in \"+JSON.stringify(this.mMoves));\n\treturn false;\n}\n\nJocBoard.prototype.PushMove = function(aGame,args) {\n\tthis.mMoves.push(aGame.CreateMove(args));\n}\n\n\nJocBoard.prototype.GenerateMoveObjects = function(aGame) {\n\tvar moves=[];\n\tthis.mMoves=[];\n\tthis.GenerateMoves(aGame);\n\tfor(var i=0;i<this.mMoves.length;i++)\n\t\tmoves.push(aGame.CreateMove(this.mMoves[i]));\n\tthis.mMoves=moves;\n}\n\nJocBoard.prototype.ExportBoardState = function(aGame) {\n\treturn JSON.stringify(this);\n}\n\nJocGame.prototype.GetBestMatchingMove = function(moveStr,candidateMoves) {\n\tvar prettyMoves=[];\n\tvar $this=this;\n\tcandidateMoves.forEach(function(m) {\n\t\tif(typeof m.ToString==\"function\")\n\t\t\tprettyMoves.push(m.ToString());\n\t\telse\n\t\t\tprettyMoves.push($this.CreateMove(m).ToString());\n\t});\n\tvar bestDist=Infinity;\n\tvar bestMatches=[];\n\tcandidateMoves.forEach(function(candidate,index) {\n\t\tvar dist=JocGame.Levenshtein(moveStr,prettyMoves[index])/(Math.max(prettyMoves[index].length,moveStr.length)+1);\n\t\tif(dist==bestDist)\n\t\t\tbestMatches.push(index);\n\t\telse if(dist<bestDist) {\n\t\t\tbestMatches=[index];\n\t\t\tbestDist=dist;\n\t\t}\n\t});\n\tif(bestMatches.length==1)\n\t\treturn candidateMoves[bestMatches[0]];\n\n\tvar candidateIndexes=bestMatches;\n\tvar matches=[];\n\tcandidateIndexes.forEach(function(index) {\n\t\tvar pretty=prettyMoves[index];\n\t\tif(moveStr.indexOf(pretty)>=0 || pretty.indexOf(moveStr)>=0)\n\t\t\tmatches.push(index);\n\t});\n\tif(matches.length==1)\n\t\treturn candidateMoves[matches[0]];\n\n\tbestDist=Infinity;\n\tbestMatches=[];\n\tcandidateIndexes.forEach(function(index) {\n\t\tvar dist=0;\n\t\tvar str1=moveStr.replace(/[A-Z]/g,'');\n\t\tvar str2=prettyMoves[index].replace(/[A-Z]/g,'');\n\t\tdist+=JocGame.Levenshtein(str1,str2)/(Math.max(str1.length,str2.length)+1);\n\t\tdist+=(str1.indexOf(str2)>=0 || str2.indexOf(str1)>=0)?0:1;\n\t\tstr1=moveStr.replace(/[a-z]/g,'');\n\t\tstr2=prettyMoves[index].replace(/[a-z]/g,'');\n\t\tdist+=JocGame.Levenshtein(str1,str2)/(Math.max(str1.length,str2.length)+1);\n\t\tdist+=(str1.indexOf(str2)>=0 || str2.indexOf(str1)>=0)?0:1;\n\t\tif(dist==bestDist)\n\t\t\tbestMatches.push(index);\n\t\telse if(dist<bestDist) {\n\t\t\tbestMatches=[index];\n\t\t\tbestDist=dist;\n\t\t}\n\t});\n\tif(bestMatches.length==1)\n\t\treturn candidateMoves[bestMatches[0]];\n\treturn null;\n}\n\nJocBoard.prototype.PickMoveFromDatabase = function(aGame,database) {\n\tif(!this.mMoves || this.mMoves.length==0) {\n\t\tvar moves=[];\n\t\tthis.mMoves=[];\n\t\tthis.GenerateMoves(aGame);\n\t\tfor(var i=0;i<this.mMoves.length;i++)\n\t\t\tmoves.push(aGame.CreateMove(this.mMoves[i]));\n\t\tthis.mMoves=moves;\n\t}\n\tif(this.mMoves.length==0)\n\t\treturn null;\n\tvar key=\"\"+this.mWho+\"#\"+this.GetSignature();\n\tvar dbMoves=database[key];\n\tif(!dbMoves)\n\t\treturn null;\n\tvar totalEval=0;\n\tfor(var i=0;i<dbMoves.length;i++)\n\t\ttotalEval+=dbMoves[i].e;\n\tvar rnd=Math.random()*totalEval;\n\tvar current=0;\n\tfor(var i=0;i<dbMoves.length;i++) {\n\t\tvar dbMove=dbMoves[i];\n\t\tcurrent+=dbMove.e;\n\t\tif(current>rnd) {\n\t\t\tvar pickedMove=aGame.GetBestMatchingMove(dbMove.m,this.mMoves);\n\t\t\tif(pickedMove)\n\t\t\t\treturn [pickedMove];\n\t\t}\n\t}\n\treturn null; // never reached\n}\n\nJocBoard.prototype.CompactMoveString = function(aGame,aMove) {\n\tif(typeof aMove.ToString!=\"function\")\n\t\taMove=aGame.CreateMove(aMove);\n\treturn aMove.ToString();\n}\n\n/*-- Zobrist implementation --*/\n\nJocGame.Zobrist=function(params) {\n\tvar mt=new MersenneTwister(12345);\n\tvar paramNames=[];\n\tfor(var f in params)\n\t\tparamNames.push(f);\n\tparamNames.sort(); // ensures we walk through parameters always in same order so generated pseudo random seeds are always the same\n\tthis.seed={};\n\tfor(var pi=0;pi<paramNames.length;pi++) {\n\t\tvar f=paramNames[pi];\n\t\tvar param=params[f];\n\t\tvar seed={\n\t\t\tvalues: {},\n\t\t\tseeds:[],\n\t\t}\n\t\tvar vIndex=0;\n\t\tfor(var vi=0;vi<param.values.length;vi++)\n\t\t\tseed.values[param.values[vi]]=vIndex++;\n\t\tswitch(param.type) {\n\t\tcase \"array\":\n\t\t\tfor(var j=0;j<param.size;j++) {\n\t\t\t\tvar seeds0=[];\n\t\t\t\tfor(var i=0;i<vIndex;i++)\n\t\t\t\t\tseeds0.push(mt.genrand_int32());\n\t\t\t\tseed.seeds.push(seeds0);\n\t\t\t}\n\t\t\tseed.type=\"array\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfor(var i=0;i<vIndex;i++)\n\t\t\t\tseed.seeds.push(mt.genrand_int32());\n\t\t\tseed.type=\"simple\";\n\t\t}\n\t\tthis.seed[f]=seed;\n\t}\n\t//console.log(\"Created zobrist\",this);\n}\n\nJocGame.Zobrist.prototype={\n\tupdate: function(zobrist,name) {\n\t\t//var zobrist0=zobrist;\n\t\tvar seed=this.seed[name];\n\t\tif(seed===undefined) {\n\t\t\tconsole.error(\"Unknown Zobrist parameter\",name);\n\t\t\treturn 0;\n\t\t}\n\t\tvar vIndex=seed.values[arguments[2]];\n\t\tif(vIndex===undefined) {\n\t\t\tconsole.error(\"Undeclared Zobrist value\",arguments[2],\"as param\",name);\n\t\t\treturn 0;\n\t\t}\n\t\tswitch(seed.type) {\n\t\tcase \"simple\":\n\t\t\tzobrist^=seed.seeds[vIndex];\n\t\t\tbreak;\n\t\tcase \"array\":\n\t\t\tvar seeds=seed.seeds[arguments[3]];\n\t\t\tif(seeds===undefined) {\n\t\t\t\tconsole.error(\"Undeclared Zobrist array index\",arguments[3],\"as param\",name);\n\t\t\t\treturn 0;\t\t\t\t\n\t\t\t}\n\t\t\tzobrist^=seeds[vIndex];\n\t\t\t//console.log(\"Zobrist\",zobrist0,\"=>\",name,\"array[\",arguments[2],\"] =\",arguments[3],\"=>\",zobrist);\n\t\t\tbreak;\n\t\t}\n\t\treturn zobrist;\n\t},\n}\n\n/*--- Levenshtein distance implementation ---*/\nJocGame.Levenshtein=function(e,f){if(e==f)return 0;var d=e.length,j=f.length;if(0===d)return j;if(0===j)return d;var b=!1;try{b=!\"0\"[0]}catch(m){b=!0}\nb&&(e=e.split(\"\"),f=f.split(\"\"));for(var b=Array(d+1),g=Array(d+1),a=0,h=0,i=0,a=0;a<d+1;a++)b[a]=a;for(var c=\"\",k=\"\",h=1;h<=j;h++){g[0]=h;k=f[h-1];\nfor(a=0;a<d;a++){var c=e[a],i=c==k?0:1,c=b[a+1]+1,l=g[a]+1,i=b[a]+i;l<c&&(c=l);i<c&&(c=i);g[a+1]=c}a=b;b=g;g=a}return b[d]};\n\n"]}