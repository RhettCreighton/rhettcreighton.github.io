{"version":3,"sources":["SubdivisionModifier.js","tween.js","tween.fix.js","JoclyOrbitControls.js","DeviceOrientationControls.js","Projector.js","threex.domevent.js","threex.domevent.object3d.js","StereoEffect.js","AnaglyphEffect.js","VRGamepad.js","VRControls.js","VREffect.js","OBJLoader.js","MTLLoader.js","kalman.js","jocly.ar.js","jocly.state-machine.js","jocly.xd-view.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACj6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACziBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jocly-xdview.js","sourcesContent":["/*\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog \n *\n *\tSubdivision Geometry Modifier \n *\t\tusing Catmull-Clark Subdivision Surfaces\n *\t\tfor creating smooth geometry meshes\n *\n *\tNote: a modifier modifies vertices and faces of geometry,\n *\t\tso use geometry.clone() if original geometry needs to be retained\n * \n *\tReadings: \n *\t\thttp://en.wikipedia.org/wiki/Catmull%E2%80%93Clark_subdivision_surface\n *\t\thttp://www.rorydriscoll.com/2008/08/01/catmull-clark-subdivision-the-basics/\n *\t\thttp://xrt.wikidot.com/blog:31\n *\t\t\"Subdivision Surfaces in Character Animation\"\n *\n *\t\t(on boundary edges)\n *\t\thttp://rosettacode.org/wiki/Catmull%E2%80%93Clark_subdivision_surface\n *\t\thttps://graphics.stanford.edu/wikis/cs148-09-summer/Assignment3Description\n *\n *\tSupports:\n *\t\tClosed and Open geometries.\n *\n *\tTODO:\n *\t\tcrease vertex and \"semi-sharp\" features\n *\t\tselective subdivision\n */\n\nTHREE.SubdivisionModifier = function ( subdivisions ) {\n\n\tthis.subdivisions = (subdivisions === undefined ) ? 1 : subdivisions;\n\n\t// Settings\n\tthis.useOldVertexColors = false;\n\tthis.supportUVs = true;\n\tthis.debug = false;\n\n};\n\n// Applies the \"modify\" pattern\nTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\tvar repeats = this.subdivisions;\n\n\twhile ( repeats-- > 0 ) {\n\t\tthis.smooth( geometry );\n\t}\n\n};\n\n/// REFACTORING THIS OUT\n\nTHREE.GeometryUtils.orderedKey = function ( a, b ) {\n\n\treturn Math.min( a, b ) + \"_\" + Math.max( a, b );\n\n};\n\n\n// Returns a hashmap - of { edge_key: face_index }\nTHREE.GeometryUtils.computeEdgeFaces = function ( geometry ) {\n\n\tvar i, il, v1, v2, j, k,\n\t\tface, faceIndices, faceIndex,\n\t\tedge,\n\t\thash,\n\t\tedgeFaceMap = {};\n\n\tvar orderedKey = THREE.GeometryUtils.orderedKey;\n\n\tfunction mapEdgeHash( hash, i ) {\n\n\t\tif ( edgeFaceMap[ hash ] === undefined ) {\n\n\t\t\tedgeFaceMap[ hash ] = [];\n\n\t\t}\n\n\t\tedgeFaceMap[ hash ].push( i );\n\t}\n\n\n\t// construct vertex -> face map\n\n\tfor( i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\tface = geometry.faces[ i ];\n\n\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\thash = orderedKey( face.a, face.b );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.b, face.c );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.c, face.a );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\thash = orderedKey( face.a, face.b );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.b, face.c );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.c, face.d );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t\thash = orderedKey( face.d, face.a );\n\t\t\tmapEdgeHash( hash, i );\n\n\t\t}\n\n\t}\n\n\t// extract faces\n\n\t// var edges = [];\n\t// \n\t// var numOfEdges = 0;\n\t// for (i in edgeFaceMap) {\n\t// \tnumOfEdges++;\n\t//\n\t// \tedge = edgeFaceMap[i];\n\t// \tedges.push(edge);\n\t//\n\t// }\n\n\t//debug('edgeFaceMap', edgeFaceMap, 'geometry.edges',geometry.edges, 'numOfEdges', numOfEdges);\n\n\treturn edgeFaceMap;\n\n}\n\n/////////////////////////////\n\n// Performs an iteration of Catmull-Clark Subdivision\nTHREE.SubdivisionModifier.prototype.smooth = function ( oldGeometry ) {\n\n\t//debug( 'running smooth' );\n\n\t// New set of vertices, faces and uvs\n\tvar newVertices = [], newFaces = [], newUVs = [];\n\n\tfunction v( x, y, z ) {\n\t\tnewVertices.push( new THREE.Vector3( x, y, z ) );\n\t}\n\n\tvar scope = this;\n\tvar orderedKey = THREE.GeometryUtils.orderedKey;\n\tvar computeEdgeFaces = THREE.GeometryUtils.computeEdgeFaces;\n\n\tfunction assert() {\n\n\t\tif (scope.debug && console && console.assert) console.assert.apply(console, arguments);\n\n\t}\n\n\tfunction debug() {\n\n\t\tif (scope.debug) console.log.apply(console, arguments);\n\n\t}\n\n\tfunction warn() {\n\n\t\tif (console)\n\t\tconsole.log.apply(console, arguments);\n\n\t}\n\n\tfunction f4( a, b, c, d, oldFace, orders, facei ) {\n\n\t\t// TODO move vertex selection over here!\n\n\t\tvar newFace = new THREE.Face4( a, b, c, d, null, oldFace.color, oldFace.materialIndex );\n\n\t\tif (scope.useOldVertexColors) {\n\n\t\t\tnewFace.vertexColors = []; \n\n\t\t\tvar color, tmpColor, order;\n\n\t\t\tfor (var i=0;i<4;i++) {\n\n\t\t\t\torder = orders[i];\n\n\t\t\t\tcolor = new THREE.Color(),\n\t\t\t\tcolor.setRGB(0,0,0);\n\n\t\t\t\tfor (var j=0, jl=0; j<order.length;j++) {\n\t\t\t\t\ttmpColor = oldFace.vertexColors[order[j]-1];\n\t\t\t\t\tcolor.r += tmpColor.r;\n\t\t\t\t\tcolor.g += tmpColor.g;\n\t\t\t\t\tcolor.b += tmpColor.b;\n\t\t\t\t}\n\n\t\t\t\tcolor.r /= order.length;\n\t\t\t\tcolor.g /= order.length;\n\t\t\t\tcolor.b /= order.length;\n\n\t\t\t\tnewFace.vertexColors[i] = color;\n\n\t\t\t}\n\n\t\t}\n\n\t\tnewFaces.push( newFace );\n\n\t\tif (scope.supportUVs) {\n\n\t\t\tvar aUv = [\n\t\t\t\tgetUV(a, ''),\n\t\t\t\tgetUV(b, facei),\n\t\t\t\tgetUV(c, facei),\n\t\t\t\tgetUV(d, facei)\n\t\t\t];\n\n\t\t\tif (!aUv[0]) debug('a :( ', a+':'+facei);\n\t\t\telse if (!aUv[1]) debug('b :( ', b+':'+facei);\n\t\t\telse if (!aUv[2]) debug('c :( ', c+':'+facei);\n\t\t\telse if (!aUv[3]) debug('d :( ', d+':'+facei);\n\t\t\telse \n\t\t\t\tnewUVs.push( aUv );\n\n\t\t}\n\t}\n\n\tvar originalPoints = oldGeometry.vertices;\n\tvar originalFaces = oldGeometry.faces;\n\tvar originalVerticesLength = originalPoints.length;\n\n\tvar newPoints = originalPoints.concat(); // New set of vertices to work on\n\n\tvar facePoints = [], // these are new points on exisiting faces\n\t\tedgePoints = {}; // these are new points on exisiting edges\n\n\tvar sharpEdges = {}, sharpVertices = []; // Mark edges and vertices to prevent smoothening on them\n\t// TODO: handle this correctly.\n\n\tvar uvForVertices = {}; // Stored in {vertex}:{old face} format\n\n\n\tfunction debugCoreStuff() {\n\n\t\tconsole.log('facePoints', facePoints, 'edgePoints', edgePoints);\n\t\tconsole.log('edgeFaceMap', edgeFaceMap, 'vertexEdgeMap', vertexEdgeMap);\n\n\t}\n\n\tfunction getUV(vertexNo, oldFaceNo) {\n\t\tvar j,jl;\n\n\t\tvar key = vertexNo+':'+oldFaceNo;\n\t\tvar theUV = uvForVertices[key];\n\n\t\tif (!theUV) {\n\t\t\tif (vertexNo>=originalVerticesLength && vertexNo < (originalVerticesLength + originalFaces.length)) {\n\t\t\t\tdebug('face pt');\n\t\t\t} else {\n\t\t\t\tdebug('edge pt');\n\t\t\t}\n\n\t\t\twarn('warning, UV not found for', key);\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn theUV;\n \n\t\t// Original faces -> Vertex Nos. \n\t\t// new Facepoint -> Vertex Nos.\n\t\t// edge Points\n\n\t}\n\n\tfunction addUV(vertexNo, oldFaceNo, value) {\n\n\t\tvar key = vertexNo+':'+oldFaceNo;\n\t\tif (!(key in uvForVertices)) {\n\t\t\tuvForVertices[key] = value;\n\t\t} else {\n\t\t\twarn('dup vertexNo', vertexNo, 'oldFaceNo', oldFaceNo, 'value', value, 'key', key, uvForVertices[key]);\n\t\t}\n\t}\n\n\t// Step 1\n\t//\tFor each face, add a face point\n\t//\tSet each face point to be the centroid of all original points for the respective face.\n\t// debug(oldGeometry);\n\tvar i, il, j, jl, face;\n\n\t// For Uvs\n\tvar uvs = oldGeometry.faceVertexUvs[0];\n\tvar abcd = 'abcd', vertice;\n\n\tdebug('originalFaces, uvs, originalVerticesLength', originalFaces.length, uvs.length, originalVerticesLength);\n\n\tif (scope.supportUVs)\n\n\tfor (i=0, il = uvs.length; i<il; i++ ) {\n\n\t\tfor (j=0,jl=uvs[i].length;j<jl;j++) {\n\n\t\t\tvertice = originalFaces[i][abcd.charAt(j)];\n\t\t\taddUV(vertice, i, uvs[i][j]);\n\n\t\t}\n\n\t}\n\n\tif (uvs.length == 0) scope.supportUVs = false;\n\n\t// Additional UVs check, if we index original \n\tvar uvCount = 0;\n\tfor (var u in uvForVertices) {\n\t\tuvCount++;\n\t}\n\tif (!uvCount) {\n\t\tscope.supportUVs = false;\n\t\tdebug('no uvs');\n\t}\n\n\tvar avgUv ;\n\n\tfor (i=0, il = originalFaces.length; i<il ;i++) {\n\n\t\tface = originalFaces[ i ];\n\t\tfacePoints.push( face.centroid );\n\t\tnewPoints.push( face.centroid );\n\n\t\tif (!scope.supportUVs) continue;\n\n\t\t// Prepare subdivided uv\n\n\t\tavgUv = new THREE.Vector2();\n\n\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\tavgUv.x = getUV( face.a, i ).x + getUV( face.b, i ).x + getUV( face.c, i ).x;\n\t\t\tavgUv.y = getUV( face.a, i ).y + getUV( face.b, i ).y + getUV( face.c, i ).y;\n\t\t\tavgUv.x /= 3;\n\t\t\tavgUv.y /= 3;\n\n\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\tavgUv.x = getUV( face.a, i ).x + getUV( face.b, i ).x + getUV( face.c, i ).x + getUV( face.d, i ).x;\n\t\t\tavgUv.y = getUV( face.a, i ).y + getUV( face.b, i ).y + getUV( face.c, i ).y + getUV( face.d, i ).y;\n\t\t\tavgUv.x /= 4;\n\t\t\tavgUv.y /= 4;\n\n\t\t}\n\n\t\taddUV(originalVerticesLength + i, '', avgUv);\n\n\t}\n\n\t// Step 2\n\t//\tFor each edge, add an edge point.\n\t//\tSet each edge point to be the average of the two neighbouring face points and its two original endpoints.\n\n\tvar edgeFaceMap = computeEdgeFaces ( oldGeometry ); // Edge Hash -> Faces Index  eg { edge_key: [face_index, face_index2 ]}\n\tvar edge, faceIndexA, faceIndexB, avg;\n\n\t// debug('edgeFaceMap', edgeFaceMap);\n\n\tvar edgeCount = 0;\n\n\tvar edgeVertex, edgeVertexA, edgeVertexB;\n\n\t////\n\n\tvar vertexEdgeMap = {}; // Gives edges connecting from each vertex\n\tvar vertexFaceMap = {}; // Gives faces connecting from each vertex\n\n\tfunction addVertexEdgeMap(vertex, edge) {\n\n\t\tif (vertexEdgeMap[vertex]===undefined) {\n\n\t\t\tvertexEdgeMap[vertex] = [];\n\n\t\t}\n\n\t\tvertexEdgeMap[vertex].push(edge);\n\t}\n\n\tfunction addVertexFaceMap(vertex, face, edge) {\n\n\t\tif (vertexFaceMap[vertex]===undefined) {\n\n\t\t\tvertexFaceMap[vertex] = {};\n\n\t\t}\n\n\t\tvertexFaceMap[vertex][face] = edge;\n\t\t// vertexFaceMap[vertex][face] = null;\n\t}\n\n\t// Prepares vertexEdgeMap and vertexFaceMap\n\tfor (i in edgeFaceMap) { // This is for every edge\n\t\tedge = edgeFaceMap[i];\n\n\t\tedgeVertex = i.split('_');\n\t\tedgeVertexA = edgeVertex[0];\n\t\tedgeVertexB = edgeVertex[1];\n\n\t\t// Maps an edgeVertex to connecting edges\n\t\taddVertexEdgeMap(edgeVertexA, [edgeVertexA, edgeVertexB] );\n\t\taddVertexEdgeMap(edgeVertexB, [edgeVertexA, edgeVertexB] );\n\n\t\tfor (j=0,jl=edge.length;j<jl;j++) {\n\n\t\t\tface = edge[j];\n\t\t\taddVertexFaceMap(edgeVertexA, face, i);\n\t\t\taddVertexFaceMap(edgeVertexB, face, i);\n\n\t\t}\n\n\t\t// {edge vertex: { face1: edge_key, face2: edge_key.. } }\n\n\t\t// this thing is fishy right now.\n\t\tif (edge.length < 2) {\n\n\t\t\t// edge is \"sharp\";\n\t\t\tsharpEdges[i] = true;\n\t\t\tsharpVertices[edgeVertexA] = true;\n\t\t\tsharpVertices[edgeVertexB] = true;\n\n\t\t}\n\n\t}\n\n\tfor (i in edgeFaceMap) {\n\n\t\tedge = edgeFaceMap[i];\n\n\t\tfaceIndexA = edge[0]; // face index a\n\t\tfaceIndexB = edge[1]; // face index b\n\n\t\tedgeVertex = i.split('_');\n\t\tedgeVertexA = edgeVertex[0];\n\t\tedgeVertexB = edgeVertex[1];\n\n\t\tavg = new THREE.Vector3();\n\n\t\t//debug(i, faceIndexB,facePoints[faceIndexB]);\n\n\t\tassert(edge.length > 0, 'an edge without faces?!');\n\n\t\tif (edge.length==1) {\n\n\t\t\tavg.add( originalPoints[ edgeVertexA ] );\n\t\t\tavg.add( originalPoints[ edgeVertexB ] );\n\t\t\tavg.multiplyScalar( 0.5 );\n\n\t\t\tsharpVertices[newPoints.length] = true;\n\n\t\t} else {\n\n\t\t\tavg.add( facePoints[ faceIndexA ] );\n\t\t\tavg.add( facePoints[ faceIndexB ] );\n\n\t\t\tavg.add( originalPoints[ edgeVertexA ] );\n\t\t\tavg.add( originalPoints[ edgeVertexB ] );\n\n\t\t\tavg.multiplyScalar( 0.25 );\n\n\t\t}\n\n\t\tedgePoints[i] = originalVerticesLength + originalFaces.length + edgeCount;\n\n\t\tnewPoints.push( avg );\n\n\t\tedgeCount ++;\n\n\t\tif (!scope.supportUVs) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Prepare subdivided uv\n\n\t\tavgUv = new THREE.Vector2();\n\n\t\tavgUv.x = getUV(edgeVertexA, faceIndexA).x + getUV(edgeVertexB, faceIndexA).x;\n\t\tavgUv.y = getUV(edgeVertexA, faceIndexA).y + getUV(edgeVertexB, faceIndexA).y;\n\t\tavgUv.x /= 2;\n\t\tavgUv.y /= 2;\n\n\t\taddUV(edgePoints[i], faceIndexA, avgUv);\n\n\t\tif (edge.length>=2) {\n\t\t\tassert(edge.length == 2, 'did we plan for more than 2 edges?');\n\t\t\tavgUv = new THREE.Vector2();\n\n\t\t\tavgUv.x = getUV(edgeVertexA, faceIndexB).x + getUV(edgeVertexB, faceIndexB).x;\n\t\t\tavgUv.y = getUV(edgeVertexA, faceIndexB).y + getUV(edgeVertexB, faceIndexB).y;\n\t\t\tavgUv.x /= 2;\n\t\t\tavgUv.y /= 2;\n\n\t\t\taddUV(edgePoints[i], faceIndexB, avgUv);\n\t\t}\n\n\t}\n\n\tdebug('-- Step 2 done');\n\n\t// Step 3\n\t//\tFor each face point, add an edge for every edge of the face, \n\t//\tconnecting the face point to each edge point for the face.\n\n\tvar facePt, currentVerticeIndex;\n\n\tvar hashAB, hashBC, hashCD, hashDA, hashCA;\n\n\tvar abc123 = ['123', '12', '2', '23'];\n\tvar bca123 = ['123', '23', '3', '31'];\n\tvar cab123 = ['123', '31', '1', '12'];\n\tvar abc1234 = ['1234', '12', '2', '23'];\n\tvar bcd1234 = ['1234', '23', '3', '34'];\n\tvar cda1234 = ['1234', '34', '4', '41'];\n\tvar dab1234 = ['1234', '41', '1', '12'];\n\n\tfor (i=0, il = facePoints.length; i<il ;i++) { // for every face\n\t\tfacePt = facePoints[i];\n\t\tface = originalFaces[i];\n\t\tcurrentVerticeIndex = originalVerticesLength+ i;\n\n\t\tif ( face instanceof THREE.Face3 ) {\n\n\t\t\t// create 3 face4s\n\n\t\t\thashAB = orderedKey( face.a, face.b );\n\t\t\thashBC = orderedKey( face.b, face.c );\n\t\t\thashCA = orderedKey( face.c, face.a );\n\n\t\t\tf4( currentVerticeIndex, edgePoints[hashAB], face.b, edgePoints[hashBC], face, abc123, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashBC], face.c, edgePoints[hashCA], face, bca123, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashCA], face.a, edgePoints[hashAB], face, cab123, i );\n\n\t\t} else if ( face instanceof THREE.Face4 ) {\n\n\t\t\t// create 4 face4s\n\n\t\t\thashAB = orderedKey( face.a, face.b );\n\t\t\thashBC = orderedKey( face.b, face.c );\n\t\t\thashCD = orderedKey( face.c, face.d );\n\t\t\thashDA = orderedKey( face.d, face.a );\n\n\t\t\tf4( currentVerticeIndex, edgePoints[hashAB], face.b, edgePoints[hashBC], face, abc1234, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashBC], face.c, edgePoints[hashCD], face, bcd1234, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashCD], face.d, edgePoints[hashDA], face, cda1234, i );\n\t\t\tf4( currentVerticeIndex, edgePoints[hashDA], face.a, edgePoints[hashAB], face, dab1234, i );\n\n\n\t\t} else {\n\n\t\t\tdebug('face should be a face!', face);\n\n\t\t}\n\n\t}\n\n\tnewVertices = newPoints;\n\n\t// Step 4\n\n\t//\tFor each original point P, \n\t//\t\ttake the average F of all n face points for faces touching P, \n\t//\t\tand take the average R of all n edge midpoints for edges touching P, \n\t//\t\twhere each edge midpoint is the average of its two endpoint vertices. \n\t//\tMove each original point to the point\n\n\n\tvar F = new THREE.Vector3();\n\tvar R = new THREE.Vector3();\n\n\tvar n;\n\tfor (i=0, il = originalPoints.length; i<il; i++) {\n\t\t// (F + 2R + (n-3)P) / n\n\n\t\tif (vertexEdgeMap[i]===undefined) continue;\n\n\t\tF.set(0,0,0);\n\t\tR.set(0,0,0);\n\t\tvar newPos =  new THREE.Vector3(0,0,0);\n\n\t\tvar f = 0; // this counts number of faces, original vertex is connected to (also known as valance?)\n\t\tfor (j in vertexFaceMap[i]) {\n\t\t\tF.add(facePoints[j]);\n\t\t\tf++;\n\t\t}\n\n\t\tvar sharpEdgeCount = 0;\n\n\t\tn = vertexEdgeMap[i].length; // given a vertex, return its connecting edges\n\n\t\t// Are we on the border?\n\t\tvar boundary_case = f != n;\n\n\t\t// if (boundary_case) {\n\t\t// \tconsole.error('moo', 'o', i, 'faces touched', f, 'edges',  n, n == 2);\n\t\t// }\n\n\t\tfor (j=0;j<n;j++) {\n\t\t\tif (\n\t\t\t\tsharpEdges[\n\t\t\t\t\torderedKey(vertexEdgeMap[i][j][0],vertexEdgeMap[i][j][1])\n\t\t\t\t]) {\n\t\t\t\t\tsharpEdgeCount++;\n\t\t\t\t}\n\t\t}\n\n\t\t// if ( sharpEdgeCount==2 ) {\n\t\t// \tcontinue;\n\t\t// \t// Do not move vertex if there's 2 connecting sharp edges.\n\t\t// }\n\n\t\t/*\n\t\tif (sharpEdgeCount>2) {\n\t\t\t// TODO\n\t\t}\n\t\t*/\n\n\t\tF.divideScalar(f);\n\n\n\t\tvar boundary_edges = 0;\n\n\t\tif (boundary_case) {\n\n\t\t\tvar bb_edge;\n\t\t\tfor (j=0; j<n;j++) {\n\t\t\t\tedge = vertexEdgeMap[i][j];\n\t\t\t\tbb_edge = edgeFaceMap[orderedKey(edge[0], edge[1])].length == 1\n\t\t\t\tif (bb_edge) {\n\t\t\t\t\tvar midPt = originalPoints[edge[0]].clone().add(originalPoints[edge[1]]).divideScalar(2);\n\t\t\t\t\tR.add(midPt);\n\t\t\t\t\tboundary_edges++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tR.divideScalar(4);\n\t\t\t// console.log(j + ' --- ' + n + ' --- ' + boundary_edges);\n\t\t\tassert(boundary_edges == 2, 'should have only 2 boundary edges');\n\n\t\t} else {\n\t\t\tfor (j=0; j<n;j++) {\n\t\t\t\tedge = vertexEdgeMap[i][j];\n\t\t\t\tvar midPt = originalPoints[edge[0]].clone().add(originalPoints[edge[1]]).divideScalar(2);\n\t\t\t\tR.add(midPt);\n\t\t\t}\n\n\t\t\tR.divideScalar(n);\n\t\t}\n\n\t\t// Sum the formula\n\t\tnewPos.add(originalPoints[i]);\n\n\n\t\tif (boundary_case) {\n\n\t\t\tnewPos.divideScalar(2);\n\t\t\tnewPos.add(R);\n\n\t\t} else {\n\n\t\t\tnewPos.multiplyScalar(n - 3);\n\n\t\t\tnewPos.add(F);\n\t\t\tnewPos.add(R.multiplyScalar(2));\n\t\t\tnewPos.divideScalar(n);\n\n\t\t}\n\n\t\tnewVertices[i] = newPos;\n\n\t}\n\n\tvar newGeometry = oldGeometry; // Let's pretend the old geometry is now new :P\n\n\tnewGeometry.vertices = newVertices;\n\tnewGeometry.faces = newFaces;\n\tnewGeometry.faceVertexUvs[ 0 ] = newUVs;\n\n\tdelete newGeometry.__tmpVertices; // makes __tmpVertices undefined :P\n\n\tnewGeometry.computeCentroids();\n\tnewGeometry.computeFaceNormals();\n\tnewGeometry.computeVertexNormals();\n\n};\n","// tween.js r5 - http://github.com/sole/tween.js\nvar TWEEN = TWEEN || function() {\n\tvar a, e, c = 60, b = false, h = [];\n\treturn {\n\t\tsetFPS : function(f) {\n\t\t\tc = f || 60\n\t\t},\n\t\tstart : function(f) {\n\t\t\targuments.length != 0 && this.setFPS(f);\n\t\t\te = setInterval(this.update, 1E3 / c)\n\t\t},\n\t\tstop : function() {\n\t\t\tclearInterval(e)\n\t\t},\n\t\tsetAutostart : function(f) {\n\t\t\t(b = f) && !e && this.start()\n\t\t},\n\t\tadd : function(f) {\n\t\t\th.push(f);\n\t\t\tb && !e && this.start()\n\t\t},\n\t\tgetAll : function() {\n\t\t\treturn h\n\t\t},\n\t\tremoveAll : function() {\n\t\t\th = []\n\t\t},\n\t\tremove : function(f) {\n\t\t\ta = h.indexOf(f);\n\t\t\ta !== -1 && h.splice(a, 1)\n\t\t},\n\t\tupdate : function(f) {\n\t\t\ta = 0;\n\t\t\tnum_tweens = h.length;\n\t\t\tfor (f = f || Date.now(); a < num_tweens;)\n\t\t\t\tif (h[a].update(f))\n\t\t\t\t\ta++;\n\t\t\t\telse {\n\t\t\t\t\th.splice(a, 1);\n\t\t\t\t\tnum_tweens--\n\t\t\t\t}\n\t\t\tnum_tweens == 0 && b == true && this.stop()\n\t\t}\n\t}\n}();\nTWEEN.Tween = function(a) {\n\tvar e = {}, c = {}, b = {}, h = 1E3, f = 0, j = null, n = TWEEN.Easing.Linear.EaseNone, k = null, l = null, m = null;\n\tthis.to = function(d, g) {\n\t\tif (g !== null)\n\t\t\th = g;\n\t\tfor ( var i in d)\n\t\t\tif (a[i] !== null)\n\t\t\t\tb[i] = d[i];\n\t\treturn this\n\t};\n\tthis.start = function(d) {\n\t\tTWEEN.add(this);\n\t\tj = d ? d + f : Date.now() + f;\n\t\tfor ( var g in b)\n\t\t\tif (a[g] !== null) {\n\t\t\t\te[g] = a[g];\n\t\t\t\tc[g] = b[g] - a[g]\n\t\t\t}\n\t\treturn this\n\t};\n\tthis.stop = function() {\n\t\tTWEEN.remove(this);\n\t\treturn this\n\t};\n\tthis.delay = function(d) {\n\t\tf = d;\n\t\treturn this\n\t};\n\tthis.easing = function(d) {\n\t\tn = d;\n\t\treturn this\n\t};\n\tthis.chain = function(d) {\n\t\tk = d\n\t};\n\tthis.onUpdate = function(d) {\n\t\tl = d;\n\t\treturn this\n\t};\n\tthis.onComplete = function(d) {\n\t\tm = function() {\n\t\t\tvar $this=this;\n\t\t\tsetTimeout(function() {\n\t\t\t\td.call($this);\t\t\t\t\n\t\t\t},0);\n\t\t}\n\t\treturn this\n\t};\n\tthis.update = function(d) {\n\t\tvar g, i;\n\t\tif (d < j)\n\t\t\treturn true;\n\t\td = (d - j) / h;\n\t\td = d > 1 ? 1 : d;\n\t\ti = n(d);\n\t\tfor (g in c)\n\t\t\ta[g] = e[g] + c[g] * i;\n\t\tl !== null && l.call(a, i);\n\t\tif (d == 1) {\n\t\t\tm !== null && m.call(a);\n\t\t\tk !== null && k.start();\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n};\nTWEEN.Easing = {\n\tLinear : {},\n\tQuadratic : {},\n\tCubic : {},\n\tQuartic : {},\n\tQuintic : {},\n\tSinusoidal : {},\n\tExponential : {},\n\tCircular : {},\n\tElastic : {},\n\tBack : {},\n\tBounce : {}\n};\nTWEEN.Easing.Linear.EaseNone = function(a) {\n\treturn a\n};\nTWEEN.Easing.Quadratic.EaseIn = function(a) {\n\treturn a * a\n};\nTWEEN.Easing.Quadratic.EaseOut = function(a) {\n\treturn -a * (a - 2)\n};\nTWEEN.Easing.Quadratic.EaseInOut = function(a) {\n\tif ((a *= 2) < 1)\n\t\treturn 0.5 * a * a;\n\treturn -0.5 * (--a * (a - 2) - 1)\n};\nTWEEN.Easing.Cubic.EaseIn = function(a) {\n\treturn a * a * a\n};\nTWEEN.Easing.Cubic.EaseOut = function(a) {\n\treturn --a * a * a + 1\n};\nTWEEN.Easing.Cubic.EaseInOut = function(a) {\n\tif ((a *= 2) < 1)\n\t\treturn 0.5 * a * a * a;\n\treturn 0.5 * ((a -= 2) * a * a + 2)\n};\nTWEEN.Easing.Quartic.EaseIn = function(a) {\n\treturn a * a * a * a\n};\nTWEEN.Easing.Quartic.EaseOut = function(a) {\n\treturn -(--a * a * a * a - 1)\n};\nTWEEN.Easing.Quartic.EaseInOut = function(a) {\n\tif ((a *= 2) < 1)\n\t\treturn 0.5 * a * a * a * a;\n\treturn -0.5 * ((a -= 2) * a * a * a - 2)\n};\nTWEEN.Easing.Quintic.EaseIn = function(a) {\n\treturn a * a * a * a * a\n};\nTWEEN.Easing.Quintic.EaseOut = function(a) {\n\treturn (a -= 1) * a * a * a * a + 1\n};\nTWEEN.Easing.Quintic.EaseInOut = function(a) {\n\tif ((a *= 2) < 1)\n\t\treturn 0.5 * a * a * a * a * a;\n\treturn 0.5 * ((a -= 2) * a * a * a * a + 2)\n};\nTWEEN.Easing.Sinusoidal.EaseIn = function(a) {\n\treturn -Math.cos(a * Math.PI / 2) + 1\n};\nTWEEN.Easing.Sinusoidal.EaseOut = function(a) {\n\treturn Math.sin(a * Math.PI / 2)\n};\nTWEEN.Easing.Sinusoidal.EaseInOut = function(a) {\n\treturn -0.5 * (Math.cos(Math.PI * a) - 1)\n};\nTWEEN.Easing.Exponential.EaseIn = function(a) {\n\treturn a == 0 ? 0 : Math.pow(2, 10 * (a - 1))\n};\nTWEEN.Easing.Exponential.EaseOut = function(a) {\n\treturn a == 1 ? 1 : -Math.pow(2, -10 * a) + 1\n};\nTWEEN.Easing.Exponential.EaseInOut = function(a) {\n\tif (a == 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn 1;\n\tif ((a *= 2) < 1)\n\t\treturn 0.5 * Math.pow(2, 10 * (a - 1));\n\treturn 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)\n};\nTWEEN.Easing.Circular.EaseIn = function(a) {\n\treturn -(Math.sqrt(1 - a * a) - 1)\n};\nTWEEN.Easing.Circular.EaseOut = function(a) {\n\treturn Math.sqrt(1 - --a * a)\n};\nTWEEN.Easing.Circular.EaseInOut = function(a) {\n\tif ((a /= 0.5) < 1)\n\t\treturn -0.5 * (Math.sqrt(1 - a * a) - 1);\n\treturn 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1)\n};\nTWEEN.Easing.Elastic.EaseIn = function(a) {\n\tvar e, c = 0.1, b = 0.4;\n\tif (a == 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn 1;\n\tb || (b = 0.3);\n\tif (!c || c < 1) {\n\t\tc = 1;\n\t\te = b / 4\n\t} else\n\t\te = b / (2 * Math.PI) * Math.asin(1 / c);\n\treturn -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - e) * 2 * Math.PI\n\t\t\t/ b))\n};\nTWEEN.Easing.Elastic.EaseOut = function(a) {\n\tvar e, c = 0.1, b = 0.4;\n\tif (a == 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn 1;\n\tb || (b = 0.3);\n\tif (!c || c < 1) {\n\t\tc = 1;\n\t\te = b / 4\n\t} else\n\t\te = b / (2 * Math.PI) * Math.asin(1 / c);\n\treturn c * Math.pow(2, -10 * a) * Math.sin((a - e) * 2 * Math.PI / b) + 1\n};\nTWEEN.Easing.Elastic.EaseInOut = function(a) {\n\tvar e, c = 0.1, b = 0.4;\n\tif (a == 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn 1;\n\tb || (b = 0.3);\n\tif (!c || c < 1) {\n\t\tc = 1;\n\t\te = b / 4\n\t} else\n\t\te = b / (2 * Math.PI) * Math.asin(1 / c);\n\tif ((a *= 2) < 1)\n\t\treturn -0.5 * c * Math.pow(2, 10 * (a -= 1))\n\t\t\t\t* Math.sin((a - e) * 2 * Math.PI / b);\n\treturn c * Math.pow(2, -10 * (a -= 1))\n\t\t\t* Math.sin((a - e) * 2 * Math.PI / b) * 0.5 + 1\n};\nTWEEN.Easing.Back.EaseIn = function(a) {\n\treturn a * a * (2.70158 * a - 1.70158)\n};\nTWEEN.Easing.Back.EaseOut = function(a) {\n\treturn (a -= 1) * a * (2.70158 * a + 1.70158) + 1\n};\nTWEEN.Easing.Back.EaseInOut = function(a) {\n\tif ((a *= 2) < 1)\n\t\treturn 0.5 * a * a * (3.5949095 * a - 2.5949095);\n\treturn 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2)\n};\nTWEEN.Easing.Bounce.EaseIn = function(a) {\n\treturn 1 - TWEEN.Easing.Bounce.EaseOut(1 - a)\n};\nTWEEN.Easing.Bounce.EaseOut = function(a) {\n\treturn (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625\n\t\t\t* (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625\n\t\t\t* (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75)\n\t\t\t* a + 0.984375\n};\nTWEEN.Easing.Bounce.EaseInOut = function(a) {\n\tif (a < 0.5)\n\t\treturn TWEEN.Easing.Bounce.EaseIn(a * 2) * 0.5;\n\treturn TWEEN.Easing.Bounce.EaseOut(a * 2 - 1) * 0.5 + 0.5\n};\n","(function() {\n\t\n\tvar _Tween=TWEEN.Tween;\n\t\n\tTWEEN.Tween = function(object) {\n\t\tvar $this=this;\n\t\t$.extend(this,new _Tween(object));\n\t\tvar _onComplete=this.onComplete;\n        this.onComplete = function ( callback ) {\n            _onComplete.call($this,function() {\n            \tsetTimeout(function() {\n            \t\tcallback.call($this);\n            \t},0);\n            });\n            return this;\n        };\n\t}\n\t\n\tTWEEN.Easing.Linear.EaseNone = TWEEN.Easing.Linear.EaseNone || TWEEN.Easing.Linear.None; \n\tTWEEN.Easing.Quadratic.EaseIn = TWEEN.Easing.Quadratic.EaseIn || TWEEN.Easing.Quadratic.In;\n\tTWEEN.Easing.Quadratic.EaseOut = TWEEN.Easing.Quadratic.EaseOut || TWEEN.Easing.Quadratic.Out;\n\tTWEEN.Easing.Quadratic.EaseInOut = TWEEN.Easing.Quadratic.EaseInOut || TWEEN.Easing.Quadratic.InOut;\n\tTWEEN.Easing.Cubic.EaseIn = TWEEN.Easing.Cubic.EaseIn || TWEEN.Easing.Cubic.In; \n\tTWEEN.Easing.Cubic.EaseOut = TWEEN.Easing.Cubic.EaseOut || TWEEN.Easing.Cubic.Out;\n\tTWEEN.Easing.Cubic.EaseInOut = TWEEN.Easing.Cubic.EaseInOut || TWEEN.Easing.Cubic.InOut;\n\tTWEEN.Easing.Quartic.EaseIn = TWEEN.Easing.Quartic.EaseIn || TWEEN.Easing.Quartic.In;\n\tTWEEN.Easing.Quartic.EaseOut = TWEEN.Easing.Quartic.EaseOut || TWEEN.Easing.Quartic.Out;\n\tTWEEN.Easing.Quartic.EaseInOut = TWEEN.Easing.Quartic.EaseInOut || TWEEN.Easing.Quartic.InOut;\n\tTWEEN.Easing.Quintic.EaseIn = TWEEN.Easing.Quintic.EaseIn || TWEEN.Easing.Quintic.In;\n\tTWEEN.Easing.Quintic.EaseOut = TWEEN.Easing.Quintic.EaseOut || TWEEN.Easing.Quintic.Out; \n\tTWEEN.Easing.Quintic.EaseInOut = TWEEN.Easing.Quintic.EaseInOut || TWEEN.Easing.Quintic.InOut;\n\tTWEEN.Easing.Sinusoidal.EaseIn = TWEEN.Easing.Sinusoidal.EaseIn || TWEEN.Easing.Sinusoidal.In;\n\tTWEEN.Easing.Sinusoidal.EaseOut = TWEEN.Easing.Sinusoidal.EaseOut || TWEEN.Easing.Sinusoidal.Out;\n\tTWEEN.Easing.Sinusoidal.EaseInOut = TWEEN.Easing.Sinusoidal.EaseInOut || TWEEN.Easing.Sinusoidal.InOut;\n\tTWEEN.Easing.Exponential.EaseIn = TWEEN.Easing.Exponential.EaseIn || TWEEN.Easing.Exponential.In;\n\tTWEEN.Easing.Exponential.EaseOut = TWEEN.Easing.Exponential.EaseOut || TWEEN.Easing.Exponential.Out;\n\tTWEEN.Easing.Exponential.EaseInOut = TWEEN.Easing.Exponential.EaseInOut || TWEEN.Easing.Exponential.InOut;\n\tTWEEN.Easing.Circular.EaseIn = TWEEN.Easing.Circular.EaseIn || TWEEN.Easing.Circular.In;\n\tTWEEN.Easing.Circular.EaseOut = TWEEN.Easing.Circular.EaseOut || TWEEN.Easing.Circular.Out;\n\tTWEEN.Easing.Circular.EaseInOut = TWEEN.Easing.Circular.EaseInOut || TWEEN.Easing.Circular.InOut;\n\tTWEEN.Easing.Elastic.EaseIn = TWEEN.Easing.Elastic.EaseIn || TWEEN.Easing.Elastic.In;\n\tTWEEN.Easing.Elastic.EaseOut = TWEEN.Easing.Elastic.EaseOut || TWEEN.Easing.Elastic.Out;\n\tTWEEN.Easing.Elastic.EaseInOut = TWEEN.Easing.Elastic.EaseInOut || TWEEN.Easing.Elastic.InOut;\n\tTWEEN.Easing.Back.EaseIn = TWEEN.Easing.Back.EaseIn || TWEEN.Easing.Back.In;\n\tTWEEN.Easing.Back.EaseOut = TWEEN.Easing.Back.EaseOut || TWEEN.Easing.Back.Out;\n\tTWEEN.Easing.Back.EaseInOut = TWEEN.Easing.Back.EaseInOut || TWEEN.Easing.Back.InOut;\n\tTWEEN.Easing.Bounce.EaseIn = TWEEN.Easing.Bounce.EaseIn || TWEEN.Easing.Bounce.In;\n\tTWEEN.Easing.Bounce.EaseOut = TWEEN.Easing.Bounce.EaseOut || TWEEN.Easing.Bounce.Out;\n\tTWEEN.Easing.Bounce.EaseInOut = TWEEN.Easing.Bounce.EaseInOut || TWEEN.Easing.Bounce.InOut;\n\n})();","/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n//\n// This is a drop-in replacement for (most) TrackballControls used in examples.\n// That is, include this js file and wherever you see:\n//    \tcontrols = new THREE.TrackballControls( camera );\n//      controls.target.z = 150;\n// Simple substitute \"OrbitControls\" and the control should work as-is.\n\nTHREE.OrbitControls = function ( camera, object, domElement ) {\n\n\tthis.object = object;\n    this.camera = camera;\n    \n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the control orbits around\n\t// and where it pans with respect to.\n\tthis.camTarget = new THREE.Vector3();\n\t// center is old, deprecated; use \"camTarget\" instead\n\tthis.center = this.camTarget;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for\n\t// backwards compatibility\n\tthis.noZoom = false;\n\tthis.zoomSpeed = 1.0;\n\t// Limits to how far you can dolly in and out\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// Set to true to disable this control\n\tthis.noRotate = false;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to true to disable this control\n\tthis.noPan = false;\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// Set to true to disable use of the keys\n\tthis.noKeys = false;\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\t\n\t// Jocly specific\n\tthis.animControl = null;\n\tthis.enableDrag = true;\n\tthis.targetBounds = [3,3,3];\n\n\t////////////\n\t// internals\n\n\tvar scope = this;\n\n\tvar EPS = 0.000001;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tvar phiDelta = 0;\n\tvar thetaDelta = 0;\n\tvar scale = 1;\n\tvar pan = new THREE.Vector3();\n\n\tvar lastPosition = new THREE.Vector3();\n\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\tvar state = STATE.NONE;\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\n\n\tthis.rotateLeft = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tthetaDelta -= angle;\n\n\t};\n\n\tthis.rotateUp = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tphiDelta -= angle;\n\n\t};\n\n\t// pass in distance in world space to move left\n\tthis.panLeft = function ( distance ) {\n\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar te = this.object.matrix.elements;\n\t\t// get X column of matrix\n\t\tpanOffset.set( te[0], te[1], te[2] );\n\t\tpanOffset.multiplyScalar(-distance);\n\t\t\n\t\tpan.add( panOffset );\n\n\t};\n\n\t// pass in distance in world space to move up\n\tthis.panUp = function ( distance ) {\n\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar te = this.object.matrix.elements;\n\t\t// get Y column of matrix\n\t\tpanOffset.set( te[4], te[5], te[6] );\n\t\tpanOffset.multiplyScalar(distance);\n\t\t\n\t\tpan.add( panOffset );\n\t};\n\t\n\t// main entry point; pass in Vector2 of change desired in pixel space,\n\t// right and down are positive\n\tthis.pan = function ( delta ) {\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( scope.camera.fov !== undefined ) {\n\n\t\t\t// perspective\n\t\t\tvar position = scope.object.position;\n\t\t\tvar offset = position.clone().sub( scope.camTarget );\n\t\t\tvar targetDistance = offset.length();\n\n\t\t\t// half of the fov is center to top of screen\n\t\t\ttargetDistance *= Math.tan( (scope.camera.fov/2) * Math.PI / 180.0 );\n\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\tscope.panLeft( 2 * delta.x * targetDistance / element.clientHeight );\n\t\t\tscope.panUp( 2 * delta.y * targetDistance / element.clientHeight );\n\n\t\t} else if ( scope.object.top !== undefined ) {\n\n\t\t\t// orthographic\n\t\t\tscope.panLeft( delta.x * (scope.object.right - scope.object.left) / element.clientWidth );\n\t\t\tscope.panUp( delta.y * (scope.object.top - scope.object.bottom) / element.clientHeight );\n\n\t\t} else {\n\n\t\t\t// camera neither orthographic or perspective - warn user\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\n\t\t}\n\n\t};\n\n\tthis.dollyIn = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale /= dollyScale;\n\n\t};\n\n\tthis.dollyOut = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tscale *= dollyScale;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tvar position = this.object.position;\n\t\tvar offset = position.clone().sub( this.camTarget );\n\n\t\t// angle from z-axis around y-axis\n\n\t\tvar theta = Math.atan2( offset.x, offset.z );\n\n\t\t// angle from y-axis\n\n\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\n\t\tif ( this.autoRotate ) {\n\n\t\t\tthis.rotateLeft( getAutoRotationAngle() );\n\n\t\t}\n\n\t\ttheta += thetaDelta;\n\t\tphi += phiDelta;\n\n\t\t// restrict phi to be between desired limits\n\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\n\t\tvar radius = offset.length() * scale;\n\n\t\t// restrict radius to be between desired limits\n\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\t\t\n\t\t//console.log(\"radius\",radius,\"phi\",phi,\"theta\",theta);\n\t\t\n\t\t// move target to panned location\n\t\tthis.camTarget.add( pan );\n\n\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\toffset.y = radius * Math.cos( phi );\n\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\t\t\n\t\tif(this.camTarget.x<-this.targetBounds[0])\n\t\t\tthis.camTarget.setX(-this.targetBounds[0]);\n\t\tif(this.camTarget.x>this.targetBounds[0])\n\t\t\tthis.camTarget.setX(this.targetBounds[0]);\n\t\tif(this.camTarget.y<-this.targetBounds[1])\n\t\t\tthis.camTarget.setY(-this.targetBounds[1]);\n\t\tif(this.camTarget.y>this.targetBounds[1])\n\t\t\tthis.camTarget.setY(this.targetBounds[1]);\n\t\tif(this.camTarget.z<-this.targetBounds[2])\n\t\t\tthis.camTarget.setZ(-this.targetBounds[2]);\n\t\tif(this.camTarget.z>this.targetBounds[2])\n\t\t\tthis.camTarget.setZ(this.targetBounds[2]);\n\n\t\tposition.copy( this.camTarget ).add( offset );\n\n\t\t// apparently camera.lookAt is based on the camera relative position\n        // in our case, where the camera is attached to an object, we need\n        // to temporarily move the camera to this object for lookAt to work\n        // properly\n        var camPos = new THREE.Vector3();\n        camPos.copy(this.camera.position);\n        this.camera.position.copy(this.object.position);\n\t\tthis.camera.lookAt( this.camTarget );\n        this.camera.position.copy(camPos);\n\n\t\tthetaDelta = 0;\n\t\tphiDelta = 0;\n\t\tscale = 1;\n\t\tpan.set(0,0,0);\n\n\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 ) {\n\n\t\t\tif(typeof this.dispatchEvent==\"function\")\n\t\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\tlastPosition.copy( this.object.position );\n\t\t}\n\n\t};\n\t\n\tthis.destroy = function() {\n\t\t// things to do there ?\n\t}\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t}\n\n\tfunction onMouseDown( event ) {\n\n\t\tif(THREE.Object3D._threexDomEvent.lockObject(event,scope.enableDrag))\n\t\t\treturn;\n\n\t\tif ( scope.enabled === false ) { return; }\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( event.button === 0 ) {\n\t\t\tif ( scope.noRotate === true ) { return; }\n\n\t\t\tstate = STATE.ROTATE;\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 1 ) {\n\t\t\tif ( scope.noZoom === true ) { return; }\n\n\t\t\tstate = STATE.DOLLY;\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 2 ) {\n\t\t\tif ( scope.noPan === true ) { return; }\n\n\t\t\tstate = STATE.PAN;\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\t// Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\n\t\tscope.domElement.addEventListener( 'mousemove', onMouseMove, false );\n\t\tscope.domElement.addEventListener( 'mouseup', onMouseUp, false );\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\t\t\t\n\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tscope.dollyIn();\n\n\t\t\t} else {\n\n\t\t\t\tscope.dollyOut();\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\t\t\n\t\t\tscope.pan( panDelta );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\ttrigger();\n\n\t}\n\n\tfunction onMouseUp( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\t// Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\n\t\tscope.domElement.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tscope.domElement.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\t\t\n\t\tevent.stopPropagation();\n\t\tevent.preventDefault();\n\n\t\tif ( scope.enabled === false || scope.noZoom === true ) return;\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta;\n\n\t\t} else if ( event.detail ) { // Firefox\n\n\t\t\tdelta = - event.detail;\n\n\t\t}\n\n\t\tif ( delta > 0 ) {\n\n\t\t\tscope.dollyOut();\n\n\t\t} else {\n\n\t\t\tscope.dollyIn();\n\n\t\t}\n\t\t\n\t\ttrigger();\n\n\t}\n\n\tfunction onMouseOut( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\n\t\tthis.mouseIsDown = false;\n\t\tstate = STATE.NONE;\n\t\t\n\t}\n\t\n\tfunction onKeyDown( event ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\t\tif ( scope.noKeys === true ) { return; }\n\t\tif ( scope.noPan === true ) { return; }\n\n\t\t// pan a pixel - I guess for precise positioning?\n\t\t// Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\n\t\tvar needUpdate = false;\n\t\t\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tscope.pan( new THREE.Vector2( 0, scope.keyPanSpeed ) );\n\t\t\t\tneedUpdate = true;\n\t\t\t\tbreak;\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tscope.pan( new THREE.Vector2( 0, -scope.keyPanSpeed ) );\n\t\t\t\tneedUpdate = true;\n\t\t\t\tbreak;\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tscope.pan( new THREE.Vector2( scope.keyPanSpeed, 0 ) );\n\t\t\t\tneedUpdate = true;\n\t\t\t\tbreak;\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tscope.pan( new THREE.Vector2( -scope.keyPanSpeed, 0 ) );\n\t\t\t\tneedUpdate = true;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Greggman fix: https://github.com/greggman/three.js/commit/fde9f9917d6d8381f06bf22cdff766029d1761be\n\t\tif ( needUpdate ) {\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t}\n\t\n\tfunction touchstart( event ) {\n\n\t\tif(THREE.Object3D._threexDomEvent.lockObject(event,scope.enableDrag))\n\t\t\treturn;\n\n\t\tif ( scope.enabled === false ) { return; }\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\t\t\t\tif ( scope.noRotate === true ) { return; }\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t// two-fingered touch: dolly\n\t\t\t\tif ( scope.noZoom === true ) { return; }\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\t\t\t\tif ( scope.noPan === true ) { return; }\n\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\t\t\n\t\ttrigger();\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1: // one-fingered touch: rotate\n\t\t\t\tif ( scope.noRotate === true ) { return; }\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) { return; }\n\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\trotateStart.copy( rotateEnd );\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // two-fingered touch: dolly\n\t\t\t\tif ( scope.noZoom === true ) { return; }\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) { return; }\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\tscope.dollyOut();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.dollyIn();\n\n\t\t\t\t}\n\n\t\t\t\tdollyStart.copy( dollyEnd );\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\t\t\t\tif ( scope.noPan === true ) { return; }\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) { return; }\n\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\t\t\t\n\t\t\t\tscope.pan( panDelta );\n\n\t\t\t\tpanStart.copy( panEnd );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\ttrigger();\n\n\t}\n\n\tfunction touchend( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) { return; }\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction trigger() {\n\t\tif(scope.animControl)\n\t\t\tscope.animControl.trigger();\n\t}\n\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); event.stopPropagation(); }, false );\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\tthis.domElement.addEventListener( 'mouseout', onMouseOut, false );\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\n\n\tthis.domElement.addEventListener( 'keydown', onKeyDown, false );\n\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n};\n\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n","/**\n * @author richt / http://richt.me\n * @author WestLangley / http://github.com/WestLangley\n *\n * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)\n */\n\nTHREE.DeviceOrientationControls = function( object, changeCallback ) {\n\n\tvar scope = this;\n\n\tthis.object = object;\n\n\tthis.enabled = false;\n\n\tthis.deviceOrientation = {};\n\tthis.screenOrientation = 0;\n\n\tthis.alpha = 0;\n\tthis.alphaOffsetAngle = 0;\n\n\tthis.calibration = true;\n\n\tvar onDeviceOrientationChangeEvent = function( event ) {\n\n\t\tif(event.alpha!==null || event.beta!==null | event.gamma!==null) {\n\t\t\tscope.object.rotation.reorder( \"YXZ\" );\n\t\t\tscope.enabled = true;\n\t\t}\n\t\tscope.deviceOrientation = event;\n\t\tchangeCallback(scope);\n\n\t};\n\n\tvar onScreenOrientationChangeEvent = function() {\n\n\t\tscope.screenOrientation = window.orientation || 0;\n\t\tchangeCallback(scope);\n\n\t};\n\n\t// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\n\n\tvar setObjectQuaternion = function() {\n\n\t\tvar zee = new THREE.Vector3( 0, 0, 1 );\n\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar q0 = new THREE.Quaternion();\n\n\t\tvar q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis\n\n\t\treturn function( quaternion, alpha, beta, gamma, orient ) {\n\n\t\t\teuler.set( beta, alpha, - gamma, 'YXZ' ); // 'ZXY' for the device, but 'YXZ' for us\n\n\t\t\tquaternion.setFromEuler( euler ); // orient the device\n\n\t\t\tquaternion.multiply( q1 ); // camera looks out the back of the device, not the top\n\n\t\t\tquaternion.multiply( q0.setFromAxisAngle( zee, - orient ) ); // adjust for screen orientation\n\n\t\t}\n\n\t}();\n\n\tthis.connect = function() {\n\n\t\tonScreenOrientationChangeEvent(); // run once on load\n\n\t\twindow.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\n\t\twindow.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\n\n\t};\n\n\tthis.disconnect = function() {\n\n\t\twindow.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\n\t\twindow.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\n\n\t\tscope.enabled = false;\n\n\t};\n\n\tthis.update = function() {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tif(scope.calibration) {\n\t\t\tscope.calibration = false;\n\t\t\tthis.alphaOffsetAngle = - object.rotation.y - THREE.Math.degToRad( scope.deviceOrientation.alpha ) + Math.PI/2;\n\t\t}\n\n\t\tvar alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) + this.alphaOffsetAngle : 0; // Z\n\t\tvar beta = scope.deviceOrientation.beta ? THREE.Math.degToRad( scope.deviceOrientation.beta ) : 0; // X'\n\t\tvar gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''\n\t\tvar orient = scope.screenOrientation ? THREE.Math.degToRad( scope.screenOrientation ) : 0; // O\n\n\t\tsetObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );\n\t\tthis.alpha = alpha;\n\n\t};\n\n\tthis.updateAlphaOffsetAngle = function( angle ) {\n\n\t\tthis.alphaOffsetAngle = angle;\n\t\tthis.update();\n\n\t};\n\n\tthis.dispose = function() {\n\n\t\tthis.disconnect();\n\n\t};\n\n\tthis.connect();\n\n};\n","/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\tthis.z = 0;\n\tthis.renderOrder = 0;\n\n};\n\n//\n\nTHREE.RenderableFace = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.normalModel = new THREE.Vector3();\n\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsLength = 0;\n\n\tthis.color = new THREE.Color();\n\tthis.material = null;\n\tthis.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];\n\n\tthis.z = 0;\n\tthis.renderOrder = 0;\n\n};\n\n//\n\nTHREE.RenderableVertex = function () {\n\n\tthis.position = new THREE.Vector3();\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n\n};\n\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\n\tthis.positionWorld.copy( vertex.positionWorld );\n\tthis.positionScreen.copy( vertex.positionScreen );\n\n};\n\n//\n\nTHREE.RenderableLine = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\tthis.material = null;\n\n\tthis.z = 0;\n\tthis.renderOrder = 0;\n\n};\n\n//\n\nTHREE.RenderableSprite = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.z = 0;\n\n\tthis.rotation = 0;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n\tthis.renderOrder = 0;\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\n\t_renderData = { objects: [], lights: [], elements: [] },\n\n\t_vector3 = new THREE.Vector3(),\n\t_vector4 = new THREE.Vector4(),\n\n\t_clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t_boundingBox = new THREE.Box3(),\n\t_points3 = new Array( 3 ),\n\t_points4 = new Array( 4 ),\n\n\t_viewMatrix = new THREE.Matrix4(),\n\t_viewProjectionMatrix = new THREE.Matrix4(),\n\n\t_modelMatrix,\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\n\t_normalMatrix = new THREE.Matrix3(),\n\n\t_frustum = new THREE.Frustum(),\n\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\n\t//\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n\t//\n\n\tvar RenderList = function () {\n\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tvar object = null;\n\t\tvar material = null;\n\n\t\tvar normalMatrix = new THREE.Matrix3();\n\n\t\tfunction setObject( value ) {\n\n\t\t\tobject = value;\n\t\t\tmaterial = object.material;\n\n\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\n\n\t\t\tnormals.length = 0;\n\t\t\tuvs.length = 0;\n\n\t\t}\n\n\t\tfunction projectVertex( vertex ) {\n\n\t\t\tvar position = vertex.position;\n\t\t\tvar positionWorld = vertex.positionWorld;\n\t\t\tvar positionScreen = vertex.positionScreen;\n\n\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\n\t\t\tvar invW = 1 / positionScreen.w;\n\n\t\t\tpositionScreen.x *= invW;\n\t\t\tpositionScreen.y *= invW;\n\t\t\tpositionScreen.z *= invW;\n\n\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\n\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\n\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\n\n\t\t}\n\n\t\tfunction pushVertex( x, y, z ) {\n\n\t\t\t_vertex = getNextVertexInPool();\n\t\t\t_vertex.position.set( x, y, z );\n\n\t\t\tprojectVertex( _vertex );\n\n\t\t}\n\n\t\tfunction pushNormal( x, y, z ) {\n\n\t\t\tnormals.push( x, y, z );\n\n\t\t}\n\n\t\tfunction pushUv( x, y ) {\n\n\t\t\tuvs.push( x, y );\n\n\t\t}\n\n\t\tfunction checkTriangleVisibility( v1, v2, v3 ) {\n\n\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;\n\n\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t_points3[ 2 ] = v3.positionScreen;\n\n\t\t\treturn _clipBox.intersectsBox( _boundingBox.setFromPoints( _points3 ) );\n\n\t\t}\n\n\t\tfunction checkBackfaceCulling( v1, v2, v3 ) {\n\n\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\n\t\t}\n\n\t\tfunction pushLine( a, b ) {\n\n\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\tvar v2 = _vertexPool[ b ];\n\n\t\t\t_line = getNextLineInPool();\n\n\t\t\t_line.id = object.id;\n\t\t\t_line.v1.copy( v1 );\n\t\t\t_line.v2.copy( v2 );\n\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\n\t\t\t_line.renderOrder = object.renderOrder;\n\n\t\t\t_line.material = object.material;\n\n\t\t\t_renderData.elements.push( _line );\n\n\t\t}\n\n\t\tfunction pushTriangle( a, b, c ) {\n\n\t\t\tvar v1 = _vertexPool[ a ];\n\t\t\tvar v2 = _vertexPool[ b ];\n\t\t\tvar v3 = _vertexPool[ c ];\n\n\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;\n\n\t\t\tif ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\n\n\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t_face.id = object.id;\n\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t_face.v3.copy( v3 );\n\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\t\t\t_face.renderOrder = object.renderOrder;\n\n\t\t\t\t// use first vertex normal as face normal\n\n\t\t\t\t_face.normalModel.fromArray( normals, a * 3 );\n\t\t\t\t_face.normalModel.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\n\t\t\t\t\tnormal.fromArray( normals, arguments[ i ] * 3 );\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\tvar uv = _face.uvs[ i ];\n\t\t\t\t\tuv.fromArray( uvs, arguments[ i ] * 2 );\n\n\t\t\t\t}\n\n\t\t\t\t_face.vertexNormalsLength = 3;\n\n\t\t\t\t_face.material = object.material;\n\n\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tsetObject: setObject,\n\t\t\tprojectVertex: projectVertex,\n\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\n\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\n\t\t\tpushVertex: pushVertex,\n\t\t\tpushNormal: pushNormal,\n\t\t\tpushUv: pushUv,\n\t\t\tpushLine: pushLine,\n\t\t\tpushTriangle: pushTriangle\n\t\t}\n\n\t};\n\n\tvar renderList = new RenderList();\n\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\n\t\t_faceCount = 0;\n\t\t_lineCount = 0;\n\t\t_spriteCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\n\t\t//\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tfunction addObject( object ) {\n\n\t\t\t_object = getNextObjectInPool();\n\t\t\t_object.id = object.id;\n\t\t\t_object.object = object;\n\n\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t_vector3.applyMatrix4( _viewProjectionMatrix );\n\t\t\t_object.z = _vector3.z;\n\t\t\t_object.renderOrder = object.renderOrder;\n\n\t\t\t_renderData.objects.push( _object );\n\n\t\t}\n\n\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\t_renderData.lights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\n\n\t\t\t\tif ( object.material.visible === false ) return;\n\t\t\t\tif ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) return;\n\n\t\t\t\taddObject( object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.material.visible === false ) return;\n\t\t\t\tif ( object.frustumCulled === true && _frustum.intersectsSprite( object ) === false ) return;\n\n\t\t\t\taddObject( object );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( sortObjects === true ) {\n\n\t\t\t_renderData.objects.sort( painterSort );\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\n\t\t\tvar object = _renderData.objects[ o ].object;\n\t\t\tvar geometry = object.geometry;\n\n\t\t\trenderList.setObject( object );\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\tif ( attributes.position === undefined ) continue;\n\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.normal !== undefined ) {\n\n\t\t\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tvar uvs = attributes.uv.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\t\tvar indices = geometry.index.array;\n\n\t\t\t\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\t\t\t\tfor ( var g = 0; g < groups.length; g ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ g ];\n\n\t\t\t\t\t\t\t\tfor ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\n\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\n\n\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ v ];\n\n\t\t\t\t\t\t_vector3.copy( vertex );\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\n\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\n\n\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\n\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\n\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\n\t\t\t\t\t\tmaterial = isFaceMaterial === true\n\t\t\t\t\t\t\t ? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t\t : object.material;\n\n\t\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\t\tvar side = material.side;\n\n\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\n\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\n\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\n\n\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;\n\n\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\n\n\t\t\t\t\t\tif ( side !== THREE.DoubleSide ) {\n\n\t\t\t\t\t\t\tif ( side === THREE.FrontSide && visible === false ) continue;\n\t\t\t\t\t\t\tif ( side === THREE.BackSide && visible === true ) continue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t_face.v3.copy( v3 );\n\n\t\t\t\t\t\t_face.normalModel.copy( face.normal );\n\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\t_face.normalModel.negate();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\n\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\t\tnormalModel.negate();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\n\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\n\n\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\n\t\t\t\t\t\t_face.renderOrder = object.renderOrder;\n\n\t\t\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\n\t\t\t\t\tif ( attributes.position !== undefined ) {\n\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\t\t\tvar indices = geometry.index.array;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar step = object instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\n\t\t\t\t\tvar vertices = object.geometry.vertices;\n\n\t\t\t\t\tif ( vertices.length === 0 ) continue;\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\tvar step = object instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\n\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\n\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\n\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\n\t\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\n\t\t\t\t\t\t\t_line = getNextLineInPool();\n\n\t\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\n\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\t\t\t\t\t\t\t_line.renderOrder = object.renderOrder;\n\n\t\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\n\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_renderData.elements.push( _line );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\n\t\t\t\tvar invW = 1 / _vector4.w;\n\n\t\t\t\t_vector4.z *= invW;\n\n\t\t\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\n\n\t\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t\t_sprite.id = object.id;\n\t\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t\t_sprite.renderOrder = object.renderOrder;\n\t\t\t\t\t_sprite.object = object;\n\n\t\t\t\t\t_sprite.rotation = object.rotation;\n\n\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\n\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\n\n\t\t\t\t\t_sprite.material = object.material;\n\n\t\t\t\t\t_renderData.elements.push( _sprite );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sortElements === true ) {\n\n\t\t\t_renderData.elements.sort( painterSort );\n\n\t\t}\n\n\t\treturn _renderData;\n\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif ( _objectCount === _objectPoolLength ) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push( object );\n\t\t\t_objectPoolLength ++;\n\t\t\t_objectCount ++;\n\t\t\treturn object;\n\n\t\t}\n\n\t\treturn _objectPool[ _objectCount ++ ];\n\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif ( _vertexCount === _vertexPoolLength ) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push( vertex );\n\t\t\t_vertexPoolLength ++;\n\t\t\t_vertexCount ++;\n\t\t\treturn vertex;\n\n\t\t}\n\n\t\treturn _vertexPool[ _vertexCount ++ ];\n\n\t}\n\n\tfunction getNextFaceInPool() {\n\n\t\tif ( _faceCount === _facePoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace();\n\t\t\t_facePool.push( face );\n\t\t\t_facePoolLength ++;\n\t\t\t_faceCount ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _facePool[ _faceCount ++ ];\n\n\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif ( _lineCount === _linePoolLength ) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push( line );\n\t\t\t_linePoolLength ++;\n\t\t\t_lineCount ++;\n\t\t\treturn line;\n\n\t\t}\n\n\t\treturn _linePool[ _lineCount ++ ];\n\n\t}\n\n\tfunction getNextSpriteInPool() {\n\n\t\tif ( _spriteCount === _spritePoolLength ) {\n\n\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t_spritePool.push( sprite );\n\t\t\t_spritePoolLength ++;\n\t\t\t_spriteCount ++;\n\t\t\treturn sprite;\n\n\t\t}\n\n\t\treturn _spritePool[ _spriteCount ++ ];\n\n\t}\n\n\t//\n\n\tfunction painterSort( a, b ) {\n\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else if ( a.id !== b.id ) {\n\n\t\t\treturn a.id - b.id;\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction clipLine( s1, s2 ) {\n\n\t\tvar alpha1 = 0, alpha2 = 1,\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near =  s1.z + s1.w,\n\t\tbc2near =  s2.z + s2.w,\n\t\tbc1far =  - s1.z + s1.w,\n\t\tbc2far =  - s2.z + s2.w;\n\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\n\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif ( bc1near < 0 ) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t} else if ( bc2near < 0 ) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t}\n\n\t\t\tif ( bc1far < 0 ) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t} else if ( bc2far < 0 ) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t}\n\n\t\t\tif ( alpha2 < alpha1 ) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n","// This THREEx helper makes it easy to handle the mouse events in your 3D scene\n//\n// * CHANGES NEEDED\n//   * handle drag/drop\n//   * notify events not object3D - like DOM\n//     * so single object with property\n//   * DONE bubling implement bubling/capturing\n//   * DONE implement event.stopPropagation()\n//   * DONE implement event.type = \"click\" and co\n//   * DONE implement event.target\n//\n// # Lets get started\n//\n// First you include it in your page\n//\n// ```<script src='threex.domevent.js'></script>```\n//\n// # use the object oriented api\n//\n// You bind an event like this\n// \n// ```mesh.on('click', function(object3d){ ... })```\n//\n// To unbind an event, just do\n//\n// ```mesh.off('click', function(object3d){ ... })```\n//\n// As an alternative, there is another naming closer DOM events.\n// Pick the one you like, they are doing the same thing\n//\n// ```mesh.addEventListener('click', function(object3d){ ... })```\n// ```mesh.removeEventListener('click', function(object3d){ ... })```\n//\n// # Supported Events\n//\n// Always in a effort to stay close to usual pratices, the events name are the same as in DOM.\n// The semantic is the same too.\n// Currently, the available events are\n// [click, dblclick, mouseup, mousedown](http://www.quirksmode.org/dom/events/click.html),\n// [mouseover and mouse out](http://www.quirksmode.org/dom/events/mouseover.html).\n//\n// # use the standalone api\n//\n// The object-oriented api modifies THREE.Object3D class.\n// It is a global class, so it may be legitimatly considered unclean by some people.\n// If this bother you, simply do ```THREEx.DomEvent.noConflict()``` and use the\n// standalone API. In fact, the object oriented API is just a thin wrapper\n// on top of the standalone API.\n//\n// First, you instanciate the object\n//\n// ```var domEvent = new THREEx.DomEvent();```\n// \n// Then you bind an event like this\n//\n// ```domEvent.bind(mesh, 'click', function(object3d){ object3d.scale.x *= 2; });```\n//\n// To unbind an event, just do\n//\n// ```domEvent.unbind(mesh, 'click', callback);```\n//\n// \n// # Code\n\n//\n\n/** @namespace */\nvar THREEx\t\t= THREEx \t\t|| {};\n\n// # Constructor\nTHREEx.DomEvent\t= function(camera)\n{\n\tthis._camera\t= camera || null;\n\tthis._domElement= null;\n\tthis._projector\t= new THREE.Projector();\n\tthis._selected\t= null;\n\tthis._boundObjs\t= {};\n\tthis.setBoundContext('_');\n\tthis.mouseIsDown = false;\n\tthis.mouseDragNotified = false;\n\tthis.lastDownTime = 0;\n\n\t// Bind dom event for mouse and touch\n\tvar _this\t= this;\n\t//this._$onClick\t\t= function(){ _this._onClick.apply(_this, arguments);\t\t};\n\t//this._$onDblClick\t= function(){ _this._onDblClick.apply(_this, arguments);\t};\n\tthis._$onMouseMove\t= function(){ _this._onMouseMove.apply(_this, arguments);\t};\n\tthis._$onMouseDown\t= function(){ _this._onMouseDown.apply(_this, arguments);\t};\n\tthis._$onMouseUp\t= function(){ _this._onMouseUp.apply(_this, arguments);\t\t};\n\tthis._$onTouchMove\t= function(){ _this._onTouchMove.apply(_this, arguments);\t};\n\tthis._$onTouchStart\t= function(){ _this._onTouchStart.apply(_this, arguments);\t};\n\tthis._$onTouchEnd\t= function(){ _this._onTouchEnd.apply(_this, arguments);\t};\n}\n\nTHREEx.DomEvent.prototype.setDOMElement = function(domElement) {\n\tif(this._domElement)\n\t\tthis.unsetDOMElement();\n\tthis._domElement=domElement;\n\t//this._domElement.addEventListener( 'click'\t, this._$onClick\t, false );\n\t//this._domElement.addEventListener( 'dblclick'\t, this._$onDblClick\t, false );\n\tthis._domElement.addEventListener( 'mousemove'\t, this._$onMouseMove\t, false );\n\tthis._domElement.addEventListener( 'mousedown'\t, this._$onMouseDown\t, false );\n\tthis._domElement.addEventListener( 'mouseup'\t, this._$onMouseUp\t, false );\n\tthis._domElement.addEventListener( 'touchmove'\t, this._$onTouchMove\t, false );\n\tthis._domElement.addEventListener( 'touchstart'\t, this._$onTouchStart\t, false );\n\tthis._domElement.addEventListener( 'touchend'\t, this._$onTouchEnd\t, false );\n}\n\nTHREEx.DomEvent.prototype.unsetDOMElement = function() {\n\tif(this._domElement) {\n\t\t//this._domElement.removeEventListener( 'click'\t\t, this._$onClick\t, false );\n\t\t//this._domElement.removeEventListener( 'dblclick'\t, this._$onDblClick\t, false );\n\t\tthis._domElement.removeEventListener( 'mousemove'\t, this._$onMouseMove\t, false );\n\t\tthis._domElement.removeEventListener( 'mousedown'\t, this._$onMouseDown\t, false );\n\t\tthis._domElement.removeEventListener( 'mouseup'\t\t, this._$onMouseUp\t, false );\n\t\tthis._domElement.removeEventListener( 'touchmove'\t, this._$onTouchMove\t, false );\n\t\tthis._domElement.removeEventListener( 'touchstart'\t, this._$onTouchStart\t, false );\n\t\tthis._domElement.removeEventListener( 'touchend'\t, this._$onTouchEnd\t, false );\n\t\tthis._domElement=null;\n\t}\n}\n\nTHREEx.DomEvent.prototype.setBoundContext = function(boundContext) {\n\tthis._boundContext=boundContext;\n\tif(this._boundObjs[boundContext]===undefined)\n\t\tthis._boundObjs[boundContext]=[];\n}\n\nTHREEx.DomEvent.prototype.unsetBoundContext = function(boundContext) {\n\tif(this._boundObjs[boundContext]!==undefined) {\n\t\tvar boundObjs=this._boundObjs[boundContext];\n\t\tfor(var i=0;i<boundObjs.length;i++) {\n\t\t\tvar object3d=boundObjs[i];\n\t\t\tif(object3d._3xDomEvent) {\n\t\t\t\tfor(var f in object3d._3xDomEvent) {\n\t\t\t\t\tvar m=/^(.*)Handlers$/.exec(f);\n\t\t\t\t\tif(m) {\n\t\t\t\t\t\tvar event=m[1];\n\t\t\t\t\t\tvar handlers=object3d._3xDomEvent[f];\n\t\t\t\t\t\tfor(var j=0;j<handlers.length;j++) {\n\t\t\t\t\t\t\tvar handler=handlers[j];\n\t\t\t\t\t\t\tthis.unbind(object3d,event,handler.callback,handler.useCapture);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// # Destructor\nTHREEx.DomEvent.prototype.destroy\t= function()\n{\n\tfor(var bc in this._boundObjs)\n\t\tthis.unsetBoundContext(bc);\n\t\n\t// unBind dom event for mouse and touch\n\tthis.unsetDOMElement();\n}\n\nTHREEx.DomEvent.eventNames\t= [\n\t//\"click\",\n\t//\"dblclick\",\n\t//\"holdclick\",\n\t//\"mouseover\",\n\t//\"mouseout\",\n\t\"mousedown\",\n\t\"mouseup\",\n\t\"mousemove\",\n\t\"touchmove\",\n\t\"touchstart\",\n\t\"touchend\",\n];\n\n/********************************************************************************/\n/*\t\tdomevent context\t\t\t\t\t\t*/\n/********************************************************************************/\n\n// handle domevent context in object3d instance\n\nTHREEx.DomEvent.prototype._objectCtxInit\t= function(object3d){\n\tobject3d._3xDomEvent = {};\n}\nTHREEx.DomEvent.prototype._objectCtxDeinit\t= function(object3d){\n\tdelete object3d._3xDomEvent;\n}\nTHREEx.DomEvent.prototype._objectCtxIsInit\t= function(object3d){\n\treturn object3d._3xDomEvent ? true : false;\n}\nTHREEx.DomEvent.prototype._objectCtxGet\t= function(object3d){\n\treturn object3d._3xDomEvent;\n}\n\n/********************************************************************************/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/********************************************************************************/\n\n/**\n * Getter/Setter for camera\n*/\nTHREEx.DomEvent.prototype.camera\t= function(value)\n{\n\tif( value )\tthis._camera\t= value;\n\treturn this._camera;\n}\n\nTHREEx.DomEvent.prototype.bind\t= function(object3d, eventName, callback, useCapture)\n{\n\tvar $this=this;\n\tconsole.assert( THREEx.DomEvent.eventNames.indexOf(eventName) !== -1, \"not available events:\"+eventName );\n\n\tif( !this._objectCtxIsInit(object3d) )\tthis._objectCtxInit(object3d);\n\tvar objectCtx\t= this._objectCtxGet(object3d);\t\n\tif( !objectCtx[eventName+'Handlers'] )\tobjectCtx[eventName+'Handlers']\t= [];\n\n\tobjectCtx[eventName+'Handlers'].push({\n\t\tcallback\t: callback,\n\t\tuseCapture\t: useCapture\n\t});\n\t\n\tfunction AddToBoundObjs(object3d) {\n\t\t$this._boundObjs[$this._boundContext].push(object3d);\n\t\tfor(var i=0;i<object3d.children.length;i++)\n\t\t\tAddToBoundObjs(object3d.children[i]);\n\t}\n\t\n\t// add this object in this._boundObjs\n\tAddToBoundObjs(object3d);\n\t//console.log(\"boundObjs\",this._boundObjs)\n}\n\nTHREEx.DomEvent.prototype.unbind\t= function(object3d, eventName, callback)\n{\n\tvar $this=this;\n\tconsole.assert( THREEx.DomEvent.eventNames.indexOf(eventName) !== -1, \"not available events:\"+eventName );\n\n\tif( !this._objectCtxIsInit(object3d) )\tthis._objectCtxInit(object3d);\n\n\tvar objectCtx\t= this._objectCtxGet(object3d);\n\tif( !objectCtx[eventName+'Handlers'] )\tobjectCtx[eventName+'Handlers']\t= [];\n\n\tfunction RemoveFromBoundObjs(object3d) {\n\t\tvar index = $this._boundObjs[$this._boundContext].indexOf(object3d);\n\t\tif(index>=0)\n\t\t\t$this._boundObjs[$this._boundContext].splice(index, 1);\n\t\tfor(var i=0;i<object3d.children.length;i++)\n\t\t\tRemoveFromBoundObjs(object3d.children[i]);\n\t}\n\t\n\tvar handlers\t= objectCtx[eventName+'Handlers'];\n\tfor(var i = 0; i < handlers.length; i++){\n\t\tvar handler\t= handlers[i];\n\t\tif( callback && callback != handler.callback )\tcontinue;\n\t\t//if( useCapture != handler.useCapture )\tcontinue;\n\t\thandlers.splice(i, 1)\n\t\t// from this object from this._boundObjs\n\t\tRemoveFromBoundObjs(object3d);\n\t\tbreak;\n\t}\n}\n\nTHREEx.DomEvent.prototype._bound\t= function(eventName, object3d)\n{\n\tvar objectCtx\t= this._objectCtxGet(this.getRootObject(object3d));\n\tif( !objectCtx )\treturn false;\n\treturn objectCtx[eventName+'Handlers'] ? true : false;\n}\n\nTHREEx.DomEvent.prototype.getRootObject = function(object3d) {\n\tvar object3d0=object3d;\n\twhile(object3d && !object3d._3xDomEvent)\n\t\tobject3d=object3d.parent;\n\tif(!object3d)\n\t\tconsole.error(\"Could not find root object for\",object3d0);\n\treturn object3d;\n}\n\nTHREEx.DomEvent.prototype.isTHREExTarget = function(clientX, clientY) {\n\tvar domElement=$(this._domElement);\n\tvar offset=domElement.offset();\n\tvar mouseX\t= +((clientX-offset.left) / domElement.width() ) * 2 - 1;\n\tvar mouseY\t= -((clientY-offset.top) / domElement.height()) * 2 + 1;\n\n\tvar vector\t= new THREE.Vector3( mouseX, mouseY, 1 );\n\tvector.unproject( this._camera );\n    var worldPos = this._camera.getWorldPosition();\n\tvector.sub( worldPos ).normalize()\n\tvar ray\t\t= new THREE.Raycaster( worldPos, vector );\n\tvar intersects\t= ray.intersectObjects( this._boundObjs[this._boundContext] );\n\treturn intersects.length !== 0;\n}\n\nTHREEx.DomEvent.prototype.lockObject = function(event,enableDrag) {\n\tif(/^mouse/.test(event.type) && event.button!=0)\n\t\treturn false;\n\tvar domElement=$(this._domElement);\n\tvar offset=domElement.offset();\n\tvar x, y;\n\tif(event.clientX!==undefined && event.clientY!==undefined) {\n\t\tx = event.clientX;\n\t\ty = event.clientY;\n\t} else if(event.touches && event.touches.length>0) {\n\t\tx = event.touches[0].pageX;\n\t\ty = event.touches[0].pageY;\n\t} else if(event.changedTouches && event.changedTouches.length>0) {\n\t\tx = event.changedTouches[0].pageX;\n\t\ty = event.changedTouches[0].pageY;\n\t} else {\n\t\tconsole.warn(\"Unable to get event position\");\n\t\treturn false;\n\t}\n\t\t\n\tvar mouseX\t= +((x-offset.left) / domElement.width() ) * 2 - 1;\n\tvar mouseY\t= -((y-offset.top) / domElement.height()) * 2 + 1;\n\t\n\tvar vector\t= new THREE.Vector3( mouseX, mouseY, 1 );\n\tvector.unproject( this._camera );\n    var worldPos = this._camera.getWorldPosition();\n    //vector.sub( this._camera.position ).normalize()\n    vector.sub( worldPos ).normalize()\n\tvar ray\t\t= new THREE.Raycaster( worldPos, vector );\n\tvar intersects\t= ray.intersectObjects( this._boundObjs[this._boundContext] );\n\tthis.objectLocked = intersects.length !== 0;\n\tthis.enableDrag = this.objectLocked && enableDrag;\n\treturn this.objectLocked;\n}\n\n/********************************************************************************/\n/*\t\tonEvent\t\t\t\t\t\t\t\t*/\n/********************************************************************************/\n\n// # handle click kind of events\n\nTHREEx.DomEvent.prototype._onEvent\t= function(eventName, mouseX, mouseY, origDomEvent, eventX, eventY)\n{\n\t//console.log(\"_onEvent\",eventName,mouseX,mouseY);\n\n\tif(eventName==\"mouseup\") {\n\t\tthis.mouseIsDown = false;\t\t\n\t\tif(!this.objectLocked)\n\t\t\treturn null;\n\t} else if(eventName==\"mousedown\") {\n\t\tthis.mouseIsDown = true;\n\t\tthis.mouseDownPos = [eventX, eventY];\n\t\tthis.mouseDragNotified = false;\n\t\tthis.lastDownTime = Date.now();\n\t} else if(eventName==\"mousemove\") {\n\t\tif(this.mouseIsDown) {\n\t\t\tvar dx = this.mouseDownPos[0] - eventX;\n\t\t\tvar dy = this.mouseDownPos[1] - eventY;\n\t\t\tvar distSq = dx * dx + dy * dy;\n\t\t\tif(this.enableDrag) {\n\t\t\t\tif(distSq < 100)\n\t\t\t\t\treturn null;\n\t\t\t\tif(!this.mouseDragNotified) {\n\t\t\t\t\tif(Date.now()-this.lastDownTime<50)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tthis.mouseDragNotified = true;\n\t\t\t\t\treturn this._onEvent(\"mouseup\", this.mouseEventPos[0], this.mouseEventPos[1], origDomEvent, eventX, eventY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(distSq > 100) {\n\t\t\t\t\tthis.objectLocked = false;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar vector\t= new THREE.Vector3( mouseX, mouseY, 1 );\n\tvector.unproject( this._camera );\n    var worldPos = this._camera.getWorldPosition();\n\tvector.sub( worldPos ).normalize()\n\tvar ray\t\t= new THREE.Raycaster( worldPos, vector );\n\tvar intersects\t= ray.intersectObjects( this._boundObjs[this._boundContext] );\n\t\n\t//console.log(\"camera\",this._camera.position,\"ray\",ray,\"bound\",this._boundObjs)\n\n\t// if there are no intersections, return now\n\tif( intersects.length === 0 )\t{\n\t\t//console.warn(\"THREEx\",eventName,\"No hit\");\n\t\treturn null;\n\t}\n\t\n\t// init some vairables\n\tvar intersect\t= intersects[0];\n\tvar object3d\t= this.getRootObject(intersect.object);\n\tvar objectCtx\t= this._objectCtxGet(object3d);\n\tif( !objectCtx )\treturn null;\n\n\t// notify handlers\n\tthis._notify(eventName, object3d, origDomEvent, intersect.point);\n}\n\nTHREEx.DomEvent.prototype._notify\t= function(eventName, object3d, origDomEvent, point)\n{\n\t//console.log(\"notify\",eventName,\"to\",object3d.id)\n\tvar objectCtx\t= this._objectCtxGet(object3d);\n\tvar handlers\t= objectCtx ? objectCtx[eventName+'Handlers'] : null;\n\n\t// do bubbling\n\tif( !objectCtx || !handlers || handlers.length === 0 ) {\n\t\tif(object3d.parent)\n\t\t\tthis._notify(eventName, object3d.parent);\n\t\treturn;\n\t}\n\t\n\t// notify all handlers\n\tvar handlers\t= objectCtx[eventName+'Handlers'];\n\tfor(var i = 0; i < handlers.length; i++){\n\t\tvar handler\t= handlers[i];\n\t\tvar toPropagate\t= true;\n\t\thandler.callback({\n\t\t\ttype\t\t: eventName,\n\t\t\ttarget\t\t: object3d,\n\t\t\torigDomEvent\t: origDomEvent,\n\t\t\tstopPropagation\t: function(){\n\t\t\t\ttoPropagate\t= false;\n\t\t\t},\n\t\t\tpoint: point\n\t\t});\n\t\tif( !toPropagate )\tcontinue;\n\t\t// do bubbling\n\t\tif( handler.useCapture === false ){\n\t\t\tobject3d.parent && this._notify(eventName, object3d.parent, origDomEvent, point);\n\t\t}\n\t}\n}\n\n/********************************************************************************/\n/*\t\thandle mouse events\t\t\t\t\t\t*/\n/********************************************************************************/\n// # handle mouse events\n\n//THREEx.DomEvent.longClickTimer=null;\n\nTHREEx.DomEvent.prototype._onMouseDown\t= function(event) {\n\t//console.log(\"_onMouseDown\",event.type)\n\tvar $this=this;\n\t\n\tif(event.button!==0)\n\t\treturn;\n\t/*\n\tif(THREEx.DomEvent.longClickTimer)\n\t\tclearTimeout(THREEx.DomEvent.longClickTimer);\n\tTHREEx.DomEvent.longClickTimer=setTimeout(function() {\n\t\tTHREEx.DomEvent.longClickTimer=null;\n\t\t$this._onMouseEvent('holdclick', event);\n\t},500);\n\t*/\n\treturn this._onMouseEvent('mousedown', event);\t\n}\nTHREEx.DomEvent.prototype._onMouseUp\t= function(event) {\n\n\tif(event.button!==0)\n\t\treturn;\n\n\t//console.log(\"_onMouseUp\",event.type)\n\t/*\n\tif(THREEx.DomEvent.longClickTimer) {\n\t\tclearTimeout(THREEx.DomEvent.longClickTimer);\n\t\tTHREEx.DomEvent.longClickTimer=null;\n\t}\n\t*/\n\treturn this._onMouseEvent('mouseup'\t, event);\t\n}\n\nTHREEx.DomEvent.prototype._onMouseMove\t= function(event)\n{\n\t//console.log(\"_onMouseMove\",event.type)\n\tif(!this.mouseIsDown)\n\t\treturn null;\n\t/*\n\tif(THREEx.DomEvent.longClickTimer) {\n\t\tclearTimeout(THREEx.DomEvent.longClickTimer);\n\t\tTHREEx.DomEvent.longClickTimer = null;\n\t}\n\t*/\n\treturn this._onMouseEvent('mousemove', event);\t\n}\n\nTHREEx.DomEvent.prototype._onMouseEvent\t= function(eventName, domEvent)\n{\n\tvar domElement=$(this._domElement);\n\tvar offset=domElement.offset();\n\tvar mouseX\t= +((domEvent.clientX-offset.left) / domElement.width() ) * 2 - 1;\n\tvar mouseY\t= -((domEvent.clientY-offset.top) / domElement.height()) * 2 + 1;\n\tthis.mouseEventPos = [ mouseX, mouseY ];\n\treturn this._onEvent(eventName, mouseX, mouseY, domEvent, domEvent.clientX-offset.left, domEvent.clientY-offset.top);\n}\n\n/*\nTHREEx.DomEvent.prototype._onClick\t\t= function(event)\n{\n\t// TODO handle touch ?\n\treturn this._onMouseEvent('click'\t, event);\n}\nTHREEx.DomEvent.prototype._onDblClick\t\t= function(event)\n{\n\t// TODO handle touch ?\n\treturn this._onMouseEvent('dblclick'\t, event);\n}\n*/\n\n/********************************************************************************/\n/*\t\thandle touch events\t\t\t\t\t\t*/\n/********************************************************************************/\n// # handle touch events\n\n\nTHREEx.DomEvent.prototype._onTouchStart\t= function(event){ return this._onTouchEvent('mousedown', event);\t}\nTHREEx.DomEvent.prototype._onTouchEnd\t= function(event){ return this._onTouchEvent('mouseup'\t, event);\t}\nTHREEx.DomEvent.prototype._onTouchMove\t= function(event){ \t\n\tif(!this.mouseIsDown) \n\t\treturn null; \n\telse \n\t\treturn this._onTouchEvent('mousemove', event);\t\n}\n\n/*\nTHREEx.DomEvent.prototype._onTouchMove\t= function(domEvent)\n{\n\tif( domEvent.touches.length != 1 )\treturn undefined;\n\n\tdomEvent.preventDefault();\n\n\tvar mouseX\t= +(domEvent.touches[ 0 ].pageX / window.innerWidth ) * 2 - 1;\n\tvar mouseY\t= -(domEvent.touches[ 0 ].pageY / window.innerHeight) * 2 + 1;\n\treturn this._onMove('mousemove', mouseX, mouseY, domEvent);\n}\n*/\n\nTHREEx.DomEvent.prototype._onTouchEvent\t= function(eventName, domEvent)\n{\n\tvar domElement=$(this._domElement);\n\tvar offset=domElement.offset();\n\tvar mouseX=0, mouseY=0, eventX=0, eventY=0;\n\tif(domEvent.touches && domEvent.touches.length>0) {\n\t\tmouseX\t= +((domEvent.touches[0].clientX-offset.left) / domElement.width() ) * 2 - 1;\n\t\tmouseY\t= -((domEvent.touches[0].clientY-offset.top) / domElement.height()) * 2 + 1;\n\t\teventX = domEvent.touches[0].clientX-offset.left;\n\t\teventY = domEvent.touches[0].clientY-offset.top;\n\t} else if(domEvent.changedTouches && domEvent.changedTouches.length>0) {\n\t\tmouseX\t= +((domEvent.changedTouches[0].clientX-offset.left) / domElement.width() ) * 2 - 1;\n\t\tmouseY\t= -((domEvent.changedTouches[0].clientY-offset.top) / domElement.height()) * 2 + 1;\n\t\teventX = domEvent.changedTouches[0].clientX-offset.left;\n\t\teventY = domEvent.changedTouches[0].clientY-offset.top;\n\t}\n\tthis.mouseEventPos = [ mouseX, mouseY ];\n\treturn this._onEvent(eventName, mouseX, mouseY, domEvent, eventX, eventY);\n}\n\n","/********************************************************************************/\n// # Patch THREE.Object3D\n/********************************************************************************/\n\n// handle noConflit.\nTHREEx.DomEvent.noConflict\t= function(){\n\tTHREEx.DomEvent.noConflict.symbols.forEach(function(symbol){\n\t\tTHREE.Object3D.prototype[symbol]\t= THREEx.DomEvent.noConflict.previous[symbol]\n\t})\n}\n// Backup previous values to restore them later if needed.\nTHREEx.DomEvent.noConflict.symbols\t= ['on', 'off', 'addEventListener', 'removeEventListener'];\nTHREEx.DomEvent.noConflict.previous\t= {};\nTHREEx.DomEvent.noConflict.symbols.forEach(function(symbol){\n\tTHREEx.DomEvent.noConflict.previous[symbol]\t= THREE.Object3D.prototype[symbol]\n})\n\n// begin the actual patching of THREE.Object3D\n\n// create the global instance of THREEx.DomEvent\n//THREE.Object3D._threexDomEvent\t= new THREEx.DomEvent();\n\n// # wrap mouseevents.bind()\nTHREE.Object3D.prototype._addEventListener = THREE.Object3D.prototype.addEventListener;\nTHREE.Object3D.prototype.on\t=\nTHREE.Object3D.prototype.addEventListener = function(eventName, callback){\n\tTHREE.Object3D._threexDomEvent.bind(this, eventName, callback);\n\treturn this;\n}\n\n// # wrap mouseevents.unbind()\nTHREE.Object3D.prototype._removeEventListener = THREE.Object3D.prototype.removeEventListener;\nTHREE.Object3D.prototype.off\t=\nTHREE.Object3D.prototype.removeEventListener\t= function(eventName, callback){\n\tTHREE.Object3D._threexDomEvent.unbind(this, eventName, callback);\n\treturn this;\n}\n","/**\n * @author alteredq / http://alteredqualia.com/\n * @authod mrdoob / http://mrdoob.com/\n * @authod arodic / http://aleksandarrodic.com/\n * @authod fonserbc / http://fonserbc.github.io/\n*/\n\nTHREE.StereoEffect = function ( renderer ) {\n\n\tvar _stereo = new THREE.StereoCamera();\n\t_stereo.aspect = 0.5;\n\n\tthis.setEyeSeparation = function ( eyeSep ) {\n\n\t\t_stereo.eyeSep = eyeSep;\n\n\t};\n\n\tthis.setSize = function ( width, height ) {\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t_stereo.update( camera );\n\n\t\tvar size = renderer.getSize();\n\n\t\tif ( renderer.autoClear ) renderer.clear();\n\t\trenderer.setScissorTest( true );\n\n\t\trenderer.setScissor( 0, 0, size.width / 2, size.height );\n\t\trenderer.setViewport( 0, 0, size.width / 2, size.height );\n\t\trenderer.render( scene, _stereo.cameraL );\n\n\t\trenderer.setScissor( size.width / 2, 0, size.width / 2, size.height );\n\t\trenderer.setViewport( size.width / 2, 0, size.width / 2, size.height );\n\t\trenderer.render( scene, _stereo.cameraR );\n\n\t\trenderer.setScissorTest( false );\n\n\t};\n\n};\n","/**\n * @author mrdoob / http://mrdoob.com/\n * @author marklundin / http://mark-lundin.com/\n * @author alteredq / http://alteredqualia.com/\n * @author tschw\n */\n\nTHREE.AnaglyphEffect = function ( renderer, width, height ) {\n\n\t// Matrices generated with angler.js https://github.com/tschw/angler.js/\n\t// (in column-major element order, as accepted by WebGL)\n\n\tthis.colorMatrixLeft = new THREE.Matrix3().fromArray( [\n\n\t\t\t1.0671679973602295, \t-0.0016435992438346148,\t\t 0.0001777536963345483, // r out\n\t\t\t-0.028107794001698494,\t-0.00019593400065787137,\t-0.0002875397040043026, // g out\n\t\t\t-0.04279090091586113,\t 0.000015809757314855233,\t-0.00024287120322696865 // b out\n\n\t] );\n\n\t//\t\tred\t\t\t\t\t\tgreen \t\t\t\t\t\tblue  \t\t\t\t\t\tin\n\n\tthis.colorMatrixRight = new THREE.Matrix3().fromArray( [\n\n\t\t\t-0.0355340838432312,\t-0.06440307199954987,\t\t 0.018319187685847282,\t// r out\n\t\t\t-0.10269022732973099,\t 0.8079727292060852,\t\t-0.04835830628871918,\t// g out\n\t\t\t0.0001224992738571018,\t-0.009558862075209618,\t\t 0.567823588848114\t\t// b out\n\n\t] );\n\n\tvar _camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n\tvar _scene = new THREE.Scene();\n\n\tvar _stereo = new THREE.StereoCamera();\n\n\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\tif ( width === undefined ) width = 512;\n\tif ( height === undefined ) height = 512;\n\n\tvar _renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\n\tvar _renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\n\n\tvar _material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: {\n\n\t\t\t\"mapLeft\": { value: _renderTargetL.texture },\n\t\t\t\"mapRight\": { value: _renderTargetR.texture },\n\n\t\t\t\"colorMatrixLeft\": { value: this.colorMatrixLeft },\n\t\t\t\"colorMatrixRight\": { value: this.colorMatrixRight }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = vec2( uv.x, uv.y );\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D mapLeft;\",\n\t\t\t\"uniform sampler2D mapRight;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform mat3 colorMatrixLeft;\",\n\t\t\t\"uniform mat3 colorMatrixRight;\",\n\n\t\t\t// These functions implement sRGB linearization and gamma correction\n\n\t\t\t\"float lin( float c ) {\",\n\t\t\t\"\treturn c <= 0.04045 ? c * 0.0773993808 :\",\n\t\t\t\"\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );\",\n\t\t\t\"}\",\n\n\t\t\t\"vec4 lin( vec4 c ) {\",\n\t\t\t\"\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );\",\n\t\t\t\"}\",\n\n\t\t\t\"float dev( float c ) {\",\n\t\t\t\"\treturn c <= 0.0031308 ? c * 12.92\",\n\t\t\t\"\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;\",\n\t\t\t\"}\",\n\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 uv = vUv;\",\n\n\t\t\t\"\tvec4 colorL = lin( texture2D( mapLeft, uv ) );\",\n\t\t\t\"\tvec4 colorR = lin( texture2D( mapRight, uv ) );\",\n\n\t\t\t\"\tvec3 color = clamp(\",\n\t\t\t\"\t\t\tcolorMatrixLeft * colorL.rgb +\",\n\t\t\t\"\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );\",\n\n\t\t\t\"\tgl_FragColor = vec4(\",\n\t\t\t\"\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),\",\n\t\t\t\"\t\t\tmax( colorL.a, colorR.a ) );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t} );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), _material );\n\t_scene.add( mesh );\n\n\tthis.setSize = function ( width, height ) {\n\n\t\trenderer.setSize( width, height );\n\n\t\tvar pixelRatio = renderer.getPixelRatio();\n\n\t\t_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );\n\t\t_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t_stereo.update( camera );\n\n\t\trenderer.render( scene, _stereo.cameraL, _renderTargetL, true );\n\t\trenderer.render( scene, _stereo.cameraR, _renderTargetR, true );\n\t\trenderer.render( _scene, _camera );\n\n\t};\n\n\tthis.dispose = function() {\n\n\t\tif ( _renderTargetL ) _renderTargetL.dispose();\n\t\tif ( _renderTargetR ) _renderTargetR.dispose();\n\n\t};\n\n};\n","\nfunction VRGamepads(opts) {\n    var options = Object.assign({\n        drag: function(position,direction) {\n            return false;\n        },\n        click: function(position,direction) {\n        },\n        reset: function() {\n        },\n        speed: 10,\n        move: function(delta) {\n        },\n        visionCrosshairAngle: -Math.PI/8,\n        movementMin: .2,\n    },opts);\n\n    var harborpad = null;\n\n    function VRGamepad(gamepad) {\n\n        THREE.Object3D.call( this );\n\n        this.matrixAutoUpdate = false;\n        this.isVRPad = false;\n\n        var axes = [];\n        var buttons = [];\n        var buttonsIndexes = {\n            move: -1,\n            click: -1,\n            reset: -1\n        }\n\n        this.getGamepad = function () {\n            return gamepad;\n        }\n\n        this.getButtonState = function ( button ) {\n            return false;\n        }\n\n        this.drag = function() {\n            var pointer = this.getPointer();\n            var progress = this.progressObject;\n            var pointed = options.drag(pointer.position,pointer.direction);\n            if(pointed) {\n                if(this.pointerRescale) {\n                    var distance = pointer.position.distanceTo(pointed.point);\n                    var thickness = harborpad ? .1 : 1;\n                    this.pointerObject.scale.set(thickness,distance,thickness);\n                }\n                this.pointerObject.material.color.setRGB(0,1,0);\n\n                if(progress) {\n                    var oid = pointed.object.id;\n                    if(this.pointedId==oid) {\n                        const pointingTime = 2000;\n                        var now = Date.now();\n                        var ratio = 1-(now-this.pointedTime)/pointingTime;\n                        if(ratio<0) {\n                            options.click(pointer.position,pointer.direction);\n                            this.pointedId = null;\n                        } else\n                            progress.scale.set(ratio,ratio,ratio);\n                    } else {\n                        this.pointedId = oid;\n                        progress.scale.set(1,1,1);\n                        this.pointedTime = Date.now();\n                        progress.visible = true;\n                    }\n                }\n            } else {\n                this.pointerObject.material.color.setRGB(1,.75,0);\n                if(this.pointerRescale) {\n                    var thickness = harborpad ? .1 : 1;\n                    this.pointerObject.scale.set(thickness,100,thickness);\n                }\n\n                if(progress && this.pointedId) {\n                    progress.visible = false;\n                    this.pointedId = null;\n                }\n\n            }\n        }\n\n        this.update = function() {\n            var $this = this;\n\n            if(this.crosshairNeedsUpdate) {\n                var pointer = this.getPointer();\n                this.pointerObject.position.copy(pointer.position);\n                this.pointerObject.position.add(pointer.direction);\n            }\n\n            if(this.progressNeedsUpdate) {\n                var pointer = this.getPointer();\n                this.progressObject.position.copy(pointer.position);\n                this.progressObject.position.add(pointer.direction);\n            }\n\n\t\t\tvar pose = gamepad.pose;\n            if(pose) {\n                if(pose.position)\n                    this.position.fromArray(pose.position);\n                if(pose.orientation)\n                    this.quaternion.fromArray(pose.orientation);\n                this.matrix.compose(this.position,this.quaternion,this.scale );\n                this.matrixWorldNeedsUpdate = true;\n            }\n            if(gamepad.buttons) {\n                var changedButtons = false;\n                gamepad.buttons.forEach(function(button,index) {\n                    if(index===buttonsIndexes.click && button.pressed)\n                        $this.drag();\n                    if(button.pressed!==buttons[index]) {\n                        buttons[index] = button.pressed;\n                        if(buttons[index]!==undefined) {\n                            changedButtons = true;\n                            if(index===buttonsIndexes.move)\n                                $this.moveButtonChanged(button.pressed);\n                            if(index===buttonsIndexes.click)\n                                $this.clickButtonChanged(button.pressed);\n                            if(index===buttonsIndexes.reset)\n                                $this.resetButtonChanged(button.pressed);\n                        }\n                    }\n                });\n            }\n            if(gamepad.axes) {\n                var changedAxes = false;\n                gamepad.axes.forEach(function(axe,index) {\n                    if(axe!==axes[index]) {\n                        axes[index] = axe;\n                        changedAxes = true;\n                    }\n                });\n                if(buttonsIndexes.move>=0 && buttons[buttonsIndexes.move]) {\n                    var now = window.performance.now();\n                    var last = this.lastThumbpadTimestamp;\n                    var deltaT = now - last;\n                    var rotation = new THREE.Matrix4().extractRotation(this.matrixWorld);\n                    var direction = new THREE.Vector3(axes[0],0,-axes[1]).applyMatrix4(rotation);\n                    direction.multiplyScalar(options.speed*deltaT/1000);\n                    options.move(direction);\n                    this.lastThumbpadTimestamp = now;\n                }\n                if(buttonsIndexes.move<0) {\n                    var now = window.performance.now();\n                    var movement = new THREE.Vector3(axes[0],0,axes[1]);\n                    if(movement.length()>options.movementMin) {\n                        var last = this.lastThumbpadTimestamp;\n                        var deltaT = now - last;\n                        // yeah i know, it could have been simpler\n                        var direction = options.camera.getWorldDirection();\n                        var xzDirection = new THREE.Vector3(direction.x,0,direction.z);\n                        xzDirection.normalize();\n                        xzDirection.applyAxisAngle(new THREE.Vector3(0,1,0),-Math.PI/2);\n                        var rotateAxis = new THREE.Vector3(xzDirection.x,0,xzDirection.z)\n                        rotateAxis.normalize();\n                        var rotateAxis2 = new THREE.Vector3().copy(direction);\n                        rotateAxis2.applyAxisAngle(rotateAxis,Math.PI/2);\n                        var angle = Math.atan2(-axes[0],-axes[1]);\n                        direction.applyAxisAngle(rotateAxis2,angle);\n                        direction.multiplyScalar(options.speed*deltaT/1000);\n                        options.move(direction);\n                    }\n                    this.lastThumbpadTimestamp = now;\n                }\n            }\n\n            if(this.alwaysDrag)\n                this.drag();\n        }\n\n        this.getPointer = function() {\n            var position = this.getWorldPosition();\n            if(gamepad.pose && gamepad.pose.hasOrientation) {\n                var line = this.pointerObject;\n                var pos0 = new THREE.Vector3(0,0,0);\n                pos0.applyMatrix4(line.matrixWorld);\n                var direction = new THREE.Vector3(0,-1,0);\n                direction.applyMatrix4(line.matrixWorld);\n                direction.sub(pos0);\n                direction.normalize();\n                return {\n                    position: position,\n                    direction: direction\n                }\n            } else {\n                var position = options.camera.getWorldPosition();\n                var direction = options.camera.getWorldDirection();\n                position.add(direction);\n                return {\n                    position: position,\n                    direction: direction\n                }\n            }\n        }\n\n        this.moveButtonChanged = function(on) {\n            if(on)\n                this.lastThumbpadTimestamp = window.performance.now();\n        }\n\n        this.clickButtonChanged = function(on) {\n            if(on)\n                this.pointerObject.visible = true;\n            else {\n                this.pointerObject.visible = false;\n                var pointer = this.getPointer();\n                options.click(pointer.position,pointer.direction);\n            }\n        }\n\n        this.resetButtonChanged = function(on) {\n\n        }\n\n        this.destroyGamepad = function() {\n            if(this.parent)\n                this.parent.remove(this);\n            if(this.pointerObject && this.pointerObject.parent)\n                this.pointerObject.parent.remove(this.pointerObject);\n            if(this.progressObject && this.progressObject.parent)\n                this.progressObject.parent.remove(this.progressObject);\n        }\n\n        var cache = {}\n\n        this.createCrosshair = function() {\n            var crosshair = cache[\"crosshair\"];\n            if(crosshair===undefined) {\n                var geometry = new THREE.SphereGeometry(.02);\n                var material = new THREE.MeshBasicMaterial( {color: 0xff0000 } );\n                crosshair = new THREE.Mesh(geometry,material);\n                cache[\"crosshair\"] = crosshair;\n            }\n            crosshair = crosshair.clone();\n            this.crosshairNeedsUpdate = true;\n            this.pointerObject = crosshair;\n            options.scene.add(crosshair);\n            this.pointerRescale = false;\n        }\n\n        this.createProgress = function() {\n            var progress = cache[\"progress\"];\n            if(progress===undefined) {\n                var geometry = new THREE.SphereGeometry(.2,16,12);\n                var material = new THREE.MeshBasicMaterial( {\n                    color: 0xff0000,\n                    opacity: .5,\n                    transparent: true\n                } );\n                progress = new THREE.Mesh(geometry,material);\n                progress.visible = false;\n                cache[\"progress\"] = progress;\n            }\n            progress = progress.clone();\n            this.progressNeedsUpdate = true;\n            this.progressObject = progress;\n            options.scene.add(progress);\n        }\n\n        this.createViveControllerMesh = function() {\n\n            var $this = this;\n            // create clicking ray\n            var line = cache[\"vive-controller-ray\"];\n            if(line===undefined) {\n                var geometry = new THREE.CylinderGeometry(.008,.008,1,8);\n                geometry.translate(0,-.5,0);\n                var material = new THREE.MeshBasicMaterial( {color: 0x80ff80} );\n                line = new THREE.Mesh( geometry, material );\n                line.scale.set(1,100,1);\n                line.rotateX(Math.PI/6);\n                line.visible = false;\n                cache[\"vive-controller-ray\"] = line;\n            }\n            this.pointerObject = line.clone();\n            this.add(this.pointerObject);\n            this.pointerRescale = true;\n\n            // create controller\n            function AddController(object) {\n                $this.add(object);\n            }\n            var controllerObject = cache[\"vive-controller\"];\n            if(controllerObject===undefined) {\n                cache[\"vive-controller\"] = [AddController];\n                var loader = new THREE.JSONLoader();\n                loader.load( options.resBase + 'vive-controller/vr_controller_vive_1_5.js',\n                    function(geometry) {\n                        var loader = new THREE.TextureLoader();\n                        loader.setPath( options.resBase + 'vive-controller/' );\n                        var material = new THREE.MeshBasicMaterial({ color: 0xffffff });\n                        material.map = loader.load( 'onepointfive_texture.png');\n                        material.specularMap = loader.load( 'onepointfive_spec.png');\n                        var controller = new THREE.Mesh(geometry,material);\n                        var object = new THREE.Object3D();\n                        object.add(controller);\n                        cache[\"vive-controller\"].forEach(function(callback) {\n                            callback(object.clone());\n                        });\n                        cache[\"vive-controller\"] = object;\n                });\n            } else if(Array.isArray(controllerObject)) {\n                cache[\"vive-controller\"].push(AddController);\n            } else\n                AddController(controllerObject.clone());\n            options.camera.parent.add(this);\n        }\n\n        this.createOculusTouchMesh = function() {\n            var $this = this;\n            // create clicking ray\n            var line = cache[\"touch-controller-ray\"];\n            if(line===undefined) {\n                var geometry = new THREE.CylinderGeometry(.008,.008,1,8);\n                geometry.translate(0,-.5,0);\n                var material = new THREE.MeshBasicMaterial( {color: 0x80ff80} );\n                line = new THREE.Mesh( geometry, material );\n                line.scale.set(1,100,1);\n                line.rotateX(Math.PI/6);\n                line.visible = false;\n                cache[\"touch-controller-ray\"] = line;\n            }\n            this.pointerObject = line.clone();\n            this.add(this.pointerObject);\n            this.pointerRescale = true;\n\n            // create controller\n            function AddController(object) {\n                $this.add(object);\n            }\n\t\t\tvar cacheName = \"touch-controller-\"+this.whichHand;\n            var controllerObject = cache[cacheName];\n            if(controllerObject===undefined) {\n                cache[cacheName] = [AddController];\n\t\t\t\tvar loader = new THREE.MTLLoader();\n\t\t\t\tloader.setPath(options.resBase + 'touch-controller/');\n\t\t\t\tloader.load(\"oculus-touch-controller-\"+this.whichHand+\".mtl\",function(materials) {\n\t\t\t\t\tmaterials.preload();\n\t\t\t\t\tvar objLoader = new THREE.OBJLoader();\n\t\t\t\t\tobjLoader.setMaterials( materials );\n\t\t\t\t\tobjLoader.setPath(options.resBase + 'touch-controller/');\n\t\t\t\t\tobjLoader.load( \"oculus-touch-controller-\"+$this.whichHand+\".obj\" , function ( controller ) {\n                        var object = new THREE.Object3D();\n\t\t\t\t\t\tcontroller.position.add(new THREE.Vector3(.008,0.03,-.03));\n                        object.add(controller);\n                        cache[cacheName].forEach(function(callback) {\n                            callback(object.clone());\n                        });\n                        cache[cacheName] = object;\t\t\t\t\n\t\t\t\t\t});\n\n\t\t\t\t});\n            } else if(Array.isArray(controllerObject)) {\n                cache[cacheName].push(AddController);\n            } else\n                AddController(controllerObject.clone());\n            options.camera.parent.add(this);\n\t\t}\n\n        this.getAxes = function() {\n            return axes;\n        }\n\n\t\tif(/left/i.test(gamepad.id))\n\t\t\tthis.whichHand = \"left\";\n\t\tif(/right/i.test(gamepad.id))\n\t\t\tthis.whichHand = \"right\";\n\t\t\n        if(/openvr/i.test(gamepad.id)) {\n            this.createViveControllerMesh();\n            buttonsIndexes = {\n                move: 0,\n                click: 1,\n                reset: 3\n            }\n            this.isVRPad = true;\n        } else if(/touch/i.test(gamepad.id)) {\n            this.createOculusTouchMesh();\n            buttonsIndexes = {\n                move: -1,\n                click: 1,\n                reset: 3\n            }\n            this.isVRPad = true;\n        } else if(gamepad.id==\"simulated\") {\n            this.createCrosshair();\n            this.createProgress();\n            this.alwaysDrag = true;\n        } else if(gamepad.id==/gear vr/i.test(gamepad.id)) {\n            this.createCrosshair();\n            buttonsIndexes = {\n                move: -1,\n                click: 1,\n                reset: 1\n            }\n        } else {\n            this.createCrosshair();\n            buttonsIndexes = {\n                move: -1,\n                click: 7,\n                reset: 1\n            }\n        }\n\n    };\n\n    VRGamepad.prototype = Object.create( THREE.Object3D.prototype );\n    VRGamepad.prototype.constructor = VRGamepad;\n\n    var knownGamepads = [];\n\n    function mapGamepads() {\n        var newGamepads = [];\n        if(typeof navigator.getGamepads==\"function\") {\n            var gamepadsList = navigator.getGamepads();\n            for(var i = 0;i<gamepadsList.length;i++) {\n                var gamepad = gamepadsList[i];\n                if(gamepad) {\n                    var isNewGamepad = true;\n                    for(var j=0;j<knownGamepads.length;j++) {\n                        var knownGamepad = knownGamepads[j];\n                        if(gamepad===knownGamepad.getGamepad()) {\n                            newGamepads.push(knownGamepad);\n                            knownGamepads.splice(j,1);\n                            isNewGamepad = false;\n                            break;\n                        }\n                    }\n                    if(isNewGamepad)\n                        newGamepads.push(new VRGamepad(gamepad));\n                }\n            }\n        }\n        if(newGamepads.length==0) {\n            var needSimulated = true;\n            for(var j=0;j<knownGamepads.length;j++) {\n                var knownGamepad = knownGamepads[j];\n                if(knownGamepad.getGamepad().id==\"simulated\") {\n                    newGamepads.push(knownGamepad);\n                    knownGamepads.splice(j,1);\n                    needSimulated = false;\n                }\n            }\n            if(needSimulated)\n                newGamepads.push(new VRGamepad({\n                    id: \"simulated\"\n                }));\n        }\n        knownGamepads.forEach(function(gamepad) {\n            gamepad.destroyGamepad();\n        });\n        knownGamepads = newGamepads;\n        harborpad = null;\n        var firstVRPad = null;\n        for(var i=0;i<knownGamepads.length;i++) {\n            var gamepad = knownGamepads[i];\n            if(gamepad.isVRPad) {\n                if(firstVRPad) {\n                    harborpad = gamepad;\n                    break;\n                } else\n                    firstVRPad = gamepad;\n            }\n        }\n        if(harborpad) {\n\t\t\tif(harborpad.whichHand==\"right\" && firstVRPad.whichHand==\"left\") {\n\t\t\t\tvar tmpPad = harborpad;\n\t\t\t\tharborpad = firstVRPad;\n\t\t\t\tfirstVRPad = tmpPad;\n\t\t\t}\n            firstVRPad.pointerObject.scale.setX(.1);\n            firstVRPad.pointerObject.scale.setZ(.1);\n        } else if(firstVRPad) {\n            firstVRPad.pointerObject.scale.setX(1);\n            firstVRPad.pointerObject.scale.setZ(1);\n        }\n\n    }\n\n    this.getHarborPad = function() {\n        return harborpad;\n    }\n\n    this.update = function() {\n        mapGamepads();\n        knownGamepads.forEach(function(gamepad) {\n            gamepad.update();\n        });\n    }\n\n    this.clearAll = function() {\n        knownGamepads.forEach(function(gamepad) {\n            gamepad.destroyGamepad();\n        });\n        knownGamepads = [];\n    }\n\n}\n","/**\n * @author dmarcos / https://github.com/dmarcos\n * @author mrdoob / http://mrdoob.com\n */\n\nTHREE.VRControls = function ( object, onError ) {\n\n\tvar scope = this;\n\n\tvar vrDisplay, vrDisplays;\n\n\tvar standingMatrix = new THREE.Matrix4();\n\n\tvar frameData = null;\n\n\tif ( 'VRFrameData' in window ) {\n\n\t\tframeData = new VRFrameData();\n\n\t}\n\n\tfunction gotVRDisplays( displays ) {\n\n\t\tvrDisplays = displays;\n\n\t\tif ( displays.length > 0 ) {\n\n\t\t\tvrDisplay = displays[ 0 ];\n\n\t\t} else {\n\n\t\t\tif ( onError ) onError( 'VR input not available.' );\n\n\t\t}\n\n\t}\n\n\tif ( navigator.getVRDisplays ) {\n\n\t\tnavigator.getVRDisplays().then( gotVRDisplays ).catch ( function () {\n\n\t\t\tconsole.warn( 'THREE.VRControls: Unable to get VR Displays' );\n\n\t\t} );\n\n\t}\n\n\t// the Rift SDK returns the position in meters\n\t// this scale factor allows the user to define how meters\n\t// are converted to scene units.\n\n\tthis.scale = 1;\n\n\t// If true will use \"standing space\" coordinate system where y=0 is the\n\t// floor and x=0, z=0 is the center of the room.\n\tthis.standing = false;\n\n\t// Distance from the users eyes to the floor in meters. Used when\n\t// standing=true but the VRDisplay doesn't provide stageParameters.\n\tthis.userHeight = 1.6;\n\n\tthis.getVRDisplay = function () {\n\n\t\treturn vrDisplay;\n\n\t};\n\n\tthis.setVRDisplay = function ( value ) {\n\n\t\tvrDisplay = value;\n\n\t};\n\n\tthis.getVRDisplays = function () {\n\n\t\tconsole.warn( 'THREE.VRControls: getVRDisplays() is being deprecated.' );\n\t\treturn vrDisplays;\n\n\t};\n\n\tthis.getStandingMatrix = function () {\n\n\t\treturn standingMatrix;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tif ( vrDisplay ) {\n\n\t\t\tvar pose;\n\n\t\t\tif ( vrDisplay.getFrameData ) {\n\n\t\t\t\tvrDisplay.getFrameData( frameData );\n\t\t\t\tpose = frameData.pose;\n\n\t\t\t} else if ( vrDisplay.getPose ) {\n\n\t\t\t\tpose = vrDisplay.getPose();\n\n\t\t\t}\n\n\t\t\tif ( pose.orientation !== null ) {\n\n\t\t\t\tobject.quaternion.fromArray( pose.orientation );\n\n\t\t\t}\n\n\t\t\tif ( pose.position !== null ) {\n\n\t\t\t\tobject.position.fromArray( pose.position );\n\n\t\t\t} else {\n\n\t\t\t\tobject.position.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( this.standing ) {\n\n\t\t\t\tif ( vrDisplay.stageParameters ) {\n\n\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\tstandingMatrix.fromArray( vrDisplay.stageParameters.sittingToStandingTransform );\n\t\t\t\t\tobject.applyMatrix( standingMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.position.setY( object.position.y + this.userHeight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.position.multiplyScalar( scope.scale );\n\n\t\t}\n\n\t};\n\n\tthis.resetPose = function () {\n\n\t\tif ( vrDisplay ) {\n\n\t\t\tvrDisplay.resetPose();\n\n\t\t}\n\n\t};\n\n\tthis.resetSensor = function () {\n\n\t\tconsole.warn( 'THREE.VRControls: .resetSensor() is now .resetPose().' );\n\t\tthis.resetPose();\n\n\t};\n\n\tthis.zeroSensor = function () {\n\n\t\tconsole.warn( 'THREE.VRControls: .zeroSensor() is now .resetPose().' );\n\t\tthis.resetPose();\n\n\t};\n\n\tthis.dispose = function () {\n\n\t\tvrDisplay = null;\n\n\t};\n\n};\n","/**\n * @author dmarcos / https://github.com/dmarcos\n * @author mrdoob / http://mrdoob.com\n *\n * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html\n *\n * Firefox: http://mozvr.com/downloads/\n * Chromium: https://webvr.info/get-chrome\n *\n */\n\nTHREE.VREffect = function( renderer, onError ) {\n\n\tvar vrDisplay, vrDisplays;\n\tvar eyeTranslationL = new THREE.Vector3();\n\tvar eyeTranslationR = new THREE.Vector3();\n\tvar renderRectL, renderRectR;\n\n\tvar frameData = null;\n\n\tif ( 'VRFrameData' in window ) {\n\n\t\tframeData = new window.VRFrameData();\n\n\t}\n\n\tfunction gotVRDisplays( displays ) {\n\n\t\tvrDisplays = displays;\n\n\t\tif ( displays.length > 0 ) {\n\n\t\t\tvrDisplay = displays[ 0 ];\n\n\t\t} else {\n\n\t\t\tif ( onError ) onError( 'HMD not available' );\n\n\t\t}\n\n\t}\n\n\tif ( navigator.getVRDisplays ) {\n\n\t\tnavigator.getVRDisplays().then( gotVRDisplays ).catch( function() {\n\n\t\t\tconsole.warn( 'THREE.VREffect: Unable to get VR Displays' );\n\n\t\t} );\n\n\t}\n\n\t//\n\n\tthis.isPresenting = false;\n\tthis.scale = 1;\n\n\tvar scope = this;\n\n\tvar rendererSize = renderer.getSize();\n\tvar rendererUpdateStyle = false;\n\tvar rendererPixelRatio = renderer.getPixelRatio();\n\n\tthis.getVRDisplay = function() {\n\n\t\treturn vrDisplay;\n\n\t};\n\n\tthis.setVRDisplay = function( value ) {\n\n\t\tvrDisplay = value;\n\n\t};\n\n\tthis.getVRDisplays = function() {\n\n\t\tconsole.warn( 'THREE.VREffect: getVRDisplays() is being deprecated.' );\n\t\treturn vrDisplays;\n\n\t};\n\n\tthis.setSize = function( width, height, updateStyle ) {\n\n\t\trendererSize = { width: width, height: height };\n\t\trendererUpdateStyle = updateStyle;\n\n\t\tif ( scope.isPresenting ) {\n\n\t\t\tvar eyeParamsL = vrDisplay.getEyeParameters( 'left' );\n\t\t\trenderer.setPixelRatio( 1 );\n\t\t\trenderer.setSize( eyeParamsL.renderWidth * 2, eyeParamsL.renderHeight, false );\n\n\t\t} else {\n\n\t\t\trenderer.setPixelRatio( rendererPixelRatio );\n\t\t\trenderer.setSize( width, height, updateStyle );\n\n\t\t}\n\n\t};\n\n\t// VR presentation\n\n\tvar canvas = renderer.domElement;\n\tvar defaultLeftBounds = [ 0.0, 0.0, 0.5, 1.0 ];\n\tvar defaultRightBounds = [ 0.5, 0.0, 0.5, 1.0 ];\n\n\tfunction onVRDisplayPresentChange() {\n\n\t\tvar wasPresenting = scope.isPresenting;\n\t\tscope.isPresenting = vrDisplay !== undefined && vrDisplay.isPresenting;\n\n\t\tif ( scope.isPresenting ) {\n\n\t\t\tvar eyeParamsL = vrDisplay.getEyeParameters( 'left' );\n\t\t\tvar eyeWidth = eyeParamsL.renderWidth;\n\t\t\tvar eyeHeight = eyeParamsL.renderHeight;\n\n\t\t\tif ( ! wasPresenting ) {\n\n\t\t\t\trendererPixelRatio = renderer.getPixelRatio();\n\t\t\t\trendererSize = renderer.getSize();\n\n\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\trenderer.setSize( eyeWidth * 2, eyeHeight, false );\n\n\t\t\t}\n\n\t\t} else if ( wasPresenting ) {\n\n\t\t\trenderer.setPixelRatio( rendererPixelRatio );\n\t\t\trenderer.setSize( rendererSize.width, rendererSize.height, rendererUpdateStyle );\n\n\t\t}\n\n\t}\n\n\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\n\n\tthis.setFullScreen = function( boolean ) {\n\n\t\treturn new Promise( function( resolve, reject ) {\n\n\t\t\tif ( vrDisplay === undefined ) {\n\n\t\t\t\treject( new Error( 'No VR hardware found.' ) );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( scope.isPresenting === boolean ) {\n\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( boolean ) {\n\n\t\t\t\tresolve( vrDisplay.requestPresent( [ { source: canvas } ] ) );\n\n\t\t\t} else {\n\n\t\t\t\tresolve( vrDisplay.exitPresent() );\n\n\t\t\t}\n\n\t\t} );\n\n\t};\n\n\tthis.requestPresent = function() {\n\n\t\treturn this.setFullScreen( true );\n\n\t};\n\n\tthis.exitPresent = function() {\n\n\t\treturn this.setFullScreen( false );\n\n\t};\n\n\tthis.requestAnimationFrame = function( f ) {\n\n\t\tif ( vrDisplay !== undefined ) {\n\n\t\t\treturn vrDisplay.requestAnimationFrame( f );\n\n\t\t} else {\n\n\t\t\treturn window.requestAnimationFrame( f );\n\n\t\t}\n\n\t};\n\n\tthis.cancelAnimationFrame = function( h ) {\n\n\t\tif ( vrDisplay !== undefined ) {\n\n\t\t\tvrDisplay.cancelAnimationFrame( h );\n\n\t\t} else {\n\n\t\t\twindow.cancelAnimationFrame( h );\n\n\t\t}\n\n\t};\n\n\tthis.submitFrame = function() {\n\n\t\tif ( vrDisplay !== undefined && scope.isPresenting ) {\n\n\t\t\tvrDisplay.submitFrame();\n\n\t\t}\n\n\t};\n\n\tthis.autoSubmitFrame = true;\n\n\t// render\n\n\tvar cameraL = new THREE.PerspectiveCamera();\n\tcameraL.layers.enable( 1 );\n\n\tvar cameraR = new THREE.PerspectiveCamera();\n\tcameraR.layers.enable( 2 );\n\n\tthis.render = function( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( vrDisplay && scope.isPresenting ) {\n\n\t\t\tvar autoUpdate = scene.autoUpdate;\n\n\t\t\tif ( autoUpdate ) {\n\n\t\t\t\tscene.updateMatrixWorld();\n\t\t\t\tscene.autoUpdate = false;\n\n\t\t\t}\n\n\t\t\tvar eyeParamsL = vrDisplay.getEyeParameters( 'left' );\n\t\t\tvar eyeParamsR = vrDisplay.getEyeParameters( 'right' );\n\n\t\t\teyeTranslationL.fromArray( eyeParamsL.offset );\n\t\t\teyeTranslationR.fromArray( eyeParamsR.offset );\n\n\t\t\tif ( Array.isArray( scene ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.VREffect.render() no longer supports arrays. Use object.layers instead.' );\n\t\t\t\tscene = scene[ 0 ];\n\n\t\t\t}\n\n\t\t\t// When rendering we don't care what the recommended size is, only what the actual size\n\t\t\t// of the backbuffer is.\n\t\t\tvar size = renderer.getSize();\n\t\t\tvar layers = vrDisplay.getLayers();\n\t\t\tvar leftBounds;\n\t\t\tvar rightBounds;\n\n\t\t\tif ( layers.length ) {\n\n\t\t\t\tvar layer = layers[ 0 ];\n\n\t\t\t\tleftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ? layer.leftBounds : defaultLeftBounds;\n\t\t\t\trightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ? layer.rightBounds : defaultRightBounds;\n\n\t\t\t} else {\n\n\t\t\t\tleftBounds = defaultLeftBounds;\n\t\t\t\trightBounds = defaultRightBounds;\n\n\t\t\t}\n\n\t\t\trenderRectL = {\n\t\t\t\tx: Math.round( size.width * leftBounds[ 0 ] ),\n\t\t\t\ty: Math.round( size.height * leftBounds[ 1 ] ),\n\t\t\t\twidth: Math.round( size.width * leftBounds[ 2 ] ),\n\t\t\t\theight: Math.round( size.height * leftBounds[ 3 ] )\n\t\t\t};\n\t\t\trenderRectR = {\n\t\t\t\tx: Math.round( size.width * rightBounds[ 0 ] ),\n\t\t\t\ty: Math.round( size.height * rightBounds[ 1 ] ),\n\t\t\t\twidth: Math.round( size.width * rightBounds[ 2 ] ),\n\t\t\t\theight: Math.round( size.height * rightBounds[ 3 ] )\n\t\t\t};\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\t\trenderTarget.scissorTest = true;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.setScissorTest( true );\n\n\t\t\t}\n\n\t\t\tif ( renderer.autoClear || forceClear ) renderer.clear();\n\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t\tcamera.matrixWorld.decompose( cameraL.position, cameraL.quaternion, cameraL.scale );\n\t\t\tcamera.matrixWorld.decompose( cameraR.position, cameraR.quaternion, cameraR.scale );\n\n\t\t\tvar scale = this.scale;\n\t\t\tcameraL.translateOnAxis( eyeTranslationL, scale );\n\t\t\tcameraR.translateOnAxis( eyeTranslationR, scale );\n\n\t\t\tif ( vrDisplay.getFrameData ) {\n\n\t\t\t\tvrDisplay.depthNear = camera.near;\n\t\t\t\tvrDisplay.depthFar = camera.far;\n\n\t\t\t\tvrDisplay.getFrameData( frameData );\n\n\t\t\t\tcameraL.projectionMatrix.elements = frameData.leftProjectionMatrix;\n\t\t\t\tcameraR.projectionMatrix.elements = frameData.rightProjectionMatrix;\n\n\t\t\t} else {\n\n\t\t\t\tcameraL.projectionMatrix = fovToProjection( eyeParamsL.fieldOfView, true, camera.near, camera.far );\n\t\t\t\tcameraR.projectionMatrix = fovToProjection( eyeParamsR.fieldOfView, true, camera.near, camera.far );\n\n\t\t\t}\n\n\t\t\t// render left eye\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\trenderTarget.viewport.set( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );\n\t\t\t\trenderTarget.scissor.set( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setViewport( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );\n\t\t\t\trenderer.setScissor( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );\n\n\t\t\t}\n\t\t\trenderer.render( scene, cameraL, renderTarget, forceClear );\n\n\t\t\t// render right eye\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\trenderTarget.viewport.set( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );\n\t\t\t\trenderTarget.scissor.set( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setViewport( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );\n\t\t\t\trenderer.setScissor( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );\n\n\t\t\t}\n\t\t\trenderer.render( scene, cameraR, renderTarget, forceClear );\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\trenderTarget.viewport.set( 0, 0, size.width, size.height );\n\t\t\t\trenderTarget.scissor.set( 0, 0, size.width, size.height );\n\t\t\t\trenderTarget.scissorTest = false;\n\t\t\t\trenderer.setRenderTarget( null );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setViewport( 0, 0, size.width, size.height );\n\t\t\t\trenderer.setScissorTest( false );\n\n\t\t\t}\n\n\t\t\tif ( autoUpdate ) {\n\n\t\t\t\tscene.autoUpdate = true;\n\n\t\t\t}\n\n\t\t\tif ( scope.autoSubmitFrame ) {\n\n\t\t\t\tscope.submitFrame();\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Regular render mode if not HMD\n\n\t\trenderer.render( scene, camera, renderTarget, forceClear );\n\n\t};\n\n\tthis.dispose = function() {\n\n\t\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\n\n\t};\n\n\t//\n\n\tfunction fovToNDCScaleOffset( fov ) {\n\n\t\tvar pxscale = 2.0 / ( fov.leftTan + fov.rightTan );\n\t\tvar pxoffset = ( fov.leftTan - fov.rightTan ) * pxscale * 0.5;\n\t\tvar pyscale = 2.0 / ( fov.upTan + fov.downTan );\n\t\tvar pyoffset = ( fov.upTan - fov.downTan ) * pyscale * 0.5;\n\t\treturn { scale: [ pxscale, pyscale ], offset: [ pxoffset, pyoffset ] };\n\n\t}\n\n\tfunction fovPortToProjection( fov, rightHanded, zNear, zFar ) {\n\n\t\trightHanded = rightHanded === undefined ? true : rightHanded;\n\t\tzNear = zNear === undefined ? 0.01 : zNear;\n\t\tzFar = zFar === undefined ? 10000.0 : zFar;\n\n\t\tvar handednessScale = rightHanded ? - 1.0 : 1.0;\n\n\t\t// start with an identity matrix\n\t\tvar mobj = new THREE.Matrix4();\n\t\tvar m = mobj.elements;\n\n\t\t// and with scale/offset info for normalized device coords\n\t\tvar scaleAndOffset = fovToNDCScaleOffset( fov );\n\n\t\t// X result, map clip edges to [-w,+w]\n\t\tm[ 0 * 4 + 0 ] = scaleAndOffset.scale[ 0 ];\n\t\tm[ 0 * 4 + 1 ] = 0.0;\n\t\tm[ 0 * 4 + 2 ] = scaleAndOffset.offset[ 0 ] * handednessScale;\n\t\tm[ 0 * 4 + 3 ] = 0.0;\n\n\t\t// Y result, map clip edges to [-w,+w]\n\t\t// Y offset is negated because this proj matrix transforms from world coords with Y=up,\n\t\t// but the NDC scaling has Y=down (thanks D3D?)\n\t\tm[ 1 * 4 + 0 ] = 0.0;\n\t\tm[ 1 * 4 + 1 ] = scaleAndOffset.scale[ 1 ];\n\t\tm[ 1 * 4 + 2 ] = - scaleAndOffset.offset[ 1 ] * handednessScale;\n\t\tm[ 1 * 4 + 3 ] = 0.0;\n\n\t\t// Z result (up to the app)\n\t\tm[ 2 * 4 + 0 ] = 0.0;\n\t\tm[ 2 * 4 + 1 ] = 0.0;\n\t\tm[ 2 * 4 + 2 ] = zFar / ( zNear - zFar ) * - handednessScale;\n\t\tm[ 2 * 4 + 3 ] = ( zFar * zNear ) / ( zNear - zFar );\n\n\t\t// W result (= Z in)\n\t\tm[ 3 * 4 + 0 ] = 0.0;\n\t\tm[ 3 * 4 + 1 ] = 0.0;\n\t\tm[ 3 * 4 + 2 ] = handednessScale;\n\t\tm[ 3 * 4 + 3 ] = 0.0;\n\n\t\tmobj.transpose();\n\n\t\treturn mobj;\n\n\t}\n\n\tfunction fovToProjection( fov, rightHanded, zNear, zFar ) {\n\n\t\tvar DEG2RAD = Math.PI / 180.0;\n\n\t\tvar fovPort = {\n\t\t\tupTan: Math.tan( fov.upDegrees * DEG2RAD ),\n\t\t\tdownTan: Math.tan( fov.downDegrees * DEG2RAD ),\n\t\t\tleftTan: Math.tan( fov.leftDegrees * DEG2RAD ),\n\t\t\trightTan: Math.tan( fov.rightDegrees * DEG2RAD )\n\t\t};\n\n\t\treturn fovPortToProjection( fovPort, rightHanded, zNear, zFar );\n\n\t}\n\n};\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.OBJLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\tthis.materials = null;\n\n\tthis.regexp = {\n\t\t// v float float float\n\t\tvertex_pattern           : /^v\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t\t// vn float float float\n\t\tnormal_pattern           : /^vn\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t\t// vt float float\n\t\tuv_pattern               : /^vt\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t\t// f vertex vertex vertex\n\t\tface_vertex              : /^f\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)(?:\\s+(-?\\d+))?/,\n\t\t// f vertex/uv vertex/uv vertex/uv\n\t\tface_vertex_uv           : /^f\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+))?/,\n\t\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n\t\tface_vertex_uv_normal    : /^f\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/,\n\t\t// f vertex//normal vertex//normal vertex//normal\n\t\tface_vertex_normal       : /^f\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)(?:\\s+(-?\\d+)\\/\\/(-?\\d+))?/,\n\t\t// o object_name | g group_name\n\t\tobject_pattern           : /^[og]\\s*(.+)?/,\n\t\t// s boolean\n\t\tsmoothing_pattern        : /^s\\s+(\\d+|on|off)/,\n\t\t// mtllib file_reference\n\t\tmaterial_library_pattern : /^mtllib /,\n\t\t// usemtl material_name\n\t\tmaterial_use_pattern     : /^usemtl /\n\t};\n\n};\n\nTHREE.OBJLoader.prototype = {\n\n\tconstructor: THREE.OBJLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\n\t},\n\n\tsetMaterials: function ( materials ) {\n\n\t\tthis.materials = materials;\n\n\t},\n\n\t_createParserState : function () {\n\n\t\tvar state = {\n\t\t\tobjects  : [],\n\t\t\tobject   : {},\n\n\t\t\tvertices : [],\n\t\t\tnormals  : [],\n\t\t\tuvs      : [],\n\n\t\t\tmaterialLibraries : [],\n\n\t\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t\tthis.object = {\n\t\t\t\t\tname : name || '',\n\t\t\t\t\tfromDeclaration : ( fromDeclaration !== false ),\n\n\t\t\t\t\tgeometry : {\n\t\t\t\t\t\tvertices : [],\n\t\t\t\t\t\tnormals  : [],\n\t\t\t\t\t\tuvs      : []\n\t\t\t\t\t},\n\t\t\t\t\tmaterials : [],\n\t\t\t\t\tsmooth : true,\n\n\t\t\t\t\tstartMaterial : function( name, libraries ) {\n\n\t\t\t\t\t\tvar previous = this._finalize( false );\n\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\tindex      : this.materials.length,\n\t\t\t\t\t\t\tname       : name || '',\n\t\t\t\t\t\t\tmtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\t\tsmooth     : ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\t\tgroupStart : ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\t\tgroupEnd   : -1,\n\t\t\t\t\t\t\tgroupCount : -1,\n\t\t\t\t\t\t\tinherited  : false,\n\n\t\t\t\t\t\t\tclone : function( index ) {\n\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\tindex      : ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\t\tname       : this.name,\n\t\t\t\t\t\t\t\t\tmtllib     : this.mtllib,\n\t\t\t\t\t\t\t\t\tsmooth     : this.smooth,\n\t\t\t\t\t\t\t\t\tgroupStart : 0,\n\t\t\t\t\t\t\t\t\tgroupEnd   : -1,\n\t\t\t\t\t\t\t\t\tgroupCount : -1,\n\t\t\t\t\t\t\t\t\tinherited  : false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind(cloned);\n\t\t\t\t\t\t\t\treturn cloned;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\t\treturn material;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tcurrentMaterial : function() {\n\n\t\t\t\t\t\tif ( this.materials.length > 0 ) {\n\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn undefined;\n\n\t\t\t\t\t},\n\n\t\t\t\t\t_finalize : function( end ) {\n\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {\n\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi-- ) {\n\t\t\t\t\t\t\t\tif ( this.materials[mi].groupCount <= 0 ) {\n\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\t\tthis.materials.push({\n\t\t\t\t\t\t\t\tname   : '',\n\t\t\t\t\t\t\t\tsmooth : this.smooth\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Inherit previous objects material.\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\" ) {\n\n\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\n\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t\t}\n\n\t\t\t\tthis.objects.push( this.object );\n\n\t\t\t},\n\n\t\t\tfinalize : function() {\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t\t},\n\n\t\t\taddVertex: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\t\t\t\tdst.push( src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ] );\n\t\t\t\tdst.push( src[ b + 1 ] );\n\t\t\t\tdst.push( src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ] );\n\t\t\t\tdst.push( src[ c + 1 ] );\n\t\t\t\tdst.push( src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddVertexLine: function ( a ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\t\t\t\tdst.push( src[ a + 2 ] );\n\n\t\t\t},\n\n\t\t\taddNormal : function ( a, b, c ) {\n\n\t\t\t\tvar src = this.normals;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\t\t\t\tdst.push( src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ] );\n\t\t\t\tdst.push( src[ b + 1 ] );\n\t\t\t\tdst.push( src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ] );\n\t\t\t\tdst.push( src[ c + 1 ] );\n\t\t\t\tdst.push( src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddUV: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\t\t\t\tdst.push( src[ b + 0 ] );\n\t\t\t\tdst.push( src[ b + 1 ] );\n\t\t\t\tdst.push( src[ c + 0 ] );\n\t\t\t\tdst.push( src[ c + 1 ] );\n\n\t\t\t},\n\n\t\t\taddUVLine: function ( a ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\n\t\t\t},\n\n\t\t\taddFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) {\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\n\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\n\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\n\t\t\t\tvar id;\n\n\t\t\t\tif ( d === undefined ) {\n\n\t\t\t\t\tthis.addVertex( ia, ib, ic );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tid = this.parseVertexIndex( d, vLen );\n\n\t\t\t\t\tthis.addVertex( ia, ib, id );\n\t\t\t\t\tthis.addVertex( ib, ic, id );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ua !== undefined ) {\n\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\n\t\t\t\t\tif ( d === undefined ) {\n\n\t\t\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tid = this.parseUVIndex( ud, uvLen );\n\n\t\t\t\t\t\tthis.addUV( ia, ib, id );\n\t\t\t\t\t\tthis.addUV( ib, ic, id );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( na !== undefined ) {\n\n\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\n\t\t\t\t\tvar nLen = this.normals.length;\n\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\n\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex( nb, nLen );\n\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex( nc, nLen );\n\n\t\t\t\t\tif ( d === undefined ) {\n\n\t\t\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tid = this.parseNormalIndex( nd, nLen );\n\n\t\t\t\t\t\tthis.addNormal( ia, ib, id );\n\t\t\t\t\t\tthis.addNormal( ib, ic, id );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tstate.startObject( '', false );\n\n\t\treturn state;\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tconsole.time( 'OBJLoader' );\n\n\t\tvar state = this._createParserState();\n\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1) {\n\n\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t}\n\n\t\tvar lines = text.split( '\\n' );\n\t\tvar line = '', lineFirstChar = '', lineSecondChar = '';\n\t\tvar lineLength = 0;\n\t\tvar result = [];\n\n\t\t// Faster to just trim left side of the line. Use if available.\n\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tline = lines[ i ];\n\n\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\tlineLength = line.length;\n\n\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t// @todo invoke passed in handler if any\n\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\tlineSecondChar = line.charAt( 1 );\n\n\t\t\t\tif ( lineSecondChar === ' ' && ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// 0                  1      2      3\n\t\t\t\t\t// [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\t\tparseFloat( result[ 2 ] ),\n\t\t\t\t\t\tparseFloat( result[ 3 ] )\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( lineSecondChar === 'n' && ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// 0                   1      2      3\n\t\t\t\t\t// [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\t\tparseFloat( result[ 2 ] ),\n\t\t\t\t\t\tparseFloat( result[ 3 ] )\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( lineSecondChar === 't' && ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// 0               1      2\n\t\t\t\t\t// [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\n\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\t\tparseFloat( result[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( \"Unexpected vertex/normal/uv line: '\" + line  + \"'\" );\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === \"f\" ) {\n\n\t\t\t\tif ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n\t\t\t\t\t// 0                        1    2    3    4    5    6    7    8    9   10         11         12\n\t\t\t\t\t// [\"f 1/1/1 2/2/2 3/3/3\", \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"3\", \"3\", \"3\", undefined, undefined, undefined]\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tresult[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ],\n\t\t\t\t\t\tresult[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],\n\t\t\t\t\t\tresult[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// f vertex/uv vertex/uv vertex/uv\n\t\t\t\t\t// 0                  1    2    3    4    5    6   7          8\n\t\t\t\t\t// [\"f 1/1 2/2 3/3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tresult[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],\n\t\t\t\t\t\tresult[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// f vertex//normal vertex//normal vertex//normal\n\t\t\t\t\t// 0                     1    2    3    4    5    6   7          8\n\t\t\t\t\t// [\"f 1//1 2//2 3//3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tresult[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],\n\t\t\t\t\t\tundefined, undefined, undefined, undefined,\n\t\t\t\t\t\tresult[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// f vertex vertex vertex\n\t\t\t\t\t// 0            1    2    3   4\n\t\t\t\t\t// [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tresult[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( \"Unexpected face line: '\" + line  + \"'\" );\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === \"l\" ) {\n\n\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( \" \" );\n\t\t\t\tvar lineVertices = [], lineUVs = [];\n\n\t\t\t\tif ( line.indexOf( \"/\" ) === - 1 ) {\n\n\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\tvar parts = lineParts[ li ].split( \"/\" );\n\n\t\t\t\t\t\tif ( parts[ 0 ] !== \"\" ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\tif ( parts[ 1 ] !== \"\" ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t} else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// o object_name\n\t\t\t\t// or\n\t\t\t\t// g group_name\n\n\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\tvar name = ( \" \" + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\n\n\t\t\t\tstate.startObject( name );\n\n\t\t\t} else if ( this.regexp.material_use_pattern.test( line ) ) {\n\n\t\t\t\t// material\n\n\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t} else if ( this.regexp.material_library_pattern.test( line ) ) {\n\n\t\t\t\t// mtl file\n\n\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t} else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// smooth shading\n\n\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\n\t\t\t\tstate.object.smooth = ( value === '1' || value === 'on' );\n\n\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\tif ( material ) {\n\n\t\t\t\t\tmaterial.smooth = state.object.smooth;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Handle null terminated files without exception\n\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\tthrow new Error( \"Unexpected line: '\" + line  + \"'\" );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.finalize();\n\n\t\tvar container = new THREE.Group();\n\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\tvar object = state.objects[ i ];\n\t\t\tvar geometry = object.geometry;\n\t\t\tvar materials = object.materials;\n\t\t\tvar isLine = ( geometry.type === 'Line' );\n\n\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\tvar buffergeometry = new THREE.BufferGeometry();\n\n\t\t\tbuffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\tbuffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\tbuffergeometry.computeVertexNormals();\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\tbuffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n\n\t\t\t}\n\n\t\t\t// Create materials\n\n\t\t\tvar createdMaterials = [];\n\n\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {\n\n\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\tvar material = undefined;\n\n\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\tif ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {\n\n\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\n\t\t\t\t\t\tmaterialLine.copy( material );\n\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! material ) {\n\n\t\t\t\t\tmaterial = ( ! isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial() );\n\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;\n\n\t\t\t\tcreatedMaterials.push(material);\n\n\t\t\t}\n\n\t\t\t// Create mesh\n\n\t\t\tvar mesh;\n\n\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {\n\n\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t}\n\n\t\t\t\tmesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials ) : new THREE.LineSegments( buffergeometry, createdMaterials ) );\n\n\t\t\t} else {\n\n\t\t\t\tmesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] ) );\n\t\t\t}\n\n\t\t\tmesh.name = object.name;\n\n\t\t\tcontainer.add( mesh );\n\n\t\t}\n\n\t\tconsole.timeEnd( 'OBJLoader' );\n\n\t\treturn container;\n\n\t}\n\n};\n","/**\n * Loads a Wavefront .mtl file specifying materials\n *\n * @author angelxuanchang\n */\n\nTHREE.MTLLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.MTLLoader.prototype = {\n\n\tconstructor: THREE.MTLLoader,\n\n\t/**\n\t * Loads and parses a MTL asset from a URL.\n\t *\n\t * @param {String} url - URL to the MTL file.\n\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\n\t * @param {Function} [onProgress] - Callback for download progress.\n\t * @param {Function} [onError] - Callback for download errors.\n\t *\n\t * @see setPath setTexturePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setPath and/or setTexturePath explicitly prior to load.\n\t */\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\t/**\n\t * Set base path for resolving references.\n\t * If set this path will be prepended to each loaded and found reference.\n\t *\n\t * @see setTexturePath\n\t * @param {String} path\n\t *\n\t * @example\n\t *     mtlLoader.setPath( 'assets/obj/' );\n\t *     mtlLoader.load( 'my.mtl', ... );\n\t */\n\tsetPath: function ( path ) {\n\n\t\tthis.path = path;\n\n\t},\n\n\t/**\n\t * Set base path for resolving texture references.\n\t * If set this path will be prepended found texture reference.\n\t * If not set and setPath is, it will be used as texture base path.\n\t *\n\t * @see setPath\n\t * @param {String} path\n\t *\n\t * @example\n\t *     mtlLoader.setPath( 'assets/obj/' );\n\t *     mtlLoader.setTexturePath( 'assets/textures/' );\n\t *     mtlLoader.load( 'my.mtl', ... );\n\t */\n\tsetTexturePath: function ( path ) {\n\n\t\tthis.texturePath = path;\n\n\t},\n\n\tsetBaseUrl: function ( path ) {\n\n\t\tconsole.warn( 'THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' );\n\n\t\tthis.setTexturePath( path );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tsetMaterialOptions: function ( value ) {\n\n\t\tthis.materialOptions = value;\n\n\t},\n\n\t/**\n\t * Parses a MTL file.\n\t *\n\t * @param {String} text - Content of MTL file\n\t * @return {THREE.MTLLoader.MaterialCreator}\n\t *\n\t * @see setPath setTexturePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setPath and/or setTexturePath explicitly prior to parse.\n\t */\n\tparse: function ( text ) {\n\n\t\tvar lines = text.split( '\\n' );\n\t\tvar info = {};\n\t\tvar delimiter_pattern = /\\s+/;\n\t\tvar materialsInfo = {};\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tvar line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\n\t\t\tvalue = value.trim();\n\n\t\t\tif ( key === 'newmtl' ) {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t} else if ( info ) {\n\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' ) {\n\n\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions );\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\tmaterialCreator.setManager( this.manager );\n\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\treturn materialCreator;\n\n\t}\n\n};\n\n/**\n * Create a new THREE-MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nTHREE.MTLLoader.MaterialCreator = function ( baseUrl, options ) {\n\n\tthis.baseUrl = baseUrl || '';\n\tthis.options = options;\n\tthis.materialsInfo = {};\n\tthis.materials = {};\n\tthis.materialsArray = [];\n\tthis.nameLookup = {};\n\n\tthis.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;\n\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;\n\n};\n\nTHREE.MTLLoader.MaterialCreator.prototype = {\n\n\tconstructor: THREE.MTLLoader.MaterialCreator,\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tsetManager: function ( value ) {\n\n\t\tthis.manager = value;\n\n\t},\n\n\tsetMaterials: function ( materialsInfo ) {\n\n\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t},\n\n\tconvert: function ( materialsInfo ) {\n\n\t\tif ( ! this.options ) return materialsInfo;\n\n\t\tvar converted = {};\n\n\t\tfor ( var mn in materialsInfo ) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\tvar covmat = {};\n\n\t\t\tconverted[ mn ] = covmat;\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar save = true;\n\t\t\t\tvar value = mat[ prop ];\n\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( save ) {\n\n\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn converted;\n\n\t},\n\n\tpreload: function () {\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.create( mn );\n\n\t\t}\n\n\t},\n\n\tgetIndex: function ( materialName ) {\n\n\t\treturn this.nameLookup[ materialName ];\n\n\t},\n\n\tgetAsArray: function () {\n\n\t\tvar index = 0;\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\tindex ++;\n\n\t\t}\n\n\t\treturn this.materialsArray;\n\n\t},\n\n\tcreate: function ( materialName ) {\n\n\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\tthis.createMaterial_( materialName );\n\n\t\t}\n\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tcreateMaterial_: function ( materialName ) {\n\n\t\t// Create material\n\n\t\tvar scope = this;\n\t\tvar mat = this.materialsInfo[ materialName ];\n\t\tvar params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfunction resolveURL( baseUrl, url ) {\n\n\t\t\tif ( typeof url !== 'string' || url === '' )\n\t\t\t\treturn '';\n\n\t\t\t// Absolute URL\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\n\n\t\t\treturn baseUrl + url;\n\n\t\t}\n\n\t\tfunction setMapForType( mapType, value ) {\n\n\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\n\n\t\t\tvar texParams = scope.getTextureParams( value, params );\n\t\t\tvar map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\n\n\t\t\tmap.repeat.copy( texParams.scale );\n\t\t\tmap.offset.copy( texParams.offset );\n\n\t\t\tmap.wrapS = scope.wrap;\n\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\tparams[ mapType ] = map;\n\n\t\t}\n\n\t\tfor ( var prop in mat ) {\n\n\t\t\tvar value = mat[ prop ];\n\n\t\t\tif ( value === '' ) continue;\n\n\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams.color = new THREE.Color().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams.specular = new THREE.Color().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tsetMapForType( \"map\", value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t// Specular map\n\n\t\t\t\t\tsetMapForType( \"specularMap\", value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tsetMapForType( \"bumpMap\", value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams.shininess = parseFloat( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\n\t\t\t\t\tif ( value < 1 ) {\n\n\t\t\t\t\t\tparams.opacity = value;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Tr':\n\n\t\t\t\t\tif ( value > 0 ) {\n\n\t\t\t\t\t\tparams.opacity = 1 - value;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.materials[ materialName ] = new THREE.MeshPhongMaterial( params );\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tgetTextureParams: function ( value, matParams ) {\n\n\t\tvar texParams = {\n\n\t\t\tscale: new THREE.Vector2( 1, 1 ),\n\t\t\toffset: new THREE.Vector2( 0, 0 )\n\n\t\t };\n\n\t\tvar items = value.split( /\\s+/ );\n\t\tvar pos;\n\n\t\tpos = items.indexOf( '-bm' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\n\t\t\titems.splice( pos, 2 );\n\n\t\t}\n\n\t\tpos = items.indexOf( '-s' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\tpos = items.indexOf( '-o' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\ttexParams.url = items.join( ' ' ).trim();\n\t\treturn texParams;\n\n\t},\n\n\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\n\n\t\tvar texture;\n\t\tvar loader = THREE.Loader.Handlers.get( url );\n\t\tvar manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = new THREE.TextureLoader( manager );\n\n\t\t}\n\n\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\t\ttexture = loader.load( url, onLoad, onProgress, onError );\n\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t}\n\n};\n","/**\n* KalmanFilter\n* @class\n* @author Wouter Bulten\n* @see {@link http://github.com/wouterbulten/kalmanjs}\n* @version Version: 1.0.0-beta\n* @copyright Copyright 2015 Wouter Bulten\n* @license GNU LESSER GENERAL PUBLIC LICENSE v3\n* @preserve\n*/\n\n\n\nfunction KalmanFilter(params) {\n\t/**\n\t* Create 1-dimensional kalman filter\n\t* @param  {Number} options.R Process noise\n\t* @param  {Number} options.Q Measurement noise\n\t* @param  {Number} options.A State vector\n\t* @param  {Number} options.B Control vector\n\t* @param  {Number} options.C Measurement vector\n\t* @return {KalmanFilter}\n\t*/\n\n\tthis.R = typeof params.R == \"undefined\" ? 1 : params.R; // noise power desirable\n\tthis.Q = typeof params.Q == \"undefined\" ? 1 : params.Q; // noise power estimated\n\n\tthis.A = typeof params.A == \"undefined\" ? 1 : params.A;\n\tthis.C = typeof params.C == \"undefined\" ? 1 : params.C;\n\tthis.B = typeof params.B == \"undefined\" ? 0 : params.B;\n\tthis.cov = NaN;\n\tthis.x = NaN; // estimated signal without noise\n}\n\n/**\n* Filter a new value\n* @param  {Number} z Measurement\n* @param  {Number} u Control\n* @return {Number}\n*/\nKalmanFilter.prototype.filter = function (z, u) {\n\tif (typeof u == \"undefined\")\n\t\tu = 0;\n\tif (isNaN(this.x)) {\n\t\tthis.x = (1 / this.C) * z;\n\t\tthis.cov = (1 / this.C) * this.Q * (1 / this.C);\n\t}\n\telse {\n\n\t\t// Compute prediction\n\t\tconst predX = (this.A * this.x) + (this.B * u);\n\t\tconst predCov = ((this.A * this.cov) * this.A) + this.R;\n\n\t\t// Kalman gain\n\t\tconst K = predCov * this.C * (1 / ((this.C * predCov * this.C) + this.Q));\n\n\t\t// Correction\n\t\tthis.x = predX + K * (z - (this.C * predX));\n\t\tthis.cov = predCov - (K * this.C * predCov);\n\t}\n\n\treturn this.x;\n}\n\n/**\n* Return the last filtered measurement\n* @return {Number}\n*/\nKalmanFilter.prototype.lastMeasurement = function () {\n\treturn this.x;\n}\n\n/**\n* Set measurement noise Q\n* @param {Number} noise\n*/\nKalmanFilter.prototype.setMeasurementNoise = function (noise) {\n\tthis.Q = noise;\n}\n\n/**\n* Set the process noise R\n* @param {Number} noise\n*/\nKalmanFilter.prototype.setProcessNoise = function (noise) {\n\tthis.R = noise;\n}\n\n","/*    Copyright 2017 Jocly\n *\n *    This program is free software: you can redistribute it and/or  modify\n *    it under the terms of the GNU Affero General Public License, version 3,\n *    as published by the Free Software Foundation.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU Affero General Public License for more details.\n *\n *    You should have received a copy of the GNU Affero General Public License\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *    As a special exception, the copyright holders give permission to link the\n *    code of portions of this program with the OpenSSL library under certain\n *    conditions as described in each individual source file and distribute\n *    linked combinations including the program with the OpenSSL library. You\n *    must comply with the GNU Affero General Public License in all respects\n *    for all of the code used other than as permitted herein. If you modify\n *    file(s) with this exception, you may extend this exception to your\n *    version of the file(s), but you are not obligated to do so. If you do not\n *    wish to do so, delete this exception statement from your version. If you\n *    delete this exception statement from all source files in the program,\n *    then also delete it in the license file.\n */\n\nJoclyAR = (function($) {\n\n    var running = false;\n    var videoElement = null;\n    var canvas, context;\n    var width = 320, height = 240;\n    var modelSize = 5;\n    var scale = .2;\n    var threeCtx = null;\n    var processing = false;\n    var arWorker = null;\n    var oposition = new THREE.Vector3();\n    var oeuler = new THREE.Euler();\n\n    function AnimationFrame() {\n        if(!running)\n            return;\n        if(!processing && videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {\n            processing = true;\n            context.drawImage(videoElement,0,0,width,height);\n            var imageData = context.getImageData(0, 0, width, height);\n            arWorker.postMessage({\n                type: \"Detect\",\n                imageData: imageData,\n                vwidth: videoElement.clientWidth,\n                vheight: videoElement.clientHeight\n            });\n        } else\n            requestAnimationFrame(AnimationFrame);\n    }\n\n    var mouseDownY = null, scale0 = scale;\n    function MouseMove(event) {\n        var y = event.clientY;\n        var ratio = (y-mouseDownY) / event.target.clientHeight;\n        scale = scale0 * (1 - ratio);\n        threeCtx.animControl.trigger();\n    }\n    function Mouse(event) {\n        switch(event.type) {\n            case 'mousedown':\n                if(event.button==1 || event.button==2) {\n                    mouseDownY = event.clientY;\n                    scale0 = scale;\n                    event.target.addEventListener('mousemove',MouseMove);\n                }\n                break;\n            case 'mouseup':\n            case 'mouseout':\n                event.target.removeEventListener('mousemove',MouseMove);\n        }\n    }\n\n    var exports = {\n        start: function() {\n            JoclyPlazza.webrtc.startLocal(true,{\n                video: {\n                    width: { ideal: width },\n                    height: { ideal: height },\n                    facingMode: \"environment\",\n                    frameRate: {ideal: 24 }\n                }\n            });\n        },\n        stop: function() {\n            JoclyPlazza.webrtc.setChannel(null);\n        },\n        attach: function(data) {\n            videoElement = data.element;\n            JoclyPlazza.webrtc.attachMediaStream(data.element,data.stream);\n            canvas = document.createElement(\"canvas\");\n            canvas.setAttribute(\"width\",width);\n            canvas.setAttribute(\"height\",height);\n            Object.assign(canvas.style,{\n                width: width,\n                height: height,\n                visibility : \"hidden\",\n                position: \"absolute\",\n                \"z-index\": -2,\n                top: 0,\n            });\n            document.body.appendChild(canvas);\n            /*\n            $(\"<canvas/>\")\n                .attr(\"width\", width).attr(\"height\",height)\n                .width(width).height(height)\n                .css({\n                    visibility : \"hidden\",\n                    position: \"absolute\",\n                    \"z-index\": -2,\n                    top: 0,\n            }).appendTo(\"body\");\n            */\n            context = canvas.getContext(\"2d\");\n            threeCtx = data.threeCtx;\n            running = true;\n            processing = false;\n            threeCtx.renderer.domElement.addEventListener(\"mousedown\",Mouse);\n            threeCtx.renderer.domElement.addEventListener(\"mouseup\",Mouse);\n            threeCtx.renderer.domElement.addEventListener(\"mouseout\",Mouse);\n\n       \t\tarWorker = new Worker(JoclyPlazza.config.baseURL+JoclyPlazza.config.joclyPath+'/jocly.arworker.js');\n            arWorker.onmessage = function(e) {\n                processing = false;\n                var message = e.data;\n                switch(message.type) {\n                    case \"Pose\": \n                        var rotation = message.rotation;\n                        var translation = message.translation;\n\n                        threeCtx.body.position.set(0,0,0);\n                        threeCtx.camera.lookAt(new THREE.Vector3(0,-1,0));\n\n                        threeCtx.harbor.scale.set(modelSize*scale,modelSize*scale,modelSize*scale);\n\n                        threeCtx.harbor.rotation.set(\n                            -Math.asin(-rotation[1][2]),\n                            Math.atan2(rotation[1][0], rotation[1][1]),\n                            -Math.atan2(rotation[0][2], rotation[2][2])                            \n                        );\n                        threeCtx.harbor.position.set(\n                            translation[0],\n                            -translation[2],\n                            -translation[1]                            \n                        );\n                        if(!threeCtx.harbor.position.equals(oposition) || \n                            !threeCtx.harbor.rotation.equals(oeuler))\n                            threeCtx.animControl.trigger();\n                        oposition.copy(threeCtx.harbor.position);\n                        oeuler.copy(threeCtx.harbor.rotation);\n                        break;\n                    case \"NoPose\":\n                        break;\n                }\n                setTimeout(AnimationFrame,20);\n            }\n            arWorker.postMessage({\n                type: \"Init\",\n                baseUrl: JoclyPlazza.config.baseURL+JoclyPlazza.config.joclyPath,\n                modelSize: modelSize,\n                width: width,\n                height: height\n            });\n            requestAnimationFrame(AnimationFrame);\n        },\n        detach: function(data) {\n            threeCtx.renderer.domElement.removeEventListener(\"mousedown\",Mouse);\n            threeCtx.renderer.domElement.removeEventListener(\"mouseup\",Mouse);\n            threeCtx.renderer.domElement.removeEventListener(\"mouseout\",Mouse);\n            JoclyPlazza.webrtc.detachMediaStream(data.element);\n            videoElement = null;\n            running = false;\n            canvas.parentNode.removeChild(canvas);\n            context = null;\n            threeCtx = null;\n            arWorker.terminate();\n            arWorker = null;\n        }\n    }\n\n    return exports;\n\n\n})();\n\n","/*    Copyright 2017 Jocly\n *\n *    This program is free software: you can redistribute it and/or  modify\n *    it under the terms of the GNU Affero General Public License, version 3,\n *    as published by the Free Software Foundation.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU Affero General Public License for more details.\n *\n *    You should have received a copy of the GNU Affero General Public License\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *    As a special exception, the copyright holders give permission to link the\n *    code of portions of this program with the OpenSSL library under certain\n *    conditions as described in each individual source file and distribute\n *    linked combinations including the program with the OpenSSL library. You\n *    must comply with the GNU Affero General Public License in all respects\n *    for all of the code used other than as permitted herein. If you modify\n *    file(s) with this exception, you may extend this exception to your\n *    version of the file(s), but you are not obligated to do so. If you do not\n *    wish to do so, delete this exception statement from your version. If you\n *    delete this exception statement from all source files in the program,\n *    then also delete it in the license file.\n */\n\nfunction JHStateMachine() {\n}\n\nJHStateMachine.prototype={}\n\nJHStateMachine.prototype.init=function() {\n\tthis.smState=null;\n\tthis.smStates={};\n\tthis.smEventQueue=[];\n\tthis.smScheduled=false;\n\tthis.smPauseNotified=false;\n\tthis.smPaused=true;\n\tthis.smHistory=[];\n\tthis.smGroups={};\n}\n\nJHStateMachine.prototype.smDebug=function() {}\nJHStateMachine.prototype.smWarning=function() {}\nJHStateMachine.prototype.smError=function() {}\n\nJHStateMachine.prototype.smTransition=function(states,events,newState,methods) {\n\tstates=this.smSolveStates(states);\n\tif(typeof(events)==\"string\") {\n\t\tevents=[events];\n\t}\n\tif(typeof(methods)==\"string\") {\n\t\tmethods=[methods];\n\t}\n\tfor(var s in states) {\n\t\tvar stateName=states[s];\n\t\tif(typeof(this.smStates[stateName])==\"undefined\") {\n\t\t\tthis.smStates[stateName]={\n\t\t\t\ttransitions: {},\n\t\t\t\tenteringMethods: [],\n\t\t\t\tleavingMethods: []\n\t\t\t}\n\t\t}\n\t\tfor(var e in events) {\n\t\t\tvar eventName=events[e];\n\t\t\tif(typeof(this.smStates[stateName].transitions[eventName])==\"undefined\") {\n\t\t\t\tthis.smStates[stateName].transitions[eventName]={\n\t\t\t\t\tstate: (newState!=null)?newState:stateName,\n\t\t\t\t\tmethods: []\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor(var m in methods) {\n\t\t\t\tvar methodName=methods[m];\n\t\t\t\tthis.smStates[stateName].transitions[eventName].methods.push(methodName);\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tif(newState!=null && typeof(this.smStates[newState])==\"undefined\") {\n\t\tthis.smStates[newState]={\n\t\t\ttransitions: {},\n\t\t\tenteringMethods: [],\n\t\t\tleavingMethods: []\t\t\t\t\n\t\t}\n\t}\n}\n\nJHStateMachine.prototype.smEntering=function(states,methods) {\n\tif(typeof(states)==\"string\") {\n\t\tstates=[states];\n\t}\n\tif(typeof(methods)==\"string\") {\n\t\tmethods=[methods];\n\t}\n\tfor(var s in states) {\n\t\tvar stateName=states[s];\n\t\tif(typeof(this.smStates[stateName])==\"undefined\") {\n\t\t\tthis.smStates[stateName]={\n\t\t\t\ttransitions: {},\n\t\t\t\tenteringMethods: [],\n\t\t\t\tleavingMethods: []\n\t\t\t}\n\t\t}\n\t\tfor(var m in methods) {\n\t\t\tvar methodName=methods[m];\n\t\t\tthis.smStates[stateName].enteringMethods.push(methodName);\t\t\t\t\n\t\t}\n\t}\n}\n\nJHStateMachine.prototype.smLeaving=function(states,methods) {\n\tif(typeof(states)==\"string\") {\n\t\tstates=[states];\n\t}\n\tif(typeof(methods)==\"string\") {\n\t\tmethods=[methods];\n\t}\n\tfor(var s in states) {\n\t\tvar stateName=states[s];\n\t\tif(typeof(this.smStates[stateName])==\"undefined\") {\n\t\t\tthis.smStates[stateName]={\n\t\t\t\ttransitions: {},\n\t\t\t\tenteringMethods: [],\n\t\t\t\tleavingMethods: []\n\t\t\t}\n\t\t}\n\t\tfor(var m in methods) {\n\t\t\tvar methodName=methods[m];\n\t\t\tthis.smStates[stateName].leavingMethods.push(methodName);\t\t\t\t\n\t\t}\n\t}\n}\n\nJHStateMachine.prototype.smStateGroup=function(group,states) {\n\tif(typeof(states)==\"string\")\n\t\tstates=[states];\n\tif(typeof(this.smGroups[group])==\"undefined\")\n\t\tthis.smGroups[group]=[];\n\tstates=this.smSolveStates(states);\n\tfor(var i in states) {\n\t\tvar state=states[i];\n\t\tif(!this.smContained(state,this.smGroups[group]))\n\t\t\tthis.smGroups[group].push(state);\n\t}\n}\n\nJHStateMachine.prototype.smSetInitialState=function(state) {\n\tthis.smState=state;\n}\n\nJHStateMachine.prototype.smGetState=function() {\n\treturn this.smState;\n}\n\nJHStateMachine.prototype.smHandleEvent=function(event,args) {\n\t\n\tif(typeof(this.smStates[this.smState])==\"undefined\") {\n\t\tconsole.error(\"Unknown state '\",this.smState,\"'\");\n\t\treturn;\n\t}\n\tvar hEntry={\n\t\t\tdate: new Date().getTime(),\n\t\t\tfromState: this.smState,\n\t\t\tevent: event,\n\t\t\tmethods: []\n\t}\n\ttry {\n\t\thEntry.args=JSON.stringify(args);\n\t} catch(e) {\n\t\t//console.error(\"handleEvent(event,...) JSON.stringify(args): \",e);\n\t}\n\t\n\tvar transition=this.smStates[this.smState].transitions[event];\n\tif(typeof(transition)==\"undefined\") {\n\t\tconsole.warn(\"JHStateMachine: Event '\",event,\"' not handled in state '\",this.smState,\"'\");\n\t\treturn;\n\t}\n\n\tthis.smCurrentEvent=event;\n\t\n\tvar stateChanged=(this.smState!=transition.state);\n\n\tif(stateChanged) {\n\t\tvar leavingMethods=this.smStates[this.smState].leavingMethods;\n\t\tfor(var i in leavingMethods) {\n\t\t\ttry {\n\t\t\t\thEntry.methods.push(leavingMethods[i]);\n\t\t\t\tif(typeof leavingMethods[i]==\"function\")\n\t\t\t\t\tleavingMethods[i].call(this,args);\n\t\t\t\telse\n\t\t\t\t\tthis['$'+leavingMethods[i]](args);\n\t\t\t} catch(e) {\n\t\t\t\tconsole.error(\"Exception in leaving [\",this.smState,\"] --> \"+\n\t\t\t\t\t\t(typeof leavingMethods[i]==\"function\"?leavingMethods[i].name:leavingMethods[i])\n\t\t\t\t+\"(\",args,\"): \",e);\n\t\t\t\tthrow e;\n\t\t\t}\t\t\n\t\t}\n\t}\n\t\n\tfor(var i in transition.methods) {\n\t\ttry {\n\t\t\thEntry.methods.push(transition.methods[i]);\n\t\t\tif(typeof transition.methods[i]==\"function\")\n\t\t\t\ttransition.methods[i].call(this,args);\n\t\t\telse\n\t\t\t\tthis['$'+transition.methods[i]](args);\n\t\t} catch(e) {\n\t\t\tconsole.error(\"Exception in [\"+this.smState+\"] -- \"+event+\" --> \"+\n\t\t\t\t\t(typeof transition.methods[i]==\"function\"?transition.methods[i].name:transition.methods[i])\n\t\t\t\t+\"(\",args,\"): \",\n\t\t\t\t\te);\n\t\t\tthrow e;\n\t\t}\n\t}\n\t\n\tthis.smJHStateMachineLeavingState(this.smState,event,args);\n\n\n\tthis.smDebug(\"{\",this.smState,\"} == [\",event,\"] ==> {\",transition.state,\"}\");\n\n\n\tthis.smState=transition.state;\n\n\tif(stateChanged) {\n\t\tvar enteringMethods=this.smStates[this.smState].enteringMethods;\n\t\tfor(var i in enteringMethods) {\n\t\t\ttry {\n\t\t\t\thEntry.methods.push(enteringMethods[i]);\n\t\t\t\tif(typeof enteringMethods[i]==\"function\")\n\t\t\t\t\tenteringMethods[i].call(this,args);\n\t\t\t\telse\n\t\t\t\t\tthis['$'+enteringMethods[i]](args);\n\t\t\t} catch(e) {\n\t\t\t\tconsole.error(\"Exception in entering [\"+this.smState+\"] --> \"+\n\t\t\t\t\t\t(typeof enteringMethods[i]==\"function\"?enteringMethods[i].name:enteringMethods[i])\n\t\t\t\t+\"(\",args,\"): \",e);\n\t\t\t\tthrow e;\n\t\t\t}\t\t\n\t\t}\n\t}\n\t\n\tthis.smCurrentEvent=null;\n\n\tthis.smJHStateMachineEnteringState(this.smState,event,args);\n\t\n\thEntry.toState=this.smState;\n\tthis.smHistory.splice(0,0,hEntry);\n\twhile(this.smHistory.length>50)\n\t\tthis.smHistory.pop();\t\n}\n\nJHStateMachine.prototype.smPlay=function() {\n\tvar $this=this;\n\tif(this.smPaused) {\n\t\tthis.smPaused=false;\n\t\tsetTimeout(function() {\n\t\t\t$this.smRun();\n\t\t},0);\n\t}\n}\n\nJHStateMachine.prototype.smPause=function() {\n\tthis.smPaused=true;\n}\n\nJHStateMachine.prototype.smStep=function() {\n\tthis.smPauseNotified=false;\n\tif(this.smEventQueue.length>0) {\n\t\tvar eventItem=this.smEventQueue.shift();\n\t\tthis.smHandleEvent(eventItem.event,eventItem.args);\n\t}\n\tthis.smNotifyPause();\n}\n\nJHStateMachine.prototype.smRun=function() {\n\tthis.smScheduled=false;\n\n\tvar stepCount=0;\n\twhile(this.smEventQueue.length>0) {\n\t\tif(this.smPaused) {\n\t\t\tthis.smRunEnd(stepCount);\n\t\t\treturn;\n\t\t} else {\n\t\t\tstepCount++;\n\t\t\tthis.smStep();\n\t\t}\n\t}\n\twhile(this.smPaused==false && this.smEventQueue.length>0) {\n\t\tstepCount++;\n\t\tthis.smStep();\n\t}\n\tthis.smRunEnd(stepCount);\n}\n\nJHStateMachine.prototype.smRunEnd=function() {\n}\n\nJHStateMachine.prototype.smQueueEvent=function(event,args) {\n\tvar self=this;\n\tthis.smEventQueue.push({event: event, args: args});\n\tthis.smNotifyPause();\n\tif(!this.smScheduled) {\n\t\tthis.smScheduled=true;\n\t\tsetTimeout(function() {\n\t\t\tself.smRun();\n\t\t},0);\n\t}\n}\n\nJHStateMachine.prototype.smNotifyPause=function() {\n\tif(this.smEventQueue.length>0 && this.smPaused==true) {\n\t\tvar item=this.smEventQueue[0];\n\t\tthis.smJHStateMachinePaused(item.event,item.args);\n\t}\n}\n\nJHStateMachine.prototype.smJHStateMachineEnteringState=function(state,event,args) {\n}\n\nJHStateMachine.prototype.smJHStateMachineLeavingState=function(state,event,args) {\n}\n\nJHStateMachine.prototype.smJHStateMachinePaused=function(state,event,args) {\n}\n\nJHStateMachine.prototype.smGetTable=function() {\n\tvar cells={}\n\tfor(var s in this.smStates) {\n\t\tvar state=this.smStates[s];\n\t\tfor(var e in state.transitions) {\n\t\t\tvar toState=state.transitions[e].state;\n\t\t\tvar cellname=s+\"/\"+toState;\n\t\t\tif(typeof(cells[cellname])==\"undefined\") {\n\t\t\t\tcells[cellname]={};\n\t\t\t}\n\t\t\tcells[cellname][e]=[];\n\t\t\tif(s!=toState) {\n\t\t\t\tfor(var m in state.leavingMethods) {\n\t\t\t\t\tcells[cellname][e].push(state.leavingMethods[m]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var m in state.transitions[e].methods) {\n\t\t\t\tcells[cellname][e].push(state.transitions[e].methods[m]);\n\t\t\t}\n\t\t\tif(s!=toState) {\n\t\t\t\tfor(var m in this.smStates[toState].enteringMethods) {\n\t\t\t\t\tcells[cellname][e].push(this.smStates[toState].enteringMethods[m]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvar table=[\"<table><tr><td></td>\"];\n\tfor(var s in this.smStates) {\n\t\ttable.push(\"<td class='state'>\"+s+\"</td>\");\n\t}\n\ttable.push(\"</tr>\");\n\tfor(var s1 in this.smStates) {\n\t\ttable.push(\"<tr><td class='state'>\"+s1+\"</td>\");\n\t\tvar state1=this.smStates[s1];\n\t\tfor(var s2 in this.smStates) {\n\t\t\tvar state2=this.smStates[s2];\n\t\t\tvar cellname=s1+\"/\"+s2;\n\t\t\tif(typeof(cells[cellname])==\"undefined\") {\n\t\t\t\ttable.push(\"<td class='empty'></td>\");\n\t\t\t} else {\n\t\t\t\ttable.push(\"<td class='transition'>\");\n\t\t\t\tfor(var e in cells[cellname]) {\n\t\t\t\t\ttable.push(\"<div class='event'>\");\n\t\t\t\t\ttable.push(\"<div class='eventname'>\"+e+\"</div>\");\n\t\t\t\t\tfor(var m in cells[cellname][e]) {\n\t\t\t\t\t\ttable.push(\"<div class='method'>\"+cells[cellname][e][m]+\"</div>\");\n\t\t\t\t\t}\n\t\t\t\t\ttable.push(\"</div>\");\n\t\t\t\t}\n\t\t\t\ttable.push(\"</td>\");\n\t\t\t}\n\t\t}\n\t\ttable.push(\"</tr>\");\n\t}\n\ttable.push(\"</table>\");\n\treturn table.join(\"\");\n}\n\nJHStateMachine.prototype.smGetHistoryTable=function() {\n\tvar table=[\"<table><tr><th>Date</th><th>To</th><th>Event</th><th>Methods</th><th>From</th></tr>\"];\n\tfor(var i in this.smHistory) {\n\t\tvar hEntry=this.smHistory[i];\n\t\ttable.push(\"<tr>\");\n\t\tvar date=new Date(hEntry.date);\n\t\tvar timestamp=date.getHours()+\":\"+date.getMinutes()+\":\"+date.getSeconds()+\".\"+date.getMilliseconds();\n\t\ttable.push(\"<td class='timestamp'>\"+timestamp+\"</td>\");\n\t\ttable.push(\"<td class='to'>\"+hEntry.toState+\"</td>\");\n\t\ttable.push(\"<td><div class='event'>\"+hEntry.event+\"</div><div class='args'>(\"+hEntry.args+\")</div></td>\");\n\t\ttable.push(\"<td class='methods'>\");\n\t\tfor(var j in hEntry.methods) {\n\t\t\ttable.push(hEntry.methods[j]+\"<br/>\");\n\t\t}\n\t\ttable.push(\"</td>\");\n\t\ttable.push(\"<td class='from'>\"+hEntry.fromState+\"</td>\");\n\t\ttable.push(\"</tr>\");\t\t\n\t}\n\ttable.push(\"</table>\");\n\treturn table.join(\"\");\n}\n\nJHStateMachine.prototype.smSolveStates=function(states) {\n\tvar states0=[];\n\tif(typeof(states)==\"string\") {\n\t\tstates=[states];\n\t}\n\tfor(var s in states) {\n\t\tvar state=states[s];\n\t\tif(typeof(this.smGroups[state])==\"undefined\") {\n\t\t\tif(!this.smContained(state,states0))\n\t\t\t\tstates0.push(state);\n\t\t} else {\n\t\t\tfor(var s0 in this.smGroups[state])\n\t\t\t\tif(!this.smContained(this.smGroups[state][s0]),states0)\n\t\t\t\t\tstates0.push(this.smGroups[state][s0]);\n\t\t}\n\t}\n\treturn states0;\n}\n\nJHStateMachine.prototype.smContained=function(state,group) {\n\tfor(var i in group) {\n\t\tif(state==group[i])\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nJHStateMachine.prototype.smCheck=function() {\n\tvar result={\n\t\tmissing: [],\n\t\tunused: []\n\t}\n\tvar existingFnt=[];\n\tfor(var s in this.smStates) {\n\t\tfor(var i in this.smStates[s].enteringMethods) {\n\t\t\tvar fnt=this.smStates[s].enteringMethods[i];\n\t\t\texistingFnt[fnt]=true;\n\t\t}\n\t\tfor(var i in this.smStates[s].leavingMethods) {\n\t\t\tvar fnt=this.smStates[s].leavingMethods[i];\n\t\t\texistingFnt[fnt]=true;\n\t\t}\n\t\tfor(var e in this.smStates[s].transitions) {\n\t\t\tvar event=this.smStates[s].transitions[e];\n\t\t\tfor(var i in event.methods) {\n\t\t\t\tvar fnt=event.methods[i];\n\t\t\t\texistingFnt[fnt]=true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(var fnt in existingFnt) {\n\t\tif(typeof(this['$'+fnt])!=\"function\") {\n\t\t\tresult.missing.push(fnt);\n\t\t\tconsole.error(\"JHStateMachine: missing function $\",fnt);\n\t\t}\n\t}\n\tfor(var k in this) {\n\t\ttry {\n\t\t\tif(k[0]=='$' && typeof(this[k])==\"function\") {\n\t\t\t\tvar fnt=k.substr(1);\n\t\t\t\tif(typeof(existingFnt[fnt])==\"undefined\") {\n\t\t\t\t\t//this.warning(\"JHStateMachine.check \"+this.target.name+\": unused function \"+k);\n\t\t\t\t\tresult.unused.push(fnt);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\treturn result;\n}\n","/*    Copyright 2017 Jocly\n *\n *    This program is free software: you can redistribute it and/or  modify\n *    it under the terms of the GNU Affero General Public License, version 3,\n *    as published by the Free Software Foundation.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU Affero General Public License for more details.\n *\n *    You should have received a copy of the GNU Affero General Public License\n *    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *    As a special exception, the copyright holders give permission to link the\n *    code of portions of this program with the OpenSSL library under certain\n *    conditions as described in each individual source file and distribute\n *    linked combinations including the program with the OpenSSL library. You\n *    must comply with the GNU Affero General Public License in all respects\n *    for all of the code used other than as permitted herein. If you modify\n *    file(s) with this exception, you may extend this exception to your\n *    version of the file(s), but you are not obligated to do so. If you do not\n *    wish to do so, delete this exception statement from your version. If you\n *    delete this exception statement from all source files in the program,\n *    then also delete it in the license file.\n */\n\nexports.view = View = {\n\tGame: {},\n\tBoard: {},\n};\n\nif (window.JoclyXdViewCleanup)\n\twindow.JoclyXdViewCleanup();\n\n(function () {\n\n\twindow.JoclyXdViewCleanup = function () {\n\t\tvar renderer = threeCtx && threeCtx.renderer;\n\t\tif (renderer) {\n\t\t\trenderer.forceContextLoss();\n\t\t\trenderer.context = null;\n\t\t\trenderer.domElement = null;\n\t\t\tdelete threeCtx.renderer;\n\t\t}\n\t\tif (arStream)\n\t\t\tAR(null);\n\t}\n\n\tvar area, currentSkin, logger, xdv, VSIZE, VHALF, htStateMachine, threeCtx = null,\n\t\tSCALE3D = 0.001, resourcesMap = {}, resources, arStream = null;\n\n\t// hack to ensure mouse and touch events do not collide\n\tvar lastTouchStart = 0, lastJoclyclick = 0;\n\n\t/* ======================================== */\n\n\tvar LOADING_TEXT_RESOURCE = \"\";\n\n\tif (typeof CustomEvent == \"undefined\") {\n\t\tfunction CustomEvent(event, params) {\n\t\t\tparams = params || { bubbles: false, cancelable: false };\n\t\t\tvar evt = document.createEvent('Event');\n\t\t\tevt.initEvent(event, params.bubbles, params.cancelable);\n\t\t\treturn evt;\n\t\t};\n\t\tCustomEvent.prototype = window.Event.prototype;\n\t\twindow.CustomEvent = CustomEvent;\n\t}\n\n\tvar Class = function () {\n\t};\n\t(function () {\n\t\tvar initializing = false, fnTest = /xyz/.test(function () {\n\t\t}) ? /\\b_super\\b/ : /.*/;\n\t\tClass.extend = function (prop) {\n\t\t\tvar _super = this.prototype;\n\t\t\tinitializing = true;\n\t\t\tvar prototype = new this();\n\t\t\tinitializing = false;\n\t\t\tfor (var name in prop) {\n\t\t\t\tprototype[name] = typeof prop[name] == \"function\"\n\t\t\t\t\t&& typeof _super[name] == \"function\"\n\t\t\t\t\t&& fnTest.test(prop[name]) ? (function (name, fn) {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tvar tmp = this._super;\n\t\t\t\t\t\t\tthis._super = _super[name];\n\t\t\t\t\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\t\t\t\t\tthis._super = tmp;\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t};\n\t\t\t\t\t})(name, prop[name]) : prop[name];\n\t\t\t}\n\t\t\tfunction Class(args) {\n\t\t\t\tif (!initializing && this.init)\n\t\t\t\t\tif (arguments.length > 0 && args.jBlocksArgsList)\n\t\t\t\t\t\tthis.init.apply(this, args);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.init.apply(this, arguments);\n\t\t\t}\n\t\t\tClass.prototype = prototype;\n\t\t\tClass.prototype.constructor = Class;\n\t\t\tClass.extend = arguments.callee;\n\t\t\treturn Class;\n\t\t};\n\t})();\n\n\t/* ======================================== */\n\n\tvar WebRTC;\n\tvar logResourcesLoad = false;\n\n\tfunction Log() {\n\t\tconsole.info.apply(console, arguments);\n\t}\n\n\tView.Board.Log = Log;\n\tView.Game.Log = Log;\n\n\tfunction HTStateMachine() { }\n\tHTStateMachine.prototype = new JHStateMachine();\n\n\tHTStateMachine.prototype.smError = function () {\n\t\t//console.info(\"=>\",arguments);\n\t}\n\tHTStateMachine.prototype.smWarning = function () {\n\t\t//console.info(\"=>\",arguments);\n\t};\n\tHTStateMachine.prototype.smDebug = function () {\n\t\t//console.info(\"=>\",arguments);\n\t}\n\n\tfunction Diff(oOld, oNew) {\n\t\tvar diff = {};\n\t\tvar diffSet = false;\n\t\tfor (var i in oNew) {\n\t\t\tif (oNew.hasOwnProperty(i)) {\n\t\t\t\tif (!oOld.hasOwnProperty(i)) {\n\t\t\t\t\tdiff[i] = oNew[i];\n\t\t\t\t\tdiffSet = true;\n\t\t\t\t} else if (typeof oNew[i] == \"object\") {\n\t\t\t\t\tvar diff0 = Diff(oOld[i], oNew[i]);\n\t\t\t\t\tif (diff0) {\n\t\t\t\t\t\tdiff[i] = diff0;\n\t\t\t\t\t\tdiffSet = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (oNew[i] != oOld[i]) {\n\t\t\t\t\tdiff[i] = oNew[i];\n\t\t\t\t\tdiffSet = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diffSet ? diff : null;\n\t}\n\n\tvar resLoadingMask = null;\n\tvar resLoadingCount = 0;\n\tfunction IncrementResLoading() {\n\t\tif (resLoadingCount++ == 0) {\n\t\t\tresLoadingMask = $(\".jocly-res-loading-mask\");\n\t\t\tif (resLoadingMask.length == 0)\n\t\t\t\tresLoadingMask = $(\"<div/>\").addClass(\"jocly-res-loading-mask\").css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\twidth: $(\"body\").width(),\n\t\t\t\t\theight: $(\"body\").height(),\n\t\t\t\t\t\"background-color\": \"rgba(0,0,0,.8)\",\n\t\t\t\t\t\"background-image\": \"url(\" + LOADING_TEXT_RESOURCE + \")\",\n\t\t\t\t\t\"background-position\": \"center center\",\n\t\t\t\t\t\"background-repeat\": \"no-repeat\",\n\t\t\t\t\t\"z-index\": 100000,\n\t\t\t\t}).appendTo($(\"body\"));\n\t\t\telse\n\t\t\t\tresLoadingMask.show();\n\t\t}\n\t}\n\tfunction DecrementResLoading() {\n\t\tif (--resLoadingCount == 0) {\n\t\t\tif (resLoadingMask)\n\t\t\t\tresLoadingMask.hide();\n\t\t}\n\t}\n\n\tvar materialMaps = {};\n\tfunction GetMaterialMap(map, callback) {\n\t\tvar $this = this;\n\t\tif (materialMaps[map])\n\t\t\tcallback(materialMaps[map]);\n\t\telse {\n\t\t\tvar loader = new THREE.TextureLoader();\n\t\t\tloader.setCrossOrigin(\"anonymous\");\n\t\t\tif (logResourcesLoad)\n\t\t\t\tconsole.log(\"Loading map\", map);\n\t\t\tIncrementResLoading();\n\t\t\tloader.load(\n\t\t\t\t// ressource url\n\t\t\t\tmap,\n\t\t\t\t// Function when resource is loaded\n\t\t\t\tfunction (texture) {\n\t\t\t\t\tmaterialMaps[map] = texture;\n\t\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\t\tconsole.log(\"Loaded\", map);\n\t\t\t\t\tDecrementResLoading();\n\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t\tcallback(materialMaps[map]);\n\t\t\t\t},\n\t\t\t\t// Function called when download progresses\n\t\t\t\tfunction (xhr) {\n\t\t\t\t\t//console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );\n\t\t\t\t},\n\t\t\t\t// Function called when download errors\n\t\t\t\tfunction (xhr) {\n\t\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\t\tconsole.log(\"(not) Loaded\", map);\n\t\t\t\t\tDecrementResLoading();\n\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t\tcallback(null);\n\t\t\t\t});\n\t\t}\n\t}\n\n\tvar pendingGetResource = [];\n\tfunction GetResource(res, callback) {\n\t\tvar resource = resources[res];\n\t\tif (resource === undefined) {\n\t\t\tresource = resources[res] = {\n\t\t\t\tpending: [callback],\n\t\t\t\tstatus: \"loading\",\n\t\t\t}\n\n\t\t\tvar getResFnt = null;\n\t\t\tvar m = /^(.*\\|)(.*?)$/.exec(res);\n\t\t\tif (m) {\n\t\t\t\tvar prefix = m[1];\n\t\t\t\tvar url = m[2];\n\t\t\t\tfor (var r in resourcesMap) {\n\t\t\t\t\tvar m2 = /^(.*\\|)(.*?)$/.exec(r);\n\t\t\t\t\tif (m2)\n\t\t\t\t\t\tif (prefix == m[1] && url.substr(-m2[2].length) == m2[2]) {\n\t\t\t\t\t\t\tgetResFnt = resourcesMap[r];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (/^image\\|/.test(res)) {\n\t\t\t\tvar imgSrc = /^image\\|(.*)/.exec(res)[1];\n\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\tconsole.log(\"Loading resource\", res);\n\t\t\t\tfunction HandleImage(image) {\n\t\t\t\t\tresource.image = image;\n\t\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\t\tconsole.log(\"Loaded\", res);\n\t\t\t\t\tresource.status = \"loaded\";\n\t\t\t\t\tresource.imgSrc = imgSrc;\n\t\t\t\t\tDecrementResLoading();\n\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\n\t\t\t\t\t\tresource.pending[i](resource.image, imgSrc);\n\t\t\t\t\tresource.pending = null;\n\t\t\t\t\tif (threeCtx)\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t}\n\t\t\t\tIncrementResLoading();\n\t\t\t\tif (getResFnt) {\n\t\t\t\t\tgetResFnt(function (data) {\n\t\t\t\t\t\tvar image = new Image();\n\t\t\t\t\t\timage.onload = function () {\n\t\t\t\t\t\t\tHandleImage(image);\n\t\t\t\t\t\t}\n\t\t\t\t\t\timage.src = data;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar image = new Image();\n\t\t\t\t\timage.onload = function () {\n\t\t\t\t\t\tHandleImage(image)\n\t\t\t\t\t}\n\t\t\t\t\timage.src = imgSrc;\n\t\t\t\t}\n\t\t\t} else if (/^smoothedfilegeo\\|/.test(res)) {\n\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\tconsole.log(\"Loading resource\", res);\n\t\t\t\tif (!threeCtx) {\n\t\t\t\t\tdelete resources[res];\n\t\t\t\t\tpendingGetResource.push([res, callback]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar m = /^smoothedfilegeo\\|([^\\|]*)\\|(.*)$/.exec(res);\n\t\t\t\tvar smooth = parseInt(m[1]);\n\t\t\t\tvar file = m[2];\n\t\t\t\tIncrementResLoading();\n\t\t\t\tfunction HandleGeoMat(geometry, materials) {\n\t\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\t\tconsole.log(\"Loaded\", res);\n\n\t\t\t\t\t// not sure of the side effects here but this removes the console\n\t\t\t\t\t// warnings \"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv\"\n\t\t\t\t\tfor (var i = 0; i < geometry.faceVertexUvs.length; i++) {\n\t\t\t\t\t\tfor (var j = 0; j < geometry.faceVertexUvs[i].length; j++) {\n\t\t\t\t\t\t\tvar uv = geometry.faceVertexUvs[i][j];\n\t\t\t\t\t\t\tif (uv === undefined)\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[i][j] = [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (; j < geometry.faces.length; j++)\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[i].push([{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (smooth > 0) {\n\t\t\t\t\t\tvar modifier = new THREE.SubdivisionModifier(smooth);\n\t\t\t\t\t\tmodifier.modify(geometry);\n\t\t\t\t\t}\n\t\t\t\t\tresource.status = \"loaded\";\n\t\t\t\t\tDecrementResLoading();\n\t\t\t\t\tresource.geometry = geometry;\n\t\t\t\t\tresource.materials = materials;\n\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\n\t\t\t\t\t\tresource.pending[i](geometry, materials);\n\t\t\t\t\tresource.pending = null;\n\t\t\t\t\tthreeCtx.animControl.trigger(3000);\n\t\t\t\t}\n\t\t\t\tif (getResFnt) {\n\t\t\t\t\tgetResFnt(function (data) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar parsed = threeCtx.loader.parse(JSON.parse(data));\n\t\t\t\t\t\t\tHandleGeoMat(parsed.geometry, parsed.materials);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdebugger;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else\n\t\t\t\t\tthreeCtx.loader.load(file, HandleGeoMat);\n\t\t\t} else if (/^json\\|/.test(res)) {\n\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\tconsole.log(\"Loading resource\", res);\n\t\t\t\tIncrementResLoading();\n\t\t\t\tvar url = /^json\\|(.*)/.exec(res)[1];\n\t\t\t\tfunction JSONResult(event, data) {\n\t\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\t\tconsole.log(\"Loaded\", res);\n\t\t\t\t\tvar path = /^(\\.)?(.*)$/.exec(url);\n\t\t\t\t\tif (data.url.substr(-path[2].length) == path[2]) {\n\t\t\t\t\t\t$(document).unbind(\"jocly.json-resource\", JSONResult);\n\t\t\t\t\t\tresource.status = \"loaded\";\n\t\t\t\t\t\tDecrementResLoading();\n\t\t\t\t\t\tresource.data = data.data;\n\t\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\n\t\t\t\t\t\t\tresource.pending[i](resource.data);\n\t\t\t\t\t\tresource.pending = null;\n\t\t\t\t\t\tif (threeCtx)\n\t\t\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t\t} else\n\t\t\t\t\t\tconsole.warn(\"Expecting\", url, \"got\", data.url)\n\n\t\t\t\t}\n\t\t\t\t$(document).bind(\"jocly.json-resource\", JSONResult);\n\t\t\t\t$(\"<script/>\").attr(\"type\", \"text/javascript\").attr(\"jocly-type\", \"json-resource\").attr(\"src\", url).appendTo($(\"head\"));\n\t\t\t} else if (/^json2\\|/.test(res)) {\n\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\tconsole.log(\"Loading resource\", res);\n\t\t\t\tIncrementResLoading();\n\t\t\t\tvar url = /^json2\\|(.*)/.exec(res)[1];\n\t\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\t\txhr.onreadystatechange = function () {\n\t\t\t\t\tif (xhr.readyState == XMLHttpRequest.DONE) {\n\t\t\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\t\t\tconsole.log(\"Loaded\", res);\n\t\t\t\t\t\tvar data = JSON.parse(xhr.responseText);\n\t\t\t\t\t\tresource.status = \"loaded\";\n\t\t\t\t\t\tDecrementResLoading();\n\t\t\t\t\t\tresource.data = data;\n\t\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\n\t\t\t\t\t\t\tresource.pending[i](resource.data);\n\t\t\t\t\t\tresource.pending = null;\n\t\t\t\t\t\tif (threeCtx)\n\t\t\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txhr.open('GET', url, true);\n\t\t\t\txhr.send(null);\n\n\t\t\t} else if (/^font\\|/.test(res)) {\n\t\t\t\tif (logResourcesLoad)\n\t\t\t\t\tconsole.info(\"font path\", fontPath);\n\t\t\t\tvar fontPath = /^font\\|(.*)/.exec(res)[1];\n\t\t\t\tIncrementResLoading();\n\t\t\t\tvar fontLoader = new THREE.FontLoader();\n\t\t\t\tfontLoader.load(fontPath, function (font) {\n\t\t\t\t\tDecrementResLoading();\n\t\t\t\t\tresource.status = \"loaded\";\n\t\t\t\t\tresource.font = font;\n\t\t\t\t\tfor (var i = 0; i < resource.pending.length; i++)\n\t\t\t\t\t\tresource.pending[i](font);\n\t\t\t\t\tresource.pending = null;\n\t\t\t\t\tif (threeCtx)\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (resource.status == \"loading\") {\n\t\t\tresource.pending.push(callback);\n\t\t} else {\n\t\t\tif (/^image\\|/.test(res)) {\n\t\t\t\tcallback(resource.image, resource.imgSrc);\n\t\t\t} else if (/^smoothedfilegeo\\|/.test(res)) {\n\t\t\t\tcallback(resource.geometry, resource.materials);\n\t\t\t} else if (/^json\\|/.test(res)) {\n\t\t\t\tcallback(resource.data);\n\t\t\t} else if (/^json2\\|/.test(res)) {\n\t\t\t\tcallback(resource.data);\n\t\t\t} else if (/^font\\|/.test(res)) {\n\t\t\t\tcallback(resource.font);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction ResumePendingResources() {\n\t\tif (threeCtx)\n\t\t\twhile (pendingGetResource.length) {\n\t\t\t\tvar call = pendingGetResource.shift();\n\t\t\t\tGetResource.call(null, call[0], call[1]);\n\t\t\t}\n\t}\n\n\n\t/* ======================================== */\n\n\tvar XDView = Class.extend({\n\t\tinit: function () {\n\t\t\tthis.gadgets = {};\n\t\t\tthis.resources = {};\n\t\t\tthis.game = null;\n\t\t\tthis.initDone = false;\n\t\t\tthis.ratio = 0;\n\t\t\tthis.center = null;\n\t\t\tthis.getMaterialMap = GetMaterialMap;\n\t\t},\n\t\tcreateGadget: function (id, options) {\n\t\t\tif (this.ratio > 0) {\n\t\t\t\tif (options.base === undefined)\n\t\t\t\t\toptions.base = {};\n\t\t\t\toptions.base.ratio = this.ratio;\n\t\t\t\toptions.base.center = this.center;\n\t\t\t}\n\t\t\tthis.gadgets[id] = new Gadget(id, options);\n\t\t},\n\t\tupdateGadget: function (id, options, delay, callback) {\n\t\t\tvar gadget = this.gadgets[id];\n\t\t\tif (gadget) {\n\t\t\t\tif (arguments.length < 3 || delay === undefined)\n\t\t\t\t\tdelay = 0;\n\t\t\t\tif (arguments.length < 4 || callback === undefined)\n\t\t\t\t\tcallback = function () { }\n\t\t\t\tgadget.update(options, delay, callback);\n\t\t\t}\n\t\t},\n\t\tremoveGadget: function (id) {\n\t\t\tvar gadget = this.gadgets[id];\n\t\t\tif (gadget) {\n\t\t\t\tgadget.unbuild();\n\t\t\t\tdelete this.gadgets[id];\n\t\t\t}\n\t\t},\n\t\tshowGadget: function (id) {\n\t\t\tthis.updateGadget(id, {\n\t\t\t\tbase: {\n\t\t\t\t\tvisible: true,\n\t\t\t\t},\n\t\t\t});\n\t\t},\n\t\thideGadget: function (id) {\n\t\t\tthis.updateGadget(id, {\n\t\t\t\tbase: {\n\t\t\t\t\tvisible: false,\n\t\t\t\t},\n\t\t\t});\n\t\t},\n\t\tupdateArea: function (ratio, center) {\n\t\t\tthis.ratio = ratio;\n\t\t\tthis.center = center;\n\t\t\tfor (var gi in this.gadgets)\n\t\t\t\tthis.gadgets[gi].update({\n\t\t\t\t\tbase: {\n\t\t\t\t\t\tratio: ratio,\n\t\t\t\t\t\tcenter: center,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t},\n\t\tredisplayGadgets: function () {\n\t\t\tfor (var gi in this.gadgets) {\n\t\t\t\tvar gadget = this.gadgets[gi];\n\t\t\t\tgadget.update({});\n\t\t\t}\n\t\t},\n\t\tunbuildGadgets: function () {\n\t\t\tfor (var gi in this.gadgets)\n\t\t\t\tthis.gadgets[gi].unbuild();\n\t\t},\n\t\tsaveGadgetProps: function (id, props, saveName) {\n\t\t\tvar gadget = this.gadgets[id];\n\t\t\tif (gadget)\n\t\t\t\tgadget.saveProps(props, saveName);\n\t\t},\n\t\trestoreGadgetProps: function (id, saveName, delay, callback) {\n\t\t\tvar gadget = this.gadgets[id];\n\t\t\tif (gadget)\n\t\t\t\tgadget.restoreProps(saveName, delay, callback);\n\t\t\telse if (callback)\n\t\t\t\tcallback();\n\t\t},\n\t\tlistScene: function () {\n\t\t\tconsole.log(\"listScene:\");\n\t\t\tvar accu = [];\n\t\t\taccu[\"faces\"] = 0;\n\t\t\t//var crlf=\"<br>\";\n\t\t\tvar crlf = \" :: \";\n\t\t\tvar output = \"========= Scene summary ===========\";\n\t\t\tvar nbLights = -1;\n\n\n\t\t\tfunction getFaces(obj, nbFaces) {\n\t\t\t\tif (obj.geometry) {\n\t\t\t\t\tvar gg = obj.geometry;\n\t\t\t\t\tif (gg.faces) nbFaces += gg.faces.length;\n\t\t\t\t}\n\t\t\t\tif (obj.getDescendants) {\n\t\t\t\t\tvar children = obj.getDescendants();\n\t\t\t\t\tif (children) nbFaces += getFaces(children, nbFaces);\n\t\t\t\t}\n\t\t\t\treturn nbFaces;\n\t\t\t}\n\t\t\tif (threeCtx) if (threeCtx.scene) {\n\t\t\t\tvar threeScene = threeCtx.scene;\n\t\t\t\tnbLights = threeScene.__lights.length;\n\t\t\t\tconsole.log(threeScene);\n\t\t\t\tvar obj = threeScene.getDescendants();\n\t\t\t\tfor (var o in obj) {\n\t\t\t\t\tvar nbf = getFaces(obj[o], 0);\n\t\t\t\t\taccu[\"faces\"] += nbf;\n\t\t\t\t\t//console.log(obj[o].name+\" has \"+nbf+\" faces\");\n\t\t\t\t\t/*if(obj[o].geometry){\n\t\t\t\t\t\tvar gg=obj[o].geometry;\n\t\t\t\t\t\tif (gg.faces) accu[\"faces\"]+=gg.faces.length;\n\t\t\t\t\t\tconsole.log(obj[o].name+\" has \"+gg.faces.length+\" faces\");\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput += crlf + \"nb lights: \" + nbLights;\n\t\t\toutput += crlf + \"Nb faces: \" + accu[\"faces\"];\n\t\t\tconsole.log(output);\n\t\t},\n\t})\n\n\t/* ======================================== */\n\n\tfunction InitGlobals() {\n\t\txdv = new XDView();\n\t\tVSIZE = 12600;\n\t\tVHALF = VSIZE / 2;\n\t\thtStateMachine = null;\n\t\tthreeCtx = null;\n\t\tSCALE3D = 0.001;\n\t\tresourcesMap = {};\n\t\tresources = {};\n\t\tarea = null;\n\t\tcurrentSkin = null;\n\t\tlogger = null;\n\t}\n\tInitGlobals();\n\n\t/* ======================================== */\n\n\tvar Gadget = Class.extend({\n\t\tinit: function (id, options) {\n\t\t\tthis.id = id;\n\t\t\tthis.options = $.extend(true, {\n\t\t\t\tbase: {\n\t\t\t\t\tvisible: false,\n\t\t\t\t}\n\t\t\t}, options);\n\t\t\tthis.avatar = null;\n\t\t\tthis.savedProps = {};\n\t\t},\n\t\tmergeOptions: function () {\n\t\t\treturn $.extend(true,\n\t\t\t\t{\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0,\n\t\t\t\t\tz: 0,\n\t\t\t\t},\n\t\t\t\tthis.options.base,\n\t\t\t\tcurrentSkin[\"3d\"] ? this.options[\"3d\"] : this.options[\"2d\"],\n\t\t\t\tthis.options[currentSkin.name]);\n\t\t},\n\t\tbuild: function (options) {\n\t\t\tif (this.avatar)\n\t\t\t\treturn;\n\t\t\tif (arguments.length == 0)\n\t\t\t\toptions = this.mergeOptions();\n\t\t},\n\t\tunbuild: function () {\n\t\t\tif (this.avatar) {\n\t\t\t\tthis.avatar.remove();\n\t\t\t\tthis.avatar = null;\n\t\t\t}\n\t\t},\n\t\tcanDisplay: function (options) {\n\t\t\tif (currentSkin === undefined || currentSkin === null)\n\t\t\t\treturn false;\n\t\t\tif (arguments.length == 0)\n\t\t\t\toptions = this.mergeOptions();\n\t\t\treturn options.visible &&\n\t\t\t\t((!currentSkin[\"3d\"] && options.ratio !== undefined && options.center !== undefined) ||\n\t\t\t\t\t(currentSkin[\"3d\"] /* && 3D requirements */));\n\t\t},\n\t\tupdate: function (options, delay, callback) {\n\t\t\tif (arguments.length < 2 || delay === undefined)\n\t\t\t\tdelay = 0;\n\t\t\tif (arguments.length < 3 || callback === undefined)\n\t\t\t\tcallback = function () { };\n\t\t\tif (currentSkin !== undefined && currentSkin !== null) {\n\t\t\t\tvar xdMap = currentSkin[\"3d\"] ? \"3d\" : \"2d\";\n\t\t\t\tif (options.base)\n\t\t\t\t\tfor (var i in options.base) {\n\t\t\t\t\t\tif (this.options[xdMap])\n\t\t\t\t\t\t\tdelete this.options[xdMap][i];\n\t\t\t\t\t\tif (this.options[currentSkin.name])\n\t\t\t\t\t\t\tdelete this.options[currentSkin.name][i];\n\t\t\t\t\t}\n\t\t\t\tif (options[xdMap])\n\t\t\t\t\tfor (var i in options[xdMap])\n\t\t\t\t\t\tif (this.options[currentSkin.name])\n\t\t\t\t\t\t\tdelete this.options[currentSkin.name][i];\n\t\t\t\t$.extend(true, this.options, options);\n\t\t\t\tvar aOptions = this.mergeOptions();\n\t\t\t\tif (!this.avatar && this.canDisplay(aOptions)) {\n\t\t\t\t\tvar avatarType = avatarTypes[aOptions.type];\n\t\t\t\t\tif (avatarType !== undefined)\n\t\t\t\t\t\tthis.avatar = new avatarType(this, aOptions);\n\t\t\t\t}\n\t\t\t\tif (typeof delay == \"object\") {\n\t\t\t\t\tif (delay[currentSkin.name] !== undefined)\n\t\t\t\t\t\tdelay = delay[currentSkin.name];\n\t\t\t\t\telse if (delay[xdMap] !== undefined)\n\t\t\t\t\t\tdelay = delay[xdMap];\n\t\t\t\t\telse if (delay.base !== undefined)\n\t\t\t\t\t\tdelay = delay.base;\n\t\t\t\t\telse\n\t\t\t\t\t\tdelay = 0;\n\t\t\t\t}\n\t\t\t\tif (this.avatar)\n\t\t\t\t\tthis.avatar.update(aOptions, delay, callback);\n\t\t\t} else\n\t\t\t\t$.extend(true, this.options, options);\n\t\t},\n\t\tsaveProps: function (props, saveName) {\n\t\t\tvar save = {};\n\t\t\tfor (var oi in this.options) {\n\t\t\t\tvar optCat = this.options[oi];\n\t\t\t\tfor (var i in props) {\n\t\t\t\t\tvar prop = props[i];\n\t\t\t\t\tif (optCat[prop] !== undefined) {\n\t\t\t\t\t\tsave[oi] = save[oi] || {};\n\t\t\t\t\t\tsave[oi][prop] = optCat[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.savedProps[saveName] = save;\n\t\t},\n\t\trestoreProps: function (saveName, delay, callback) {\n\t\t\tif (this.savedProps[saveName] !== undefined)\n\t\t\t\tthis.update(this.savedProps[saveName], delay, callback);\n\t\t\telse if (callback)\n\t\t\t\tcallback();\n\t\t},\n\t});\n\n\t/* ======================================== */\n\n\tvar updateOp = 1;\n\n\tvar GadgetAvatar = Class.extend({\n\t\tinit: function (gadget, options) {\n\t\t\tthis.gadget = gadget;\n\t\t\tthis.options = options;\n\t\t\tthis.SCALE3D = SCALE3D;\n\t\t\tthis.animCounts = {};\n\t\t},\n\t\tremove: function () {\n\t\t},\n\t\tdisplay: function (options) {\n\t\t},\n\t\tupdate: function (options, delay, callback) {\n\t\t\tvar aOptions = $.extend(true, {}, this.options, options);\n\t\t\taOptions.updateOp = updateOp++;\n\t\t\taOptions.updateCallback = callback;\n\t\t\tthis.display(aOptions, delay, callback);\n\t\t\tif (aOptions.visible)\n\t\t\t\tthis.show();\n\t\t\telse\n\t\t\t\tthis.hide();\n\t\t\tthis.options = aOptions;\n\t\t},\n\t\tshow: function () {\n\t\t},\n\t\thide: function () {\n\t\t},\n\t\tanimStart: function (options) {\n\t\t\tif (options === undefined) {\n\t\t\t\tconsole.error(\"animStart without options\");\n\t\t\t\tdebugger;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (options.updateOp === undefined) {\n\t\t\t\tconsole.error(\"animStart without options\");\n\t\t\t\tdebugger;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.object3d)\n\t\t\t\tthis.object3d.matrixAutoUpdate = true;\n\t\t\tif (this.animCounts[options.updateOp] === undefined)\n\t\t\t\tthis.animCounts[options.updateOp] = 1;\n\t\t\telse\n\t\t\t\tthis.animCounts[options.updateOp]++;\n\t\t},\n\t\tanimEnd: function (options) {\n\t\t\tif (options === undefined) {\n\t\t\t\tconsole.error(\"animEnd without options\");\n\t\t\t\tdebugger;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (options.updateOp === undefined) {\n\t\t\t\tconsole.error(\"animEnd without options\");\n\t\t\t\tdebugger;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.animCounts[options.updateOp] === undefined) {\n\t\t\t\tconsole.error(\"animEnd without animCount\");\n\t\t\t\tdebugger;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (--this.animCounts[options.updateOp] == 0) {\n\t\t\t\tif (this.object3d)\n\t\t\t\t\tthis.object3d.matrixAutoUpdate = false;\n\t\t\t\toptions.updateCallback();\n\t\t\t\tdelete this.animCounts[options.updateOp];\n\t\t\t}\n\t\t},\n\t\tgetResource: GetResource,\n\t});\n\n\tvar GadgetElement = GadgetAvatar.extend({\n\t\tinit: function (gadget, options) {\n\t\t\toptions = $.extend(true, {\n\t\t\t\tdisplay: function () { },\n\t\t\t}, options);\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.options = $.extend(true, {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tz: 0,\n\t\t\t\twidth: 1000,\n\t\t\t\theight: 1000,\n\t\t\t\ttag: \"div\",\n\t\t\t\topacity: 1,\n\t\t\t\trotate: 0,\n\t\t\t\tcss: {},\n\t\t\t}, options);\n\t\t\tthis.element = $(\"<\" + this.options.tag + \"/>\").css({\n\t\t\t\t\"position\": \"absolute\",\n\t\t\t\t\"z-index\": this.options.z,\n\t\t\t}).hide().addClass(\"jocly-gadget\").appendTo(area);\n\t\t\tif (this.options.initialClasses)\n\t\t\t\tthis.element.addClass(this.options.initialClasses);\n\t\t},\n\t\tdisplay: function (options, delay) {\n\t\t\tvar $this = this;\n\t\t\tif (this.element) {\n\t\t\t\tthis.displayElement.call(this, !this.displayCalled, options, delay);\n\t\t\t\tthis.displayCalled = true;\n\t\t\t} else if (delay) {\n\t\t\t\tthis.animStart(options);\n\t\t\t\tsetTimeout(function () { $this.animEnd(options); }, delay);\n\t\t\t}\n\t\t},\n\t\tdisplayElement: function (force, options, delay) {\n\t\t\tvar $this = this;\n\t\t\tthis.element.css($.extend(true, this.options.css, options.css));\n\t\t\tif (\n\t\t\t\tforce ||\n\t\t\t\tthis.aWidth === undefined || this.aHeight === undefined ||\n\t\t\t\toptions.ratio != this.options.ratio ||\n\t\t\t\toptions.center.x != this.options.center.x ||\n\t\t\t\toptions.center.y != this.options.center.y ||\n\t\t\t\toptions.width != this.options.width ||\n\t\t\t\toptions.height != this.options.height ||\n\t\t\t\toptions.x != this.options.x ||\n\t\t\t\toptions.y != this.options.y ||\n\t\t\t\toptions.z != this.options.z\n\t\t\t) {\n\t\t\t\tthis.aWidth = options.width * options.ratio;\n\t\t\t\tthis.aHeight = options.height * options.ratio;\n\t\t\t\tvar left = options.x * options.ratio + options.center.x - this.aWidth / 2;\n\t\t\t\tvar top = options.y * options.ratio + options.center.y - this.aHeight / 2;\n\t\t\t\tif (delay) {\n\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\tthis.element.css({\n\t\t\t\t\t\t\"z-index\": options.z,\n\t\t\t\t\t}).animate({\n\t\t\t\t\t\twidth: this.aWidth,\n\t\t\t\t\t\theight: this.aHeight,\n\t\t\t\t\t\tleft: left,\n\t\t\t\t\t\ttop: top,\n\t\t\t\t\t}, delay, function () { $this.animEnd(options); });\n\t\t\t\t} else {\n\t\t\t\t\tthis.element.css({\n\t\t\t\t\t\twidth: this.aWidth,\n\t\t\t\t\t\theight: this.aHeight,\n\t\t\t\t\t\tleft: left,\n\t\t\t\t\t\ttop: top,\n\t\t\t\t\t\t\"z-index\": options.z,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis.options.display(this.element, this.aWidth, this.aHeight);\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.classes != this.options.classes) {\n\t\t\t\tif (this.options.classes)\n\t\t\t\t\tthis.element.removeClass(this.options.classes);\n\t\t\t\tthis.element.addClass(options.classes);\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.click != this.options.click) {\n\t\t\t\t//this.element.unbind(JocGame.CLICK);\n\t\t\t\tthis.element.unbind(JocGame.MOUSEMOVE_EVENT);\n\t\t\t\tthis.element.unbind(JocGame.MOUSEDOWN_EVENT);\n\t\t\t\tthis.element.unbind(JocGame.MOUSEUP_EVENT);\n\t\t\t\tif (options.click) {\n\t\t\t\t\tvar iOS = (navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false);\n\t\t\t\t\t(function () {\n\t\t\t\t\t\tvar mouseDown = false;\n\t\t\t\t\t\tvar notified = false;\n\t\t\t\t\t\tvar downPosition = [0, 0];\n\t\t\t\t\t\t$this.element.bind(JocGame.MOUSEDOWN_EVENT, function (event) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tif (iOS && event.type == \"mousedown\")\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tif (event.type == \"touchstart\")\n\t\t\t\t\t\t\t\tlastTouchStart = Date.now();\n\t\t\t\t\t\t\tif (event.type == \"mousedown\" && Date.now() - lastTouchStart < 500)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tmouseDown = true;\n\t\t\t\t\t\t\tdownPosition = GetEventPosition(event);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t$this.element.bind(JocGame.MOUSEUP_EVENT, function (event) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tif (iOS && event.type == \"mouseup\")\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tmouseDown = false;\n\t\t\t\t\t\t\tif (event.type == \"joclyclick\")\n\t\t\t\t\t\t\t\tlastJoclyclick = Date.now();\n\t\t\t\t\t\t\tif (event.type == \"mouseup\" && Date.now() - lastJoclyclick < 500)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tif (event.type == 'mouseup' || event.type == 'joclyclick') {\n\t\t\t\t\t\t\t\toptions.click.call($this);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t\tvar newevent = new CustomEvent(\"joclyclick\", {});\n\t\t\t\t\t\t\t\tvar x, y;\n\t\t\t\t\t\t\t\tif (event.originalEvent.changedTouches && event.originalEvent.changedTouches.length > 0) {\n\t\t\t\t\t\t\t\t\tx = event.originalEvent.changedTouches[0].pageX;\n\t\t\t\t\t\t\t\t\ty = event.originalEvent.changedTouches[0].pageY;\n\t\t\t\t\t\t\t\t} else if (event.originalEvent.touches && event.originalEvent.touches.length > 0) {\n\t\t\t\t\t\t\t\t\tx = event.originalEvent.touches[0].pageX;\n\t\t\t\t\t\t\t\t\ty = event.originalEvent.touches[0].pageY;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconsole.warn(\"Invalid touch event\");\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar target = document.elementFromPoint(x, y);\n\t\t\t\t\t\t\t\ttarget.dispatchEvent(newevent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\t$this.element.bind(JocGame.MOUSEMOVE_EVENT, function (event) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tif (iOS && event.type == \"mousemove\")\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tif (mouseDown && !notified) {\n\t\t\t\t\t\t\t\tvar position = GetEventPosition(event);\n\t\t\t\t\t\t\t\tvar dx = position[0] - downPosition[0];\n\t\t\t\t\t\t\t\tvar dy = position[1] - downPosition[1];\n\t\t\t\t\t\t\t\tif (dx * dx + dy * dy > 100) {\n\t\t\t\t\t\t\t\t\tnotified = true;\n\t\t\t\t\t\t\t\t\toptions.click.call($this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})();\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tif(force ||\n\t\t\t\t\toptions.holdClick != this.options.holdClick) {\n\t\t\t\tthis.element.unbind(\"holdclick\");\n\t\t\t\tif(options.holdClick)\n\t\t\t\t\tthis.element.bind(\"holdclick\",options.holdClick);\n\t\t\t}\n\t\t\t*/\n\t\t\tif (force ||\n\t\t\t\toptions.rotate != this.options.rotate) {\n\t\t\t\twhile (options.rotate < 0)\n\t\t\t\t\toptions.rotate += 360;\n\t\t\t\toptions.rotate %= 360;\n\t\t\t\tvar rotate = options.rotate;\n\t\t\t\tvar rotate0 = this.options.rotate;\n\t\t\t\tif (rotate - this.options.rotate > 180)\n\t\t\t\t\trotate0 = 360;\n\t\t\t\telse if (this.options.rotate - rotate > 180)\n\t\t\t\t\trotate += 360;\n\t\t\t\tif (delay) {\n\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\t$({ deg: rotate0 }).animate({ deg: rotate }, {\n\t\t\t\t\t\tstep: function (now) {\n\t\t\t\t\t\t\t$this.element.css('transform', 'rotate(' + now + 'deg)');\n\t\t\t\t\t\t},\n\t\t\t\t\t\tduration: delay,\n\t\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else\n\t\t\t\t\tthis.element.css({\n\t\t\t\t\t\t\"transform\": \"rotate(\" + options.rotate + \"deg)\",\n\t\t\t\t\t});\n\t\t\t} else if (delay) {\n\t\t\t\tthis.animStart(options);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.opacity != this.options.opacity) {\n\t\t\t\tif (delay) {\n\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\tthis.element.stop().animate({\n\t\t\t\t\t\t\"opacity\": options.opacity,\n\t\t\t\t\t}, delay, function () { $this.animEnd(options); });\n\t\t\t\t} else\n\t\t\t\t\tthis.element.css({\n\t\t\t\t\t\t\"opacity\": options.opacity,\n\t\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tshow: function () {\n\t\t\tthis.element.show();\n\t\t},\n\t\thide: function () {\n\t\t\tthis.element.hide();\n\t\t},\n\t\tremove: function () {\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.element.unbind(JocGame.CLICK);\n\t\t\t//this.element.unbind(\"holdclick\");\n\t\t\tthis.element.remove();\n\t\t},\n\t});\n\n\tvar GadgetImage = GadgetElement.extend({\n\t\tdisplayElement: function (force, options) {\n\t\t\tvar $this = this;\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tif (force || this.options.file != options.file) {\n\t\t\t\tthis.options.file = options.file;\n\t\t\t\tGetResource(\"image|\" + options.file, function (image, imgSrc) {\n\t\t\t\t\tif (imgSrc == $this.options.file)\n\t\t\t\t\t\t$this.element.css({\n\t\t\t\t\t\t\t\"background-image\": \"url(\" + image.src + \")\",\n\t\t\t\t\t\t\t\"background-size\": \"100% 100%\",\n\t\t\t\t\t\t\t\"background-repeat\": \"no-repeat\",\n\t\t\t\t\t\t});\n\t\t\t\t\telse\n\t\t\t\t\t\tconsole.log(\"file has changed to\", $this.options.file, \"(\", imgSrc, \")\");\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t});\n\n\tvar GadgetCanvas = GadgetElement.extend({\n\t\tinit: function (gadget, options) {\n\t\t\toptions = $.extend({\n\t\t\t\ttag: \"canvas\",\n\t\t\t\tdraw: function () { },\n\t\t\t}, options);\n\t\t\tthis._super.call(this, gadget, options);\n\t\t\tthis.canvasContext = this.element[0].getContext(\"2d\");\n\t\t},\n\t\tdisplayElement: function (force, options) {\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.element.attr(\"width\", this.aWidth).attr(\"height\", this.aHeight);\n\t\t\t//this.canvasContext.save();\n\t\t\tthis.canvasContext.clearRect(0, 0, options.width, options.height);\n\t\t\tthis.canvasContext.translate(this.aWidth / 2, this.aHeight / 2);\n\t\t\tthis.canvasContext.scale(options.ratio, options.ratio);\n\t\t\tthis.options.draw.call(this, this.canvasContext, 1 / options.ratio);\n\t\t\t//this.canvasContext.restore();\n\t\t}\n\t});\n\n\tvar GadgetHexagon = GadgetCanvas.extend({\n\t\tinit: function (gadget, options) {\n\t\t\tvar $this = this;\n\t\t\tvar R = options.radius;\n\t\t\tvar L = R * Math.sqrt(3) / 2;\n\t\t\toptions = $.extend({\n\t\t\t\tlineWidthFactor: 1,\n\t\t\t}, options, {\n\t\t\t\t\tdraw: function (ctx, pixSize) {\n\t\t\t\t\t\tctx.lineWidth = pixSize * $this.options.lineWidthFactor;\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo(-L, L / 2);\n\t\t\t\t\t\tctx.lineTo(0, R);\n\t\t\t\t\t\tctx.lineTo(L, L / 2);\n\t\t\t\t\t\tctx.lineTo(L, -L / 2);\n\t\t\t\t\t\tctx.lineTo(0, -R);\n\t\t\t\t\t\tctx.lineTo(-L, -L / 2);\n\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\tif ($this.options.strokeStyle) {\n\t\t\t\t\t\t\tctx.strokeStyle = $this.options.strokeStyle;\n\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($this.options.fillStyle) {\n\t\t\t\t\t\t\tctx.fillStyle = $this.options.fillStyle;\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\tthis._super.call(this, gadget, options);\n\t\t\tthis.element.attr(\"width\", options.width).attr(\"height\", options.height);\n\t\t\tthis.canvasContext = this.element[0].getContext(\"2d\");\n\t\t},\n\t});\n\n\t/*\n\tvar GadgetSprite=GadgetCanvas.extend({\n\t\tinit: function(gadget,options) {\n\t\t\tthis._super.apply(this,arguments);\n\t\t\tthis.displayArgs=null;\n\t\t},\n\t\tdisplayElement: function(force,options) {\n\t\t\tvar $this=this;\n\t\t\tthis._super.apply(this,arguments);\n\t\t\tif(force || this.options.file!=options.file) {\n\t\t\t\tGetResource(\"image|\"+options.file, function(image) {\n\t\t\t\t\t$this.image=image;\n\t\t\t\t\tif($this.displayArgs && $this.options.clipx!==undefined && $this.options.clipy!==undefined && \n\t\t\t\t\t\t\t$this.options.clipwidth!==undefined && $this.options.clipheight!==undefined)\n\t\t\t\t\t\t$this.drawImage.apply($this,$this.displayArgs);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif(force || this.options.clipx!=options.clipx\n\t\t\t\t\t|| this.options.clipy!=options.clipy\n\t\t\t\t\t|| this.options.clipwidth!=options.clipwidth\n\t\t\t\t\t|| this.options.clipheight!=options.clipheight\n\t\t\t\t\t) {\n\t\t\t\tif(this.image && options.clipx!==undefined && options.clipy!==undefined && \n\t\t\t\t\t\toptions.clipwidth!==undefined && options.clipheight!==undefined) {\n\t\t\t\t\tthis.drawImage.call(this,force,options);\n\t\t\t\t} else \n\t\t\t\t\tthis.displayArgs=arguments;\n\t\t\t}\n\t\t\tif(this.image && options.clipx!==undefined && options.clipy!==undefined && \n\t\t\t\t\toptions.clipwidth!==undefined && options.clipheight!==undefined)\n\t\t\t\tthis.drawImage.apply(this,arguments);\n\t\t\telse\n\t\t\t\tthis.displayArgs=arguments;\n\t\t},\n\t\tdrawImage: function(force,options) {\n\t\t\tthis.canvasContext.save();\n\t\t\tvar x0=parseInt(options.clipx+.5);\n\t\t\tvar y0=parseInt(options.clipy+.5);\n\t\t\tvar cx0=parseInt(options.clipwidth+.5);\n\t\t\tvar cy0=parseInt(options.clipheight+.5);\n\t\t\tvar x1=0;\n\t\t\tvar y1=0;\n\t\t\tvar cx1=parseInt(this.aWidth+.5);\n\t\t\tvar cy1=parseInt(this.aHeight+.5);\n\t\t\t\n\t\t\tthis.canvasContext.scale(cx1,cy1);\n\t\t\tthis.canvasContext.imageSmoothingEnabled=true;\n        \t\n\t\t\tthis.canvasContext.drawImage(this.image,x0,y0,cx0,cy0,x1,y1,1,1);\n\t\t\t//this.canvasContext.drawImage(this.image,x0,y0,cx0,cy0,x1,y1,cx1,cy1);\n\t\t\tthis.canvasContext.restore();\n\t\t\tthis.displayArgs=null;\n\t\t},\n\t});\n\t*/\n\n\tvar GadgetSprite = GadgetCanvas.extend({\n\t\tinit: function (gadget, options) {\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.displayArgs = null;\n\t\t},\n\t\tdisplayElement: function (force, options) {\n\t\t\tvar $this = this;\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tif (force || this.options.file != options.file) {\n\t\t\t\tGetResource(\"image|\" + options.file, function (image, imgSrc) {\n\t\t\t\t\tif (imgSrc == $this.options.file) {\n\t\t\t\t\t\t$this.image = image;\n\t\t\t\t\t\t$this.element.css({\n\t\t\t\t\t\t\t\"background-image\": \"url(\" + image.src + \")\",\n\t\t\t\t\t\t\t\"background-size\": \"100% 100%\",\n\t\t\t\t\t\t\t\"background-repeat\": \"no-repeat\",\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif ($this.displayArgs && $this.options.clipx !== undefined && $this.options.clipy !== undefined &&\n\t\t\t\t\t\t$this.options.clipwidth !== undefined && $this.options.clipheight !== undefined)\n\t\t\t\t\t\t$this.drawImage.apply($this, $this.displayArgs);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (force || this.options.clipx != options.clipx\n\t\t\t\t|| this.options.clipy != options.clipy\n\t\t\t\t|| this.options.clipwidth != options.clipwidth\n\t\t\t\t|| this.options.clipheight != options.clipheight\n\t\t\t) {\n\t\t\t\tif (this.image && options.clipx !== undefined && options.clipy !== undefined &&\n\t\t\t\t\toptions.clipwidth !== undefined && options.clipheight !== undefined) {\n\t\t\t\t\tthis.drawImage.call(this, force, options);\n\t\t\t\t} else\n\t\t\t\t\tthis.displayArgs = arguments;\n\t\t\t}\n\t\t\tif (this.image && options.clipx !== undefined && options.clipy !== undefined &&\n\t\t\t\toptions.clipwidth !== undefined && options.clipheight !== undefined)\n\t\t\t\tthis.drawImage.apply(this, arguments);\n\t\t\telse\n\t\t\t\tthis.displayArgs = arguments;\n\t\t},\n\t\tdrawImage: function (force, options) {\n\t\t\tvar rx = (options.clipwidth / this.aWidth);\n\t\t\tvar ry = (options.clipheight / this.aHeight);\n\t\t\tvar bcx = parseInt(this.image.width / rx + .5);\n\t\t\tvar bcy = parseInt(this.image.height / ry + .5);\n\t\t\tvar bs = \"\" + bcx + \"px \" + bcy + \"px\";\n\t\t\tthis.element.css({\n\t\t\t\t\"width\": parseInt(this.aWidth + .5),\n\t\t\t\t\"height\": parseInt(this.aHeight + .5),\n\t\t\t\t\"background-image\": options.file,\n\t\t\t\t\"background-size\": bs,\n\t\t\t\t\"background-position\": \"-\" + (parseInt(options.clipx / rx + .5)) + \"px -\" + (parseInt(options.clipy / ry + .5)) + \"px\",\n\t\t\t});\n\t\t},\n\t});\n\n\tvar GadgetDisk = GadgetElement.extend({\n\t\tinit: function (gadget, options) {\n\t\t\tthis._super.apply(this, arguments);\n\t\t},\n\t\tdisplayElement: function (force, options) {\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.element.css({\n\t\t\t\t\"border-radius\": \"50%\",\n\t\t\t});\n\t\t},\n\t});\n\n\tvar GadgetObject3D = GadgetAvatar.extend({\n\t\tinit: function (gadget, options) {\n\t\t\tvar $this = this;\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.displayCalled = false;\n\t\t\tthis.options = $.extend(true, {\n\t\t\t\tx: 0.0,\n\t\t\t\ty: 0.0,\n\t\t\t\tz: 0.0,\n\t\t\t\tcolor: null,\n\t\t\t\tcastShadow: true,\n\t\t\t\treceiveShadow: false,\n\t\t\t\tharbor: true,\n\t\t\t}, options);\n\t\t\tthis.createObject();\n\t\t},\n\t\tcreateObject: function () {\n\t\t},\n\t\tobjectReady: function (object3d) {\n\t\t\tvar $this = this;\n\t\t\tthis.object3d = object3d;\n\t\t\tobject3d.castShadow = this.options.castShadow;\n\t\t\tobject3d.receiveShadow = this.options.receiveShadow;\n\t\t\tobject3d.name = this.gadget.id;\n\t\t\tobject3d.matrixAutoUpdate = false;\n\t\t\tthis.shouldUpdate = true;\n\t\t\tthis.update(this.options);\n\t\t\t//object3d.visible=this.options.visible;\n\t\t\tif (this.options.harbor)\n\t\t\t\tthreeCtx.harbor.add(object3d);\n\t\t\telse\n\t\t\t\tthreeCtx.scene.add(object3d);\n\t\t},\n\t\tdisplay: function (options, delay) {\n\t\t\tvar $this = this;\n\t\t\tif (this.object3d) {\n\t\t\t\tthis.shouldUpdate = false;\n\t\t\t\tthis.displayObject3D.call(this, !this.displayCalled, options, delay);\n\t\t\t\tthis.displayCalled = true;\n\t\t\t\tif (this.shouldUpdate)\n\t\t\t\t\tthis.object3d.updateMatrix();\n\t\t\t}\n\t\t\tif (delay) {\n\t\t\t\t$this.animStart(options);\n\t\t\t\tsetTimeout(function () { $this.animEnd(options); }, delay);\n\t\t\t}\n\t\t},\n\t\tdisplayObject3D: function (force, options, delay) {\n\t\t\tvar $this = this;\n\t\t\tthreeCtx.animControl.trigger((isNaN(delay) ? 0 : delay) + 200);\n\t\t\tif (force ||\n\t\t\t\toptions.x != this.options.x ||\n\t\t\t\toptions.y != this.options.y ||\n\t\t\t\toptions.z != this.options.z\n\t\t\t) {\n\t\t\t\tthis.shouldUpdate = true;\n\t\t\t\tif (delay) {\n\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\tnew TWEEN.Tween(this.object3d.position).to({\n\t\t\t\t\t\tx: options.x * SCALE3D,\n\t\t\t\t\t\ty: options.z * SCALE3D,\n\t\t\t\t\t\tz: options.y * SCALE3D,\n\t\t\t\t\t}, delay).easing(options.positionEasing ? options.positionEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\n\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t}).onUpdate(function (ratio) {\n\t\t\t\t\t\tif (options.positionEasingUpdate)\n\t\t\t\t\t\t\toptions.positionEasingUpdate.call($this, ratio);\n\t\t\t\t\t}).start();\n\t\t\t\t} else {\n\t\t\t\t\tthis.object3d.position.x = options.x * SCALE3D;\n\t\t\t\t\tthis.object3d.position.y = options.z * SCALE3D;\n\t\t\t\t\tthis.object3d.position.z = options.y * SCALE3D;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.click != this.options.click) {\n\t\t\t\tif (this.options.click)\n\t\t\t\t\tthis.object3d.off(\"mouseup\");\n\t\t\t\tif (options.click) {\n\t\t\t\t\t//if(!threeCtx.cameraControls.hasBeenDragged())\n\t\t\t\t\tthis.object3d.on(\"mouseup\", function () {\n\t\t\t\t\t\t//if(!threeCtx.cameraControls.hasBeenDragged())\n\t\t\t\t\t\toptions.click.call();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tif(force || \n\t\t\t\t\toptions.holdClick != this.options.holdClick) {\n\t\t\t\tif(this.options.holdClick)\n\t\t\t\t\tthis.object3d.off(\"holdclick\");\n\t\t\t\tif(options.holdClick) {\n\t\t\t\t\t//if(!threeCtx.cameraControls.hasBeenDragged())\n\t\t\t\t\t\tthis.object3d.on(\"holdclick\",function(eventData){\n\t\t\t\t\t\t\tif(!threeCtx.cameraControls.hasBeenDragged())\n\t\t\t\t\t\t\t\toptions.holdClick.call($this,eventData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\tif (force ||\n\t\t\t\toptions.castShadow != this.options.castShadow) {\n\t\t\t\tthis.object3d.castShadow = options.castShadow\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.receiveShadow != this.options.receiveShadow) {\n\t\t\t\tthis.object3d.receiveShadow = options.receiveShadow\n\t\t\t}\n\t\t},\n\t\tshow: function () {\n\t\t\tif (arStream && !this.options.harbor)\n\t\t\t\treturn this.hide();\n\t\t\tif (this.object3d) {\n\t\t\t\tthis.object3d.visible = true;\n\t\t\t\tif (this.object3d.children) {\n\t\t\t\t\tfor (var c = 0; c < this.object3d.children.length; c++) {\n\t\t\t\t\t\tvar part = this.object3d.children[c];\n\t\t\t\t\t\tif (part.joclyVisible === undefined || part.joclyVisible)\n\t\t\t\t\t\t\tpart.visible = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpart.visible = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thide: function () {\n\t\t\tif (this.object3d) {\n\t\t\t\tthis.object3d.visible = false;\n\t\t\t\tif (this.object3d.children) {\n\t\t\t\t\tfor (var c = 0; c < this.object3d.children.length; c++)\n\t\t\t\t\t\tthis.object3d.children[c].visible = false;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tremove: function () {\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tif (this.object3d) {\n\t\t\t\tif (this.options.click)\n\t\t\t\t\tthis.object3d.off(\"mouseup\");\n\t\t\t\t/*\n\t\t\t\tif(this.options.holdClick)\n\t\t\t\t\tthis.object3d.off(\"holdclick\");\n\t\t\t\t*/\n\t\t\t\tif (this.object3d.parent)\n\t\t\t\t\tthis.object3d.parent.remove(this.object3d);\n\t\t\t\tthis.object3d = null;\n\t\t\t}\n\t\t},\n\t\tgetMaterialMap: GetMaterialMap,\n\t});\n\n\tvar GadgetMesh = GadgetObject3D.extend({\n\t\tinit: function (gadget, options) {\n\t\t\toptions = $.extend(true, {\n\t\t\t\trotate: 0,\n\t\t\t\trotateX: 0,\n\t\t\t\trotateY: 0,\n\t\t\t\tscale: [1, 1, 1],\n\t\t\t\tmaterials: {},\n\t\t\t\tsmooth: 0,\n\t\t\t\topacity: 1,\n\t\t\t\tflatShading: false,\n\t\t\t\tmorphing: [],\n\t\t\t}, options, {\n\t\t\t\t});\n\t\t\tthis._super.call(this, gadget, options);\n\t\t},\n\t\tdisplayObject3D: function (force, options, delay) {\n\t\t\tvar $this = this;\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tif (force ||\n\t\t\t\toptions.rotate != this.options.rotate ||\n\t\t\t\toptions.rotateX != this.options.rotateX ||\n\t\t\t\toptions.rotateY != this.options.rotateY\n\t\t\t) {\n\t\t\t\tthis.shouldUpdate = true;\n\t\t\t\tvar delta = options.rotate - this.options.rotate;\n\t\t\t\tif (delta > 180)\n\t\t\t\t\toptions.rotate -= 360;\n\t\t\t\telse if (delta < -180)\n\t\t\t\t\toptions.rotate += 360;\n\t\t\t\tdelta = options.rotateX - this.options.rotateX;\n\t\t\t\tif (delta > 180)\n\t\t\t\t\toptions.rotateX -= 360;\n\t\t\t\telse if (delta < -180)\n\t\t\t\t\toptions.rotateX += 360;\n\t\t\t\tdelta = options.rotateY - this.options.rotateY;\n\t\t\t\tif (delta > 180)\n\t\t\t\t\toptions.rotateY -= 360;\n\t\t\t\telse if (delta < -180)\n\t\t\t\t\toptions.rotateY += 360;\n\t\t\t\tif (delay) {\n\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\tnew TWEEN.Tween(this.object3d.rotation).to({\n\t\t\t\t\t\tx: options.rotateX * (Math.PI / 180),\n\t\t\t\t\t\ty: options.rotate * (Math.PI / 180),\n\t\t\t\t\t\tz: options.rotateY * (Math.PI / 180),\n\t\t\t\t\t}, delay).easing(options.rotateEasing ? options.rotateEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\n\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t}).start();\n\t\t\t\t} else {\n\t\t\t\t\tthis.object3d.rotation.x = options.rotateX * (Math.PI / 180);\n\t\t\t\t\tthis.object3d.rotation.y = options.rotate * (Math.PI / 180);\n\t\t\t\t\tthis.object3d.rotation.z = options.rotateY * (Math.PI / 180);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.scale[0] != this.options.scale[0] ||\n\t\t\t\toptions.scale[1] != this.options.scale[1] ||\n\t\t\t\toptions.scale[2] != this.options.scale[2]\n\t\t\t) {\n\t\t\t\tthis.shouldUpdate = true;\n\t\t\t\tif (delay) {\n\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\tnew TWEEN.Tween(this.object3d.scale).to({\n\t\t\t\t\t\tx: options.scale[0],\n\t\t\t\t\t\ty: options.scale[2],\n\t\t\t\t\t\tz: options.scale[1],\n\t\t\t\t\t}, delay).easing(options.scaleEasing ? options.scaleEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\n\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t}).start();\n\t\t\t\t} else {\n\t\t\t\t\tthis.object3d.scale.set(options.scale[0], options.scale[2], options.scale[1]);\n\t\t\t\t\t/*if ((options.scale[0] > 0) &&\n\t\t\t\t\t\t(options.scale[1] > 0) &&\n\t\t\t\t\t\t(options.scale[2] > 0)\n\t\t\t\t\t)\n\t\t\t\t\t\tthis.object3d.scale.set(options.scale[0],options.scale[2],options.scale[1]);\n\t\t\t\t\telse{\n\t\t\t\t\t\tvar g=this.object3d.geometry;\n\t\t\t\t\t\tg.dynamic = true;\n\t\t\t\t\t\tfor(var i = 0; i<g.faces.length; i++) {\n\t\t\t\t\t\t    g.faces[i].normal.x = -1*g.faces[i].normal.x;\n\t\t\t\t\t\t    g.faces[i].normal.y = -1*g.faces[i].normal.y;\n\t\t\t\t\t\t    g.faces[i].normal.z = -1*g.faces[i].normal.z;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tg.computeVertexNormals();\n\t\t\t\t\t\tg.computeFaceNormals();\n\t\t\t\t\t\tg.applyMatrix(new THREE.Matrix4().makeScale( options.scale[0], options.scale[2], options.scale[1] ) );\t\t\t\t\t\t\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.color != this.options.color\n\t\t\t) {\n\t\t\t\tif (this.object3d.material && this.object3d.material.color !== undefined)\n\t\t\t\t\tif (options.color !== null)\n\t\t\t\t\t\tthis.object3d.material.color.setHex(options.color);\n\n\t\t\t\t/*\n\t\t\t\t\t\t\t\t\tif(options.color===null)\n\t\t\t\t\t\t\t\t\t\tthis.object3d.material.color.setHex(0xffffff);\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\t\tthis.object3d.material.color.setHex(options.color);\n\t\t\t\t*/\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.opacity != this.options.opacity\n\t\t\t) {\n\t\t\t\tif (this.object3d.material && this.object3d.material.opacity !== undefined) {\n\t\t\t\t\tif (options.opacity === null)\n\t\t\t\t\t\toptions.opacity = 1;\n\t\t\t\t\tif (delay) {\n\t\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\t\tnew TWEEN.Tween(this.object3d.material).to({\n\t\t\t\t\t\t\topacity: options.opacity,\n\t\t\t\t\t\t}, delay).easing(options.opacityEasing ? options.opacityEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\n\t\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t\t}).start();\n\t\t\t\t\t} else\n\t\t\t\t\t\tthis.object3d.material.opacity = options.opacity;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force ||\n\t\t\t\toptions.morphing.toString() != this.options.morphing.toString()\n\t\t\t) {\n\t\t\t\tthis.shouldUpdate = true;\n\t\t\t\tif (options.morphing.length > 0) {\n\t\t\t\t\tif (this.object3d.material && this.object3d.material.materials &&\n\t\t\t\t\t\tthis.object3d.material.materials.length > 0 && !this.object3d.material.materials[0].morphTargets) {\n\t\t\t\t\t\tfor (var i = 0; i < this.object3d.material.materials.length; i++)\n\t\t\t\t\t\t\tthis.object3d.material.materials[i].morphTargets = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (delay) {\n\t\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\t\tnew TWEEN.Tween(this.object3d.morphTargetInfluences).to(options.morphing,\n\t\t\t\t\t\t\tdelay).easing(options.morphingEasing ? options.morphingEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\n\t\t\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t\t\t}).start();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (var i = 0; i < options.morphing.length && i < this.object3d.morphTargetInfluences.length; i++)\n\t\t\t\t\t\t\tthis.object3d.morphTargetInfluences[i] = options.morphing[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.object3d.material && options.materials) {\n\t\t\t\tif (force) {\n\t\t\t\t\tif (this.object3d.material.materials) {\n\t\t\t\t\t\tfor (var m in this.object3d.material.materials) {\n\t\t\t\t\t\t\tvar mat = $this.object3d.material.materials[m];\n\t\t\t\t\t\t\tif (options.materials[mat.name]) {\n\t\t\t\t\t\t\t\tfor (var mpi in options.materials[mat.name]) {\n\t\t\t\t\t\t\t\t\tvar newMatProp = options.materials[mat.name][mpi];\n\t\t\t\t\t\t\t\t\t(function (mat, mpi) {\n\t\t\t\t\t\t\t\t\t\tif (mpi == \"map\") {\n\t\t\t\t\t\t\t\t\t\t\tGetMaterialMap(newMatProp, function (matMpi) {\n\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = matMpi;\n\t\t\t\t\t\t\t\t\t\t\t\tmat.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t} else if (mpi == \"color\") {\n\t\t\t\t\t\t\t\t\t\t\tif (typeof mat[\"ambient\"] != \"undefined\")\n\t\t\t\t\t\t\t\t\t\t\t\tmat[\"ambient\"].setHex(newMatProp);\n\t\t\t\t\t\t\t\t\t\t\tmat[mpi].setHex(newMatProp);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = newMatProp;\n\t\t\t\t\t\t\t\t\t})(mat, mpi, m);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar diffMat = Diff(this.options.materials, options.materials);\n\t\t\t\t\tif (diffMat) {\n\t\t\t\t\t\tfor (var mi in diffMat) {\n\t\t\t\t\t\t\tvar newMat = diffMat[mi];\n\t\t\t\t\t\t\tif (this.object3d.material.materials) {\n\t\t\t\t\t\t\t\tfor (var m in this.object3d.material.materials) {\n\t\t\t\t\t\t\t\t\tvar mat = $this.object3d.material.materials[m];\n\t\t\t\t\t\t\t\t\tif (mat.name == mi) {\n\t\t\t\t\t\t\t\t\t\tif (newMat) {\n\t\t\t\t\t\t\t\t\t\t\tfor (var mpi in newMat) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar newMatProp = newMat[mpi];\n\t\t\t\t\t\t\t\t\t\t\t\tif (newMatProp !== null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t(function (mat, mpi) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mpi == \"map\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGetMaterialMap(newMatProp, function (matMpi) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = matMpi;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse if (mpi == \"color\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (typeof mat[\"ambient\"] != \"undefined\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[\"ambient\"].setHex(newMatProp);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi].setHex(newMatProp);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (delay) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$this.animStart(options);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mat[mpi] === undefined || isNaN(newMatProp)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = newMatProp;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar change = {};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchange[mpi] = newMatProp;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew TWEEN.Tween(mat).to(change, delay).easing(options.materialEasing ? options.materialEasing :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}).start();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmat[mpi] = newMatProp;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t})(mat, mpi);\n\t\t\t\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\t\t\t\tdelete mat[mpi];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdelete mat.map;\n\t\t\t\t\t\t\t\t\t\t\tdelete mat.opacity;\n\t\t\t\t\t\t\t\t\t\t\tdelete mat.color;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n\n\tvar GadgetCustomMesh3D = GadgetMesh.extend({\n\t\tinit: function (gadget, options) {\n\t\t\toptions = $.extend(true, {\n\t\t\t\tcreate: function () { return null },\n\t\t\t\tdisplay: function () { },\n\t\t\t}, options, {\n\t\t\t\t});\n\t\t\tthis._super.call(this, gadget, options);\n\t\t},\n\t\tcreateObject: function () {\n\t\t\tvar $this = this;\n\t\t\tfunction Callback(object3d) {\n\t\t\t\t$this.objectReady(object3d);\n\t\t\t}\n\t\t\tvar object3d = this.options.create.call(this, Callback);\n\t\t\tif (object3d)\n\t\t\t\tthis.objectReady(object3d);\n\t\t},\n\t\tdisplayObject3D: function (force, options, delay) {\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.options.display.call(this, force, options, delay);\n\t\t},\n\t\treplaceMesh: function (mesh, options, delay) {\n\t\t\tif (this.object3d) {\n\t\t\t\tif (this.options.click)\n\t\t\t\t\tthis.object3d.off(\"mouseup\");\n\t\t\t\t/*\n\t\t\t\tif(this.options.holdClick)\n\t\t\t\t\tthis.object3d.off(\"holdclick\");\n\t\t\t\t*/\n\t\t\t\tif (this.object3d.parent)\n\t\t\t\t\tthis.object3d.parent.remove(this.object3d);\n\t\t\t}\n\t\t\tthis.object3d = mesh;\n\t\t\tif (this.options.visible)\n\t\t\t\tthis.show();\n\t\t\telse\n\t\t\t\tthis.hide();\n\t\t\tif (this.options.harbor)\n\t\t\t\tthreeCtx.harbor.add(this.object3d);\n\t\t\telse\n\t\t\t\tthreeCtx.scene.add(this.object3d);\n\t\t\tif (delay) {\n\t\t\t\tthis.displayObject3D(true, this.options);\n\t\t\t\tthis.displayObject3D(true, options, delay);\n\t\t\t} else\n\t\t\t\tthis.displayObject3D(true, options);\n\t\t},\n\t});\n\n\tvar GadgetPlane3D = GadgetMesh.extend({\n\t\tinit: function (gadget, options) {\n\t\t\toptions = $.extend(true, {\n\t\t\t\tdisplay: function () { },\n\t\t\t\tsx: 1000,\n\t\t\t\tsy: 1000,\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\thorizontal: true,\n\t\t\t\ttexture: null,\n\t\t\t\tmaterial: \"basic\",\n\t\t\t\tside: null,\n\n\t\t\t}, options, {\n\t\t\t\t});\n\t\t\tthis._super.call(this, gadget, options);\n\t\t},\n\t\tcreateObject: function () {\n\t\t\tvar gg = new THREE.PlaneGeometry(this.options.sx * SCALE3D, this.options.sy * SCALE3D, 1, 1);\n\t\t\tvar matData = {\n\t\t\t\tcolor: this.options.data,\n\t\t\t\topacity: 0,\n\t\t\t}\n\t\t\tif (this.options.texture) {\n\t\t\t\tvar tOptions = this.options.texture;\n\t\t\t\tif (tOptions.file) {\n\t\t\t\t\tGetMaterialMap(tOptions.file, function (texture) {\n\t\t\t\t\t\tif (tOptions.wrapS !== undefined)\n\t\t\t\t\t\t\ttexture.wrapS = tOptions.wrapS;\n\t\t\t\t\t\tif (tOptions.wrapT !== undefined)\n\t\t\t\t\t\t\ttexture.wrapT = tOptions.wrapT;\n\t\t\t\t\t\tif (tOptions.repeat)\n\t\t\t\t\t\t\ttexture.repeat.set.apply(texture.repeat, tOptions.repeat);\n\t\t\t\t\t\tmatData.map = texture;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.side !== undefined)\n\t\t\t\tmatData.side = this.options.side;\n\t\t\tif (this.options.transparent !== undefined)\n\t\t\t\tmatData.transparent = this.options.transparent;\n\t\t\tvar gm;\n\t\t\tswitch (this.options.material) {\n\t\t\t\tcase \"phong\":\n\t\t\t\t\tgm = new THREE.MeshPhongMaterial(matData);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgm = new THREE.MeshBasicMaterial(matData);\n\t\t\t}\n\t\t\tvar mesh = new THREE.Mesh(gg, gm);\n\t\t\tthis.objectReady(mesh);\n\t\t},\n\t});\n\n\t// should this class be obsoleted in favor of GadgetCustomMesh3D\n\tvar GadgetCustom3D = GadgetObject3D.extend({\n\t\tinit: function (gadget, options) {\n\t\t\toptions = $.extend(true, {\n\t\t\t\tcreate: function () { return null },\n\t\t\t\tdisplay: function () { },\n\t\t\t}, options, {\n\t\t\t\t});\n\t\t\tthis._super.call(this, gadget, options);\n\t\t},\n\t\tcreateObject: function () {\n\t\t\tvar $this = this;\n\t\t\tfunction Callback(object3d) {\n\t\t\t\t$this.objectReady(object3d);\n\t\t\t}\n\t\t\tvar object3d = this.options.create.call(this, Callback);\n\t\t\tif (object3d)\n\t\t\t\tthis.objectReady(object3d);\n\t\t},\n\t\tdisplayObject3D: function (force, options, delay) {\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.options.display.call(this, force, options, delay);\n\t\t},\n\t});\n\n\tvar GadgetMeshFile = GadgetMesh.extend({\n\t\tinit: function (gadget, options) {\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tthis.meshFileForceDisplay = false;\n\t\t},\n\t\tcreateObject: function () {\n\t\t\tvar $this = this;\n\t\t\tvar file = this.options.file;\n\t\t\tvar smooth = this.options.smooth;\n\t\t\tGetResource(\"smoothedfilegeo|\" + this.options.smooth + \"|\" + file, function (geometry, materials) {\n\t\t\t\tif (file != $this.options.file)\n\t\t\t\t\treturn;\n\t\t\t\tvar materials0 = []\n\t\t\t\tfor (var i = 0; i < materials.length; i++)\n\t\t\t\t\tmaterials0.push(materials[i].clone());\n\t\t\t\tmaterials = materials0;\n\t\t\t\tif ($this.options.flatShading)\n\t\t\t\t\tfor (var m = 0; m < materials.length; m++) {\n\t\t\t\t\t\tmaterials[m].shading = THREE.FlatShading;\n\t\t\t\t\t}\n\t\t\t\tvar mesh = new THREE.Mesh(geometry, new THREE.MultiMaterial(materials));\n\t\t\t\t$this.objectReady(mesh);\n\t\t\t\tif ($this.meshFileForceDisplay) {\n\t\t\t\t\t$this.displayObject3D(true, $this.meshFileForceDisplay);\n\t\t\t\t\t$this.meshFileForceDisplay = false;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdisplayObject3D: function (force, options, delay) {\n\t\t\tvar fileChange = (options.file != this.options.file);\n\t\t\tif (fileChange) {\n\t\t\t\toptions.click = null;\n\t\t\t\t//options.holdClick=null;\n\t\t\t}\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tif (fileChange) {\n\t\t\t\tif (this.object3d) {\n\t\t\t\t\tif (this.options.click)\n\t\t\t\t\t\tthis.object3d.off(\"mouseup\");\n\t\t\t\t\t/*\n\t\t\t\t\tif(this.options.holdClick)\n\t\t\t\t\t\tthis.object3d.off(\"holdclick\");\n\t\t\t\t\t*/\n\t\t\t\t\tif (this.object3d.parent)\n\t\t\t\t\t\tthis.object3d.parent.remove(this.object3d);\n\t\t\t\t\tthis.object3d = null;\n\t\t\t\t}\n\t\t\t\tthis.options.file = options.file;\n\t\t\t\tthis.meshFileForceDisplay = options;\n\t\t\t\tthis.createObject();\n\t\t\t}\n\t\t},\n\t});\n\n\tvar Gadget3DVideo = GadgetMesh.extend({\n\t\tinit: function (gadget, options) {\n\t\t\toptions = $.extend(true, {\n\t\t\t\tscale: [1, 1, 1],\n\t\t\t\tplayerSide: 1,\n\t\t\t\tmakeMesh: function (videoTexture, ccvVideoTexture) {\n\t\t\t\t\tvar material = new THREE.MeshBasicMaterial({\n\t\t\t\t\t\tmap: videoTexture,\n\t\t\t\t\t\toverdraw: true,\n\t\t\t\t\t\t// side:THREE.DoubleSide\n\t\t\t\t\t});\n\t\t\t\t\tvar geometry = new THREE.PlaneGeometry(12, 9, 1, 1);\n\t\t\t\t\tvar mesh = new THREE.Mesh(geometry, material);\n\n\t\t\t\t\treturn mesh;\n\t\t\t\t},\n\t\t\t\tvideoPlaying: function (on) {\n\t\t\t\t},\n\t\t\t\tccvLocked: function (on) {\n\t\t\t\t},\n\t\t\t\tccv: false,\n\t\t\t\tccvMargin: [.10, .10, .30, .10],\n\t\t\t\tccvWidth: 80,\n\t\t\t\tccvHeight: 60,\n\t\t\t\thideBeforeFirstLock: true,\n\t\t\t}, options);\n\t\t\tthis._super.call(this, gadget, options);\n\t\t\tthis.videoConnected = false;\n\t\t\tthis.videoErrorCount = 0;\n\t\t\tthis.videoSkipError = false;\n\t\t\tthis.shouldBeVisible = false;\n\t\t\tthis.gotFirstLock = false;\n\t\t},\n\t\tobjectReady: function (mesh) {\n\t\t\tmesh.visible = false;\n\t\t\tfor (var i = 0; i < mesh.children.length; i++)\n\t\t\t\tmesh.children[i].visible = false;\n\t\t\tthis.streamReady(Gadget3DVideo.isStreamReady(this.options.playerSide));\n\t\t\tthis._super.apply(this, arguments);\n\t\t},\n\t\tcreateObject: function () {\n\t\t\tGadget3DVideo.addAvatar(this, this.options.playerSide);\n\t\t\tvar ccvTexture = null;\n\t\t\tif (this.ccvContextKey)\n\t\t\t\tccvTexture = Gadget3DVideo.getCCVVideoTexture(this.options.playerSide, this.ccvContextKey)\n\t\t\tvar mesh = this.options.makeMesh.call(this,\n\t\t\t\tGadget3DVideo.getVideoTexture(this.options.playerSide), ccvTexture);\n\t\t\tif (mesh)\n\t\t\t\tthis.objectReady(mesh);\n\t\t},\n\t\tremove: function () {\n\t\t\tGadget3DVideo.removeAvatar(this, this.options.playerSide);\n\t\t\tthis._super.apply(this, arguments);\n\t\t},\n\t\tshow: function () {\n\t\t\tthis.shouldBeVisible = true;\n\t\t\tif (this.videoConnected && (this.options.ccv == false || this.gotFirstLock || !this.options.hideBeforeFirstLock))\n\t\t\t\tthis._super();\n\t\t},\n\t\thide: function () {\n\t\t\tthis.shouldBeVisible = false;\n\t\t\tthis._super();\n\t\t},\n\t\tstreamReady: function (on) {\n\t\t\tthis.videoConnected = on;\n\t\t\tif (on)\n\t\t\t\tthis.show();\n\t\t\telse\n\t\t\t\tthis.hide();\n\t\t},\n\t\tccvLocked: function (locked) {\n\t\t\tif (locked && this.shouldBeVisible) {\n\t\t\t\tthis.gotFirstLock = true;\n\t\t\t\tthis.show();\n\t\t\t}\n\t\t\tthis.options.ccvLocked(locked);\n\t\t},\n\t});\n\n\tGadget3DVideo.streams = {};\n\tGadget3DVideo.avatars = { \"1\": [], \"-1\": [] };\n\tGadget3DVideo.textures = { \"1\": null, \"-1\": null };\n\tGadget3DVideo.renderLoopHooked = false;\n\tGadget3DVideo.ccvLibRequested = false;\n\tGadget3DVideo.getStream = function (playerSide) {\n\t\tif (!this.streams[playerSide]) {\n\t\t\tvar vStream = {\n\t\t\t\tstream: null,\n\t\t\t\tavatars: this.avatars[playerSide],\n\t\t\t\tvideo: null,\n\t\t\t\tvideoImage: null,\n\t\t\t\tvideoContext: null,\n\t\t\t\tvideoTexture: null,\n\t\t\t\tstreamReady: false,\n\t\t\t\townVideoElement: false,\n\t\t\t\terrorCount: 0,\n\t\t\t\tloopCount: 0,\n\t\t\t\tlocal: false,\n\t\t\t\tccvVideoImage: null,\n\t\t\t\tccvInProgress: false,\n\t\t\t\tccvLock: null,\n\t\t\t\tccvContexts: {},\n\t\t\t\tccvLastAnalyzed: null,\n\t\t\t\tccvLastSuccess: null,\n\t\t\t}\n\t\t\tvar video = $(\"video[joclyhub-video='\" + playerSide + \"']\");\n\t\t\tif (video.length > 0) {\n\t\t\t\tvStream.video = video;\n\t\t\t} else {\n\t\t\t\tvStream.ownVideoElement = true;\n\t\t\t\tvStream.video = $(\"<video/>\").attr(\"autoplay\", \"autoplay\").width(\n\t\t\t\t\t160).height(120).css({\n\t\t\t\t\t\tvisibility: \"hidden\",\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\t\"z-index\": -1,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t}).attr(\"joclyhub-video\", playerSide).appendTo(\"body\");\n\t\t\t}\n\t\t\tvar canvas = $(\"canvas[joclyhub-video-canvas='\" + playerSide + \"']\");\n\t\t\tif (canvas.length > 0) {\n\t\t\t\tvStream.videoImage = canvas;\n\t\t\t\tif (this.textures[playerSide])\n\t\t\t\t\tvStream.videoTexture = this.textures[playerSide];\n\t\t\t\telse {\n\t\t\t\t\tvStream.videoTexture = new THREE.Texture(vStream.videoImage[0]);\n\t\t\t\t\tthis.textures[playerSide] = vStream.videoTexture;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvStream.videoImage = this.makeCanvas(160, 120).attr(\"joclyhub-video-canvas\", playerSide);\n\t\t\t\tvStream.videoTexture = new THREE.Texture(vStream.videoImage[0]);\n\t\t\t\tthis.textures[playerSide] = vStream.videoTexture;\n\t\t\t}\n\t\t\tvStream.videoTexture.minFilter = THREE.LinearFilter;\n\t\t\tvStream.videoTexture.magFilter = THREE.LinearFilter;\n\t\t\tvStream.videoImageContext = vStream.videoImage[0].getContext('2d');\n\t\t\tthis.streams[playerSide] = vStream;\n\t\t}\n\t\treturn this.streams[playerSide];\n\t}\n\tGadget3DVideo.addStream = function (playerSide, stream, local) {\n\t\tvar $this = this;\n\t\tvar vStream = this.getStream(playerSide);\n\t\tvStream.stream = stream;\n\t\tvStream.local = local;\n\t\tif (threeCtx)\n\t\t\tthreeCtx.animControl.trigger(3000);\n\t\tif (!this.renderLoopHooked) {\n\t\t\tthis.renderLoopHooked = true;\n\t\t\tif (threeCtx)\n\t\t\t\tthreeCtx.animateCallbacks[\"Gadget3DVideo\"] = {\n\t\t\t\t\t_this: $this,\n\t\t\t\t\tcallback: $this.animate,\n\t\t\t\t}\n\t\t}\n\t}\n\tGadget3DVideo.removeStream = function (playerSide) {\n\t\tvar vStream = this.streams[playerSide];\n\t\tif (vStream) {\n\t\t\tif (vStream.streamReady)\n\t\t\t\tfor (var i = 0; i < vStream.avatars.length; i++)\n\t\t\t\t\tvStream.avatars[i].streamReady(false);\n\t\t\tif (vStream.ccvLastSuccess)\n\t\t\t\tvStream.ccvLastSuccess.videoImage.remove();\n\t\t\tif (vStream.ccvLastAnalyzed)\n\t\t\t\tvStream.ccvLastAnalyzed.remove();\n\t\t\tdelete this.streams[playerSide];\n\t\t\tif (this.renderLoopHooked) {\n\t\t\t\tvar streamCount = 0;\n\t\t\t\tfor (var s in this.streams)\n\t\t\t\t\tstreamCount++;\n\t\t\t\tif (streamCount == 0) {\n\t\t\t\t\tif (threeCtx)\n\t\t\t\t\t\tdelete threeCtx.animateCallbacks[\"Gadget3DVideo\"];\n\t\t\t\t\tthis.renderLoopHooked = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tGadget3DVideo.addAvatar = function (avatar, playerSide) {\n\t\tthis.avatars[playerSide].push(avatar);\n\t\tvar vStream = this.getStream(playerSide);\n\t\tif (!avatar.ccvContextKey)\n\t\t\tavatar.ccvContextKey = \"\" + avatar.options.ccvWidth + \",\" + avatar.options.ccvHeight + \",\" + JSON.stringify(avatar.options.ccvMargin);\n\t\tif (!vStream.ccvContexts[avatar.ccvContextKey]) {\n\t\t\tvar ccvContext = {\n\t\t\t\twidth: avatar.options.ccvWidth,\n\t\t\t\theight: avatar.options.ccvHeight,\n\t\t\t\tmargin: avatar.options.ccvMargin,\n\t\t\t}\n\t\t\tccvContext.videoImage = this.makeCanvas(ccvContext.width, ccvContext.height);\n\t\t\tccvContext.videoImageContext = ccvContext.videoImage[0].getContext('2d');\n\t\t\tccvContext.videoImageContext.fillStyle = \"rgb(0,255,0)\";\n\t\t\tccvContext.videoImageContext.fillRect(0, 0, ccvContext.width, ccvContext.height);\n\t\t\tccvContext.videoTexture = new THREE.Texture(ccvContext.videoImage[0]);\n\t\t\tccvContext.videoTexture.minFilter = THREE.LinearFilter;\n\t\t\tccvContext.videoTexture.magFilter = THREE.LinearFilter;\n\t\t\tccvContext.videoTexture.needsUpdate = true;\n\t\t\tvStream.ccvContexts[avatar.ccvContextKey] = ccvContext;\n\t\t\t//debugger;\n\t\t}\n\t\treturn vStream.streamReady;\n\t}\n\tGadget3DVideo.getVideoTexture = function (playerSide) {\n\t\tvar vStream = this.streams[playerSide];\n\t\tif (vStream)\n\t\t\treturn vStream.videoTexture;\n\t\telse\n\t\t\treturn null;\n\t}\n\tGadget3DVideo.getCCVVideoTexture = function (playerSide, contextKey) {\n\t\tvar vStream = this.streams[playerSide];\n\t\tif (vStream) {\n\t\t\tvar ccvContext = vStream.ccvContexts[contextKey];\n\t\t\tif (ccvContext)\n\t\t\t\treturn ccvContext.videoTexture;\n\t\t}\n\t\treturn null;\n\t}\n\tGadget3DVideo.isStreamReady = function (playerSide) {\n\t\treturn this.streams[playerSide] && this.streams[playerSide].streamReady;\n\t}\n\tGadget3DVideo.isCCVLocked = function (playerSide) {\n\t\treturn this.streams[playerSide] && this.streams[playerSide].ccvLock;\n\t}\n\tGadget3DVideo.removeAvatar = function (avatar, playerSide) {\n\t\tvar vStream = this.streams[playerSide];\n\t\tif (vStream)\n\t\t\tfor (var i = 0; i < vStream.avatars.length; i++)\n\t\t\t\tif (avatar == vStream.avatars[i]) {\n\t\t\t\t\tvStream.avatars.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t}\n\tGadget3DVideo.animate = function () {\n\t\tfor (var side in this.streams) {\n\t\t\tvar vStream = this.streams[side];\n\t\t\ttry {\n\t\t\t\tvStream.loopCount++;\n\t\t\t\tif (vStream.video[0].getAttribute(\"webrtc-attached\") === \"1\" &&\n\t\t\t\t\tvStream.video[0].readyState === vStream.video[0].HAVE_ENOUGH_DATA) {\n\t\t\t\t\tvStream.videoImageContext.drawImage(vStream.video[0], 0, 0,\n\t\t\t\t\t\tvStream.videoImage[0].width, vStream.videoImage[0].height);\n\t\t\t\t\tif (vStream.videoTexture) {\n\t\t\t\t\t\tvStream.videoTexture.needsUpdate = true;\n\t\t\t\t\t\tif (!vStream.streamReady) {\n\t\t\t\t\t\t\tvStream.streamReady = true;\n\t\t\t\t\t\t\tfor (var i = 0; i < vStream.avatars.length; i++)\n\t\t\t\t\t\t\t\tvStream.avatars[i].streamReady(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar ccvLocalRequested = false;\n\t\t\t\t\tvar ccvRequested = false;\n\t\t\t\t\tfor (var i = 0; i < vStream.avatars.length; i++)\n\t\t\t\t\t\tif (vStream.avatars[i].options.ccv) {\n\t\t\t\t\t\t\tccvRequested = true;\n\t\t\t\t\t\t\tif (vStream.local) {\n\t\t\t\t\t\t\t\tccvLocalRequested = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tif (ccvLocalRequested) {\n\t\t\t\t\t\tif (typeof (ccv) == \"undefined\") { // ccv library not loaded\n\t\t\t\t\t\t\tif (!this.ccvLibRequested) {\n\t\t\t\t\t\t\t\tvar path = null;\n\t\t\t\t\t\t\t\tconsole.error(\"No CCV path available\");\n\t\t\t\t\t\t\t\tthis.ccvLibRequested = true;\n\t\t\t\t\t\t\t\tif (path) {\n\t\t\t\t\t\t\t\t\t$(\"<script/>\").attr(\"src\", path + \"/face.js\").attr(\"type\", \"text/javascript\")\n\t\t\t\t\t\t\t\t\t\t.appendTo($(\"head\"));\n\t\t\t\t\t\t\t\t\t$(\"<script/>\").attr(\"src\", path + \"/ccv.js\").attr(\"type\", \"text/javascript\")\n\t\t\t\t\t\t\t\t\t\t.appendTo($(\"head\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!vStream.ccvInProgress)\n\t\t\t\t\t\t\t\tthis.ccvPoll(vStream);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ccvRequested)\n\t\t\t\t\t\tthis.ccvAnimate(vStream);\n\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (vStream.errorCount % 1000000 == 0)\n\t\t\t\t\tconsole.warn(\"Gadget3DVideo.animate error\", vStream.errorCount, side, e);\n\t\t\t\tvStream.errorCount++;\n\t\t\t}\n\t\t}\n\t}\n\tGadget3DVideo.ccvLocked = function (vStream, locking) {\n\t\tfor (var i = 0; i < vStream.avatars.length; i++)\n\t\t\tvStream.avatars[i].ccvLocked(locking);\n\t}\n\tGadget3DVideo.ccvPoll = function (vStream) {\n\t\tvStream.ccvInProgress = true;\n\t\tvar width = vStream.videoImage[0].width;\n\t\tvar height = vStream.videoImage[0].height;\n\t\tvar now = Date.now();\n\t\tfunction CCVResult(comp) {\n\t\t\tif (comp.length == 0) {\n\t\t\t\tif (vStream.ccvLock) {\n\t\t\t\t\tvStream.ccvLock = null;\n\t\t\t\t\tGadget3DVideo.ccvLocked(vStream, false);\n\t\t\t\t\tWebRTC.sendCCVMessage({\n\t\t\t\t\t\tlocked: false,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar face = comp[0];\n\t\t\t\tvar lock = vStream.ccvLock;\n\t\t\t\tvStream.ccvLock = {\n\t\t\t\t\tx: face.x,\n\t\t\t\t\ty: face.y,\n\t\t\t\t\twidth: face.width,\n\t\t\t\t\theight: face.height,\n\t\t\t\t}\n\t\t\t\tif (vStream.ccvLastSuccess)\n\t\t\t\t\tvStream.ccvLastSuccess.videoImage.remove();\n\t\t\t\tvStream.ccvLastSuccess = $.extend({\n\t\t\t\t\tvideoImage: vStream.ccvLastAnalyzed,\n\t\t\t\t\tcopied: false,\n\t\t\t\t}, vStream.ccvLock);\n\t\t\t\tvStream.ccvLastAnalyzed = null;\n\t\t\t\tvStream.ccvLastAnalyzedContext = null;\n\n\t\t\t\tif (!lock)\n\t\t\t\t\tGadget3DVideo.ccvLocked(vStream, true);\n\t\t\t\tWebRTC.sendCCVMessage({\n\t\t\t\t\tlocked: true,\n\t\t\t\t\tx: face.x,\n\t\t\t\t\ty: face.y,\n\t\t\t\t\twidth: face.width,\n\t\t\t\t\theight: face.height,\n\t\t\t\t});\n\t\t\t}\n\t\t\tReschedulePoll();\n\t\t}\n\t\tfunction ReschedulePoll() {\n\t\t\tsetTimeout(function () {\n\t\t\t\tvStream.ccvInProgress = false;\n\t\t\t}, 200);\n\t\t}\n\t\tif (!vStream.ccvLastAnalyzed) {\n\t\t\tvStream.ccvLastAnalyzed = this.makeCanvas(vStream.videoImage[0].width, vStream.videoImage[0].height);\n\t\t\tvStream.ccvLastAnalyzedContext = vStream.ccvLastAnalyzed[0].getContext(\"2d\");\n\t\t}\n\t\tvStream.ccvLastAnalyzedContext.drawImage(vStream.videoImage[0], 0, 0, vStream.videoImage[0].width, vStream.videoImage[0].height);\n\n\t\t/*\n\t\tif(WebRTC.webrtcDetectedBrowser==\"firefox\")\n\t\t\tccv.detect_objects({\n\t\t\t\t//\"canvas\" : ccv.grayscale(vStream.ccvLastAnalyzed[0]),\n\t\t\t\t\"canvas\" : ccv.grayscale(vStream.videoImage[0]),\n\t\t\t\t\"cascade\" : cascade,\n\t\t\t\t\"interval\" : 5,\n\t\t\t\t\"min_neighbors\" : 1,\n\t\t\t\t\"async\" : false,\n\t\t\t\t\"async\" : true,\n\t\t\t\t\"worker\" : 1\n\t\t\t})(CCVResult);\n\t\telse\n\t\t*/\n\t\tCCVResult(ccv.detect_objects({\n\t\t\t//\"canvas\" : ccv.grayscale(vStream.ccvLastAnalyzed[0]),\n\t\t\t\"canvas\": ccv.grayscale(vStream.videoImage[0]),\n\t\t\t\"cascade\": cascade,\n\t\t\t\"interval\": 5,\n\t\t\t\"min_neighbors\": 1,\n\t\t\t\"async\": false,\n\t\t\t\"worker\": 1\n\t\t}));\n\t}\n\tGadget3DVideo.makeCanvas = function (width, height) {\n\t\treturn $(\"<canvas/>\").attr(\"width\", width).attr(\"height\", height).width(width).height(height)\n\t\t\t.css({\n\t\t\t\tvisibility: \"hidden\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\t\"z-index\": -1,\n\t\t\t\ttop: 0,\n\t\t\t}).appendTo(\"body\");\n\t}\n\tGadget3DVideo.ccvAnimate = function (vStream) {\n\t\tfunction DrawImage(ccvContext, ccvLock, source) {\n\t\t\tvar width = ccvLock.width * (1 + ccvContext.margin[1] + ccvContext.margin[3]);\n\t\t\tvar height = ccvLock.height * (1 + ccvContext.margin[0] + ccvContext.margin[2]);\n\t\t\tvar x = ccvLock.x - ccvLock.width * ccvContext.margin[3];\n\t\t\tvar y = ccvLock.y - ccvLock.height * ccvContext.margin[0];\n\t\t\tif (x < 0) {\n\t\t\t\twidth += x;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (y < 0) {\n\t\t\t\theight += y;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\tif (x + width > source.width)\n\t\t\t\twidth = source.width - x;\n\t\t\tif (y + height > source.height)\n\t\t\t\theight = source.height - y;\n\t\t\tccvContext.videoImageContext.drawImage(source,\n\t\t\t\tx, y, width, height,\n\t\t\t\t0, 0,\n\t\t\t\tccvContext.width, ccvContext.height);\n\t\t\tccvContext.videoTexture.needsUpdate = true;\n\t\t}\n\n\t\tfor (var contextKey in vStream.ccvContexts) {\n\t\t\tvar ccvContext = vStream.ccvContexts[contextKey];\n\t\t\tif (vStream.ccvLock)\n\t\t\t\tDrawImage(ccvContext, vStream.ccvLock, vStream.videoImage[0]);\n\t\t\telse if (vStream.ccvLastSuccess && !vStream.ccvLastSuccess.copied) {\n\t\t\t\tvStream.ccvLastSuccess.copied = true;\n\t\t\t\tDrawImage(ccvContext, vStream.ccvLastSuccess, vStream.ccvLastSuccess.videoImage[0]);\n\t\t\t}\n\t\t}\n\t}\n\tGadget3DVideo.receiveRemoteLock = function (message) {\n\t\tfor (var side in this.streams) {\n\t\t\tvar vStream = this.streams[side];\n\t\t\tif (vStream.local)\n\t\t\t\tcontinue;\n\t\t\tvar lock = vStream.ccvLock;\n\t\t\tif (message.locked) {\n\t\t\t\tvStream.ccvLock = {\n\t\t\t\t\tx: message.x,\n\t\t\t\t\ty: message.y,\n\t\t\t\t\twidth: message.width,\n\t\t\t\t\theight: message.height,\n\t\t\t\t};\n\t\t\t\tif (vStream.ccvLastSuccess)\n\t\t\t\t\tvStream.ccvLastSuccess.videoImage.remove();\n\t\t\t\tvar videoImage = this.makeCanvas(vStream.videoImage[0].width, vStream.videoImage[0].height);\n\t\t\t\tvar videoImageContext = videoImage[0].getContext(\"2d\");\n\t\t\t\tvideoImageContext.drawImage(vStream.videoImage[0], 0, 0, vStream.videoImage[0].width, vStream.videoImage[0].height);\n\t\t\t\tvStream.ccvLastSuccess = $.extend({\n\t\t\t\t\tvideoImage: videoImage,\n\t\t\t\t\tcopied: false,\n\t\t\t\t}, vStream.ccvLock);\n\t\t\t\tif (!lock)\n\t\t\t\t\tGadget3DVideo.ccvLocked(vStream, true);\n\t\t\t} else {\n\t\t\t\tif (lock) {\n\t\t\t\t\tvStream.ccvLock = null;\n\t\t\t\t\tGadget3DVideo.ccvLocked(vStream, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction WebRTCHandler(event, data) {\n\t\ttry {\n\t\t\tif (data.webrtcType == \"mediaOn\") {\n\t\t\t\tif (data.ar)\n\t\t\t\t\tAR(data.stream);\n\t\t\t\telse\n\t\t\t\t\tGadget3DVideo.addStream(data.side, data.stream, data.local);\n\t\t\t} if (data.webrtcType == \"mediaOff\") {\n\t\t\t\tif (arStream)\n\t\t\t\t\tAR(null);\n\t\t\t\telse\n\t\t\t\t\tGadget3DVideo.removeStream(data.side);\n\t\t\t} if (data.webrtcType == \"ccv\")\n\t\t\t\tGadget3DVideo.receiveRemoteLock(data.message);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"xd-view webrtc error\", e);\n\t\t}\n\t}\n\t$(document).bind(\"joclyhub.webrtc\", WebRTCHandler);\n\n\tvar Gadget3DVideoFile = GadgetCustomMesh3D.extend({\n\t\tinit: function (gadget, options) {\n\t\t\toptions = $.extend(true, {\n\t\t\t\tscale: [1, 1, 1],\n\t\t\t\tmakeMesh: function (videoTexture) {\n\t\t\t\t\tvar material = new THREE.MeshBasicMaterial({\n\t\t\t\t\t\tmap: videoTexture,\n\t\t\t\t\t\toverdraw: true,\n\t\t\t\t\t});\n\t\t\t\t\tvar geometry = new THREE.PlaneGeometry(this.options.width * this.SCALE3D, this.options.height * this.SCALE3D, 1, 1);\n\t\t\t\t\tvar mesh = new THREE.Mesh(geometry, material);\n\n\t\t\t\t\treturn mesh;\n\t\t\t\t},\n\t\t\t\twidth: 12,\n\t\t\t\theight: 9,\n\t\t\t}, options);\n\t\t\tthis.videoPlayer = Gadget3DVideoFile.GetVideoPlayer(options.src);\n\t\t\tthis._super.call(this, gadget, options);\n\t\t},\n\t\tcreateObject: function () {\n\t\t\tvar mesh = this.options.makeMesh.call(this, this.videoPlayer.texture);\n\t\t\tif (mesh)\n\t\t\t\tthis.objectReady(mesh);\n\t\t},\n\t\tremove: function () {\n\t\t\tvar videoPlayer = videoPlayers[this.options.src];\n\t\t\tif (videoPlayer) {\n\t\t\t\tvideoPlayer.count--;\n\t\t\t\tif (videoPlayer.count == 0) {\n\t\t\t\t\tdelete threeCtx.animateCallbacks[\"Gadget3DVideoFile.\" + this.options.src];\n\t\t\t\t\tvideoPlayer.tag.remove();\n\t\t\t\t\tvideoPlayer.canvas.remove();\n\t\t\t\t\tdelete videoPlayers[this.options.src];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._super.apply(this, arguments);\n\t\t},\n\t});\n\n\tvar videoPlayers = {};\n\tGadget3DVideoFile.GetVideoPlayer = function (url) {\n\t\tvar videoPlayer = videoPlayers[url];\n\t\tif (!videoPlayer) {\n\t\t\tvar width = 638;\n\t\t\tvar height = 360;\n\t\t\tvar videoTag = $(\"<video/>\").attr(\"autoplay\", \"autoplay\")./*attr(\"muted\",\"muted\").*/attr(\"loop\", \"loop\").css({\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tposition: \"absolute\",\n\t\t\t}).append($(\"<source/>\").attr(\"src\", url).attr(\"type\", \"video/webm\")).appendTo(\"body\");\n\t\t\tvideoPlayer = {\n\t\t\t\tcount: 1,\n\t\t\t\ttag: videoTag,\n\t\t\t\tcanvas: Gadget3DVideo.makeCanvas(width, height),\n\t\t\t}\n\t\t\tvideoPlayer.context = videoPlayer.canvas[0].getContext('2d');\n\t\t\tvideoPlayer.context.fillStyle = \"rgb(0,255,0)\";\n\t\t\tvideoPlayer.context.fillRect(0, 0, width, height);\n\n\t\t\tvideoPlayer.texture = new THREE.Texture(videoPlayer.canvas[0]);\n\t\t\tvideoPlayer.texture.minFilter = THREE.LinearFilter;\n\t\t\tvideoPlayer.texture.magFilter = THREE.LinearFilter;\n\t\t\tvideoPlayer.texture.needsUpdate = true;\n\n\t\t\tfunction Animate() {\n\t\t\t\tvar ctx = videoPlayer.context;\n\t\t\t\tctx.drawImage(videoPlayer.tag[0], 0, 0,\n\t\t\t\t\twidth, height);\n\t\t\t\tvideoPlayer.texture.needsUpdate = true;\n\t\t\t}\n\t\t\tthreeCtx.animateCallbacks[\"Gadget3DVideoFile.\" + url] = {\n\t\t\t\t_this: null,\n\t\t\t\tcallback: Animate,\n\t\t\t}\n\n\t\t\tvideoPlayers[url] = videoPlayer;\n\t\t} else\n\t\t\tvideoPlayer.count++;\n\n\t\treturn videoPlayer;\n\t}\n\n\n\tvar GadgetCamera = GadgetObject3D.extend({\n\t\tinit: function (gadget, options) {\n\t\t\tthis._super.call(this, gadget, options);\n\t\t\t//this.object3d=threeCtx.camera;\n\t\t\tthis.object3d = threeCtx.body;\n\t\t\tthis.cameraObject = this.object3d.children[0];\n\t\t\tthis.targetAnim = null;\n\t\t\tthis.camTarget = threeCtx.camTarget;\n\t\t},\n\t\tdisplayObject3D: function (force, options, delay) {\n\t\t\tvar $this = this;\n\t\t\tthis.options.x = this.object3d.position.x / SCALE3D;\n\t\t\tthis.options.y = this.object3d.position.z / SCALE3D;\n\t\t\tthis.options.z = this.object3d.position.y / SCALE3D;\n\t\t\tthis._super.apply(this, arguments);\n\t\t\tif (force ||\n\t\t\t\toptions.targetX * SCALE3D != threeCtx.cameraControls.camTarget.x ||\n\t\t\t\toptions.targetY * SCALE3D != threeCtx.cameraControls.camTarget.z ||\n\t\t\t\toptions.targetZ * SCALE3D != threeCtx.cameraControls.camTarget.y\n\t\t\t) {\n\t\t\t\tif (delay) {\n\t\t\t\t\tvar traveling = options.traveling;\n\t\t\t\t\tvar x0 = threeCtx.cameraControls.camTarget.x;\n\t\t\t\t\tvar y0 = threeCtx.cameraControls.camTarget.y;\n\t\t\t\t\tvar z0 = threeCtx.cameraControls.camTarget.z;\n\n\t\t\t\t\toptions.traveling = false;\n\t\t\t\t\tif (this.targetAnim) {\n\t\t\t\t\t\tthis.targetAnim.stop();\n\t\t\t\t\t\t//this.animEnd(this.targetCallback);\n\t\t\t\t\t\tthis.animEnd(options);\n\t\t\t\t\t}\n\t\t\t\t\t//this.targetCallback=callback;\n\t\t\t\t\tthis.animStart(options);\n\t\t\t\t\tthis.targetAnim = new TWEEN.Tween(threeCtx.cameraControls.camTarget).to({\n\t\t\t\t\t\tx: options.targetX * SCALE3D,\n\t\t\t\t\t\ty: options.targetZ * SCALE3D,\n\t\t\t\t\t\tz: options.targetY * SCALE3D,\n\t\t\t\t\t}, delay).easing(options.targetEasing ? options.targetEasing : TWEEN.Easing.Cubic.EaseInOut).onComplete(function () {\n\t\t\t\t\t\t$this.targetAnim = null;\n\t\t\t\t\t\t$this.animEnd(options);\n\t\t\t\t\t}).onUpdate(function (ratio) {\n\t\t\t\t\t\tif (options.targetEasingUpdate)\n\t\t\t\t\t\t\toptions.targetEasingUpdate.call($this, ratio);\n\t\t\t\t\t\tif (traveling) {\n\t\t\t\t\t\t\tvar dx = threeCtx.cameraControls.camTarget.x - x0;\n\t\t\t\t\t\t\tvar dy = threeCtx.cameraControls.camTarget.y - y0;\n\t\t\t\t\t\t\tvar dz = threeCtx.cameraControls.camTarget.z - z0;\n\t\t\t\t\t\t\tx0 = threeCtx.cameraControls.camTarget.x;\n\t\t\t\t\t\t\ty0 = threeCtx.cameraControls.camTarget.y;\n\t\t\t\t\t\t\tz0 = threeCtx.cameraControls.camTarget.z;\n\t\t\t\t\t\t\t//$this.object3d.position.add(new THREE.Vector3(dx,dy,dz));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//$this.object3d.lookAt(threeCtx.cameraControls.camTarget);\n\t\t\t\t\t\t$this.cameraObject.lookAt(threeCtx.cameraControls.camTarget);\n\t\t\t\t\t}).start();\n\t\t\t\t} else {\n\t\t\t\t\tthreeCtx.cameraControls.camTarget.x = options.targetX * SCALE3D;\n\t\t\t\t\tthreeCtx.cameraControls.camTarget.y = options.targetZ * SCALE3D;\n\t\t\t\t\tthreeCtx.cameraControls.camTarget.z = options.targetY * SCALE3D;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n\n\tfunction CreateCameraGadget() {\n\t\txdv.createGadget(\"camera\", {\n\t\t\t\"3d\": {\n\t\t\t\ttype: \"camera3d\",\n\t\t\t\tx: threeCtx.camera.position.x / SCALE3D,\n\t\t\t\ty: threeCtx.camera.position.z / SCALE3D,\n\t\t\t\tz: threeCtx.camera.position.y / SCALE3D,\n\t\t\t\ttargetX: threeCtx.cameraControls.camTarget.x / SCALE3D,\n\t\t\t\ttargetY: threeCtx.cameraControls.camTarget.z / SCALE3D,\n\t\t\t\ttargetZ: threeCtx.cameraControls.camTarget.y / SCALE3D,\n\t\t\t},\n\t\t});\n\t\txdv.saveGadgetProps(\"camera\", [\"targetX\", \"targetY\", \"targetZ\"], \"initial\");\n\t\txdv.updateGadget(\"camera\", {\n\t\t\t\"3d\": {\n\t\t\t\tvisible: true,\n\t\t\t},\n\t\t});\n\t}\n\n\t/* ======================================== */\n\n\tvar avatarTypes = {\n\t\t\"image\": GadgetImage,\n\t\t\"element\": GadgetElement,\n\t\t\"canvas\": GadgetCanvas,\n\t\t\"hexagon\": GadgetHexagon,\n\t\t\"sprite\": GadgetSprite,\n\t\t\"disk\": GadgetDisk,\n\t\t\"meshfile\": GadgetMeshFile,\n\t\t\"custom3d\": GadgetCustom3D,\n\t\t\"plane3d\": GadgetPlane3D,\n\t\t\"custommesh3d\": GadgetCustomMesh3D,\n\t\t\"video3d\": Gadget3DVideo,\n\t\t\"camera3d\": GadgetCamera,\n\t\t\"videofile3d\": Gadget3DVideoFile,\n\t}\n\n\n\t/* ======================================== */\n\n\tvar areaElements = null;\n\n\tView.Game.CamAnim = {\n\t\tisSupported: function () {\n\t\t\treturn !!threeCtx;\n\t\t},\n\t\tisRunning: function () {\n\t\t\treturn threeCtx && threeCtx.camAnim;\n\t\t},\n\t\tset: function (on) {\n\t\t\tif (threeCtx)\n\t\t\t\tthreeCtx.setCamAnim(on);\n\t\t},\n\t}\n\n\tView.Game.InitView = function () {\n\n\t\tresourcesMap = this.resources || {};\n\n\t\tif (this != xdv.game) {\n\t\t\txdv.game = this;\n\t\t\tif (this.mWidget.find(\".jocly-xdv-area\").length == 0) {\n\t\t\t\tarea = $(\"<div/>\").css({\n\t\t\t\t\t\"position\": \"absolute\",\n\t\t\t\t\t\"z-index\": 0,\n\t\t\t\t\t\"overflow\": \"hidden\",\n\t\t\t\t}).addClass(\"jocly-xdv-area\").appendTo(this.mWidget);\n\t\t\t}\n\t\t}\n\t\tif (areaElements) {\n\t\t\tareaElements.appendTo(area);\n\t\t\tareaElements = null;\n\t\t}\n\n\t\tif (!xdv.initDone) {\n\t\t\tthis.xdInit(xdv);\n\t\t\txdv.initDone = true;\n\t\t}\n\n\t\tvar needs3DUpdate = false;\n\t\tif (!currentSkin || this.mSkin != currentSkin.name) {\n\t\t\tcurrentSkin = null;\n\t\t\tfor (var i = 0; i < this.mViewOptions.skins.length; i++) {\n\t\t\t\tvar skin = this.mViewOptions.skins[i];\n\t\t\t\tif (skin.name == this.mSkin) {\n\t\t\t\t\tcurrentSkin = skin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (currentSkin == null) {\n\t\t\t\tLog(\"!!! InitView\", \"skin\", this.mSkin, \"not found\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\txdv.unbuildGadgets();\n\t\t\tareaElements = null;\n\t\t\tif (currentSkin[\"3d\"])\n\t\t\t\tneeds3DUpdate = true;\n\t\t}\n\n\t\tvar areaWidth = Math.min(this.mGeometry.width, this.mGeometry.height\n\t\t\t* (this.mViewOptions.preferredRatio || 1));\n\t\tvar areaHeight = Math.min(this.mGeometry.width / (this.mViewOptions.preferredRatio || 1), this.mGeometry.height);\n\t\tvar areaCenter;\n\t\tif (currentSkin[\"3d\"]) {\n\t\t\tarea.css({\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0,\n\t\t\t\twidth: this.mGeometry.width,\n\t\t\t\theight: this.mGeometry.height,\n\t\t\t});\n\t\t\tareaCenter = {\n\t\t\t\tx: this.mGeometry.width / 2,\n\t\t\t\ty: this.mGeometry.height / 2,\n\t\t\t};\n\t\t\tif (!threeCtx) {\n\t\t\t\tif (!THREE.Object3D._threexDomEvent) {\n\t\t\t\t\tTHREE.Object3D._threexDomEvent = new THREEx.DomEvent();\n\t\t\t\t}\n\t\t\t\tthreeCtx = BuildThree(this, areaWidth, areaHeight);\n\t\t\t\tCreateCameraGadget();\n\t\t\t\tthreeCtx.camera.updateProjectionMatrix();\n\t\t\t} else {\n\t\t\t\tthreeCtx.renderer.setSize(this.mGeometry.width, this.mGeometry.height);\n\t\t\t\tthreeCtx.anaglyphEffect.setSize(this.mGeometry.width, this.mGeometry.height);\n\t\t\t\tthreeCtx.camera.aspect = this.mGeometry.width / this.mGeometry.height;\n\t\t\t\tthreeCtx.camera.updateProjectionMatrix();\n\t\t\t}\n\n\t\t\tTHREE.Object3D._threexDomEvent.setDOMElement(threeCtx.renderer.domElement);\n\t\t\tTHREE.Object3D._threexDomEvent.setBoundContext(THREEx_boundContext);\n\t\t\tTHREE.Object3D._threexDomEvent.camera(threeCtx.camera);\n\n\t\t\tResumePendingResources();\n\n\t\t\tthreeCtx.animControl.trigger();\n\t\t\tif (needs3DUpdate) {\n\n\t\t\t\tvar cameraData = $.extend(true, {\n\t\t\t\t\tradius: 12,\n\t\t\t\t\televationAngle: 60,\n\t\t\t\t\trotationAngle: 90,\n\t\t\t\t\tdistMax: 20,\n\t\t\t\t\tdistMin: 0,\n\t\t\t\t\televationMax: 89,\n\t\t\t\t\televationMin: 10,\n\t\t\t\t\tstartAngle: 90,\n\t\t\t\t\tcamAnim: false,\n\t\t\t\t\tlimitCamMoves: true,\n\t\t\t\t\tenableDrag: true,\n\t\t\t\t\ttargetBounds: [3000, 3000, 3000],\n\t\t\t\t\ttarget: [0, 0, 800],\n\t\t\t\t\tfov: 55,\n\t\t\t\t\tnear: .01\n\t\t\t\t}, currentSkin.camera);\n\n\t\t\t\t// update FOV\n\t\t\t\tthreeCtx.camera.fov = cameraData.fov;\n\t\t\t\tthreeCtx.camera.near = cameraData.near;\n\t\t\t\tthreeCtx.camera.updateProjectionMatrix();\n\n\t\t\t\t$.extend(threeCtx.cameraControls, {\n\t\t\t\t\tminDistance: cameraData.distMin,\n\t\t\t\t\tmaxDistance: cameraData.distMax,\n\t\t\t\t\tminPolarAngle: (90 - cameraData.elevationMax) * Math.PI / 180,\n\t\t\t\t\tmaxPolarAngle: (90 - cameraData.elevationMin) * Math.PI / 180,\n\t\t\t\t\tenableDrag: cameraData.enableDrag,\n\t\t\t\t\ttargetBounds: [cameraData.targetBounds[0] * SCALE3D, cameraData.targetBounds[2] * SCALE3D, cameraData.targetBounds[1] * SCALE3D],\n\t\t\t\t});\n\n\t\t\t\tvar camPosition = {\n\t\t\t\t\tx: cameraData.radius * Math.cos(cameraData.elevationAngle * Math.PI / 180) * Math.cos(cameraData.rotationAngle * Math.PI / 180),\n\t\t\t\t\tz: cameraData.radius * Math.cos(cameraData.elevationAngle * Math.PI / 180) * Math.sin(cameraData.rotationAngle * Math.PI / 180),\n\t\t\t\t\ty: cameraData.radius * Math.sin(cameraData.elevationAngle * Math.PI / 180),\n\t\t\t\t}\n\n\t\t\t\tvar camTarget = {\n\t\t\t\t\tx: cameraData.target[0],\n\t\t\t\t\ty: cameraData.target[1],\n\t\t\t\t\tz: cameraData.target[2],\n\t\t\t\t}\n\t\t\t\txdv.updateGadget(\"camera\", {\n\t\t\t\t\t\"3d\": {\n\t\t\t\t\t\tx: camPosition.x / SCALE3D,\n\t\t\t\t\t\ty: camPosition.z / SCALE3D,\n\t\t\t\t\t\tz: camPosition.y / SCALE3D,\n\t\t\t\t\t\ttargetX: camTarget.x,\n\t\t\t\t\t\ttargetY: camTarget.y,\n\t\t\t\t\t\ttargetZ: camTarget.z,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tthreeCtx.cameraControls.camTarget.copy(camTarget);\n\t\t\t\t//threeCtx.cameraControls.camera.position.copy(camPosition);\n\t\t\t\tthreeCtx.cameraControls.update();\n\n\t\t\t\tvar world = {\n\t\t\t\t\tcolor: 0x205D7C,\n\t\t\t\t\tfog: true,\n\t\t\t\t\tfogNear: 10,\n\t\t\t\t\tfogFar: 100,\n\t\t\t\t\tlightCastShadow: true,\n\t\t\t\t\tlightIntensity: 1.75,\n\t\t\t\t\tlightPosition: { x: -12, y: 12, z: 12 },\n\t\t\t\t\t//lightShadowDarkness: 0.75,\n\t\t\t\t\tambientLightColor: 0xbbbbbb,\n\t\t\t\t\tskyLightPosition: { x: -45, y: 45, z: 45 },\n\t\t\t\t\tskyLightIntensity: 2,\n\t\t\t\t}\n\t\t\t\t$.extend(true, world, currentSkin.world);\n\t\t\t\tif (threeCtx.scene.fog) {\n\t\t\t\t\tthreeCtx.scene.remove(threeCtx.scene.fog);\n\t\t\t\t\tdelete threeCtx.scene.fog;\n\t\t\t\t}\n\t\t\t\tif (world.fog) {\n\t\t\t\t\tvar fogColor = world.color;\n\t\t\t\t\tif (world.fogColor) fogColor = world.fogColor;\n\t\t\t\t\tthreeCtx.scene.fog = new THREE.Fog(fogColor, world.fogNear, world.fogFar);\n\t\t\t\t}\n\n\t\t\t\tthreeCtx.world = world;\n\t\t\t\tthreeCtx.renderer.setClearColor(new THREE.Color(world.color), 1);\n\t\t\t\tthreeCtx.light.castShadow = world.lightCastShadow;\n\t\t\t\tthreeCtx.light.intensity = world.lightIntensity;\n\t\t\t\tthreeCtx.light.position.set(world.lightPosition.x, world.lightPosition.y, world.lightPosition.z);\n\t\t\t\t//threeCtx.light.shadowDarkness=world.lightShadowDarkness;\n\t\t\t\tthreeCtx.ambientLight.color.setHex(world.ambientLightColor);\n\t\t\t\tthreeCtx.skyLight.intensity = world.skyLightIntensity;\n\t\t\t\tthreeCtx.skyLight.position.set(world.skyLightPosition.x, world.skyLightPosition.y, world.skyLightPosition.z);\n\t\t\t}\n\t\t\tthreeCtx.renderer.domElement.style.display = \"block\";\n\t\t} else {\n\t\t\tarea.css({\n\t\t\t\tleft: (this.mGeometry.width - areaWidth) / 2,\n\t\t\t\ttop: (this.mGeometry.height - areaHeight) / 2,\n\t\t\t\twidth: areaWidth,\n\t\t\t\theight: areaHeight,\n\t\t\t});\n\t\t\tareaCenter = {\n\t\t\t\tx: areaWidth / 2,\n\t\t\t\ty: areaHeight / 2,\n\t\t\t}\n\t\t\tif (threeCtx)\n\t\t\t\tthreeCtx.renderer.domElement.style.display = \"none\";\n\t\t}\n\n\t\tthis.xdBuildScene(xdv);\n\t\t//xdv.updateArea(Math.min(areaWidth,areaHeight)/VSIZE,areaCenter);\n\t\txdv.updateArea(Math.max(areaWidth, areaHeight) / VSIZE, areaCenter);\n\t}\n\n\tView.Game.DestroyView = function () {\n\t\tif (!xdv.game) {\n\t\t\tLog(\"!!! InitView\", \"game already unset\");\n\t\t\treturn;\n\t\t}\n\t\tif (resLoadingMask)\n\t\t\tresLoadingMask.hide();\n\t\txdv.game = null;\n\t\tareaElements = area.children().detach();\n\t\tif (threeCtx) {\n\t\t\tif (threeCtx.cameraControls.autoRotate)\n\t\t\t\tthreeCtx.cameraControls.autoRotate = false;\n\t\t}\n\t\t//threeCtx.animControl.stop();\n\t}\n\n\tView.Game.CloseView = function () {\n\t\txdv.unbuildGadgets();\n\n\t\tif (threeCtx) {\n\t\t\tTHREE.Object3D._threexDomEvent.unsetBoundContext(THREEx_boundContext);\n\t\t\tthreeCtx.cameraControls.destroy();\n\t\t\tthreeCtx = null;\n\t\t}\n\t\tInitGlobals();\n\t}\n\n\tView.Game.xdResourceLoaded = function (res) {\n\t\tif (/^map\\|/.test(res))\n\t\t\treturn false;\n\t\tif (resources[res] && resources[res].status == \"loaded\")\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tView.Game.xdLoadResources = function (ress, callback) {\n\t\tvar resCount = 0;\n\t\tfunction ResLoaded() {\n\t\t\tif (--resCount == 0)\n\t\t\t\tcallback();\n\t\t}\n\t\tfor (var i = 0; i < ress.length; i++) {\n\t\t\tresCount++;\n\t\t\tvar m = /^map\\|(.*)$/.exec(ress[i]);\n\t\t\tif (m)\n\t\t\t\tGetMaterialMap(m[1], function () {\n\t\t\t\t\tsetTimeout(ResLoaded, 0);\n\t\t\t\t});\n\t\t\telse\n\t\t\t\tGetResource(ress[i], function () {\n\t\t\t\t\tsetTimeout(ResLoaded, 0);\n\t\t\t\t});\n\t\t}\n\t}\n\n\tView.Game.xdExternalCommand = function (cmd, scope) {\n\t\tswitch (cmd.type) {\n\t\t\tcase 'updateCamera':\n\t\t\t\txdv.updateGadget(\"camera\", {\n\t\t\t\t\t\"3d\": cmd.camera,\n\t\t\t\t}, cmd.delay || 0);\n\t\t\t\tbreak;\n\t\t\tcase 'getCamera':\n\t\t\t\tvar resp = {\n\t\t\t\t\ttype: \"camera\",\n\t\t\t\t\tcameraId: cmd.cameraId,\n\t\t\t\t}\n\t\t\t\tif (threeCtx) {\n\t\t\t\t\tresp.camera = {\n\t\t\t\t\t\tx: threeCtx.camera.position.x / SCALE3D,\n\t\t\t\t\t\ty: threeCtx.camera.position.z / SCALE3D,\n\t\t\t\t\t\tz: threeCtx.camera.position.y / SCALE3D,\n\t\t\t\t\t\ttargetX: threeCtx.cameraControls.camTarget.x / SCALE3D,\n\t\t\t\t\t\ttargetY: threeCtx.cameraControls.camTarget.z / SCALE3D,\n\t\t\t\t\t\ttargetZ: threeCtx.cameraControls.camTarget.y / SCALE3D,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"cannot get camera without 3D context\");\n\t\t\t\t\tresp.camera = null;\n\t\t\t\t}\n\t\t\t\tscope.sendEmbed(resp);\n\t\t\t\tbreak;\n\t\t\tcase 'snapshot':\n\t\t\t\tvar resp = {\n\t\t\t\t\ttype: \"snapshot\",\n\t\t\t\t\tsnapshotId: cmd.snapshotId,\n\t\t\t\t}\n\t\t\t\tif (threeCtx) {\n\t\t\t\t\tvar renderer = threeCtx.renderer;\n\t\t\t\t\tvar canvas = renderer.domElement;\n\t\t\t\t\trenderer.render(threeCtx.scene, threeCtx.camera);\n\t\t\t\t\tresp.image = canvas.toDataURL(\"image/png\");\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"cannot get snapshot without 3D context\");\n\t\t\t\t\tresp.image = null;\n\t\t\t\t}\n\t\t\t\tscope.sendEmbed(resp);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tView.Game.ViewControl = function (cmd, options) {\n\t\toptions = options || {};\n\t\tvar promise = new Promise(function (resolve, reject) {\n\t\t\tswitch (cmd) {\n\t\t\t\tcase \"enterAnaglyph\":\n\t\t\t\t\tif (threeCtx) {\n\t\t\t\t\t\tthreeCtx.anaglyph = true;\n\t\t\t\t\t\tvar factor = 2.5;\n\t\t\t\t\t\tthreeCtx.scene.scale.set(1 / factor, 1 / factor, 1 / factor);\n\t\t\t\t\t\tthreeCtx.camera.scale.set(factor, factor, factor);\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t\t};\n\t\t\t\t\tresolve();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"exitAnaglyph\":\n\t\t\t\t\tif (threeCtx) {\n\t\t\t\t\t\tthreeCtx.anaglyph = false;\n\t\t\t\t\t\tthreeCtx.scene.scale.set(1, 1, 1);\n\t\t\t\t\t\tthreeCtx.camera.scale.set(1, 1, 1);\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t\t};\n\t\t\t\t\tresolve();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"stopAnimations\":\n\t\t\t\t\tvar animCount = 0;\n\t\t\t\t\tvar toBeDeleted = [];\n\t\t\t\t\tTWEEN.getAll().forEach(function(tween) {\n\t\t\t\t\t\tanimCount++;\n\t\t\t\t\t\tif(tween !== threeCtx.dolly)\n\t\t\t\t\t\t\ttoBeDeleted.push(tween);\n\t\t\t\t\t});\n\t\t\t\t\ttoBeDeleted.forEach(function(tween) {\n\t\t\t\t\t\tTWEEN.remove(tween);\n\t\t\t\t\t});\n\t\t\t\t\tresolve(animCount > 0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"setPanorama\":\n\t\t\t\t\tif (options.pictureUrl || options.pictureData) {\n\t\t\t\t\t\txdv.removeGadget(\"panorama\");\n\t\t\t\t\t\txdv.createGadget(\"panorama\", {\n\t\t\t\t\t\t\t\"3d\": {\n\t\t\t\t\t\t\t\ttype: \"custommesh3d\",\n\t\t\t\t\t\t\t\tharbor: false,\n\t\t\t\t\t\t\t\trotate: options.rotate || 0,\n\t\t\t\t\t\t\t\tcreate: function (callback) {\n\t\t\t\t\t\t\t\t\tvar geometry = new THREE.SphereGeometry(500, 60, 40);\n\t\t\t\t\t\t\t\t\tgeometry.scale(- 1, 1, 1);\n\t\t\t\t\t\t\t\t\tnew Promise(function (resolve, reject) {\n\t\t\t\t\t\t\t\t\t\tif (options.pictureData) {\n\t\t\t\t\t\t\t\t\t\t\tvar image = new Image;\n\t\t\t\t\t\t\t\t\t\t\timage.src = options.pictureData;\n\t\t\t\t\t\t\t\t\t\t\tvar texture = new THREE.Texture(image);\n\t\t\t\t\t\t\t\t\t\t\timage.onload = function () {\n\t\t\t\t\t\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t\t\t\tresolve(texture);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\t\t\tresolve(new THREE.TextureLoader().load(options.pictureUrl))\n\t\t\t\t\t\t\t\t\t}).then(function (texture) {\n\t\t\t\t\t\t\t\t\t\tvar material = new THREE.MeshBasicMaterial({\n\t\t\t\t\t\t\t\t\t\t\tmap: texture\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Mesh(geometry, material);\n\t\t\t\t\t\t\t\t\t\tcallback(mesh);\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\txdv.updateGadget(\"panorama\", {\n\t\t\t\t\t\t\t\"3d\": {\n\t\t\t\t\t\t\t\tvisible: true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\txdv.updateGadget(\"panorama\", {\n\t\t\t\t\t\t\t\"3d\": {\n\t\t\t\t\t\t\t\tvisible: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t\txdv.removeGadget(\"panorama\");\n\t\t\t\t\t}\n\t\t\t\t\tresolve();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"takeSnapshot\":\n\t\t\t\t\tif (threeCtx) {\n\t\t\t\t\t\tvar canvas = threeCtx.renderer.domElement;\n\t\t\t\t\t\tthreeCtx.renderer.render(threeCtx.scene, threeCtx.camera);\n\t\t\t\t\t\tresolve(canvas.toDataURL(\"image/\" + (options.format || \"png\"), options.quality || undefined));\n\t\t\t\t\t} else\n\t\t\t\t\t\treject(new Error(\"Snapshot only available on 3D views\"));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"getCamera\":\n\t\t\t\t\tif (threeCtx)\n\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\tx: threeCtx.body.position.x / SCALE3D,\n\t\t\t\t\t\t\ty: threeCtx.body.position.z / SCALE3D,\n\t\t\t\t\t\t\tz: threeCtx.body.position.y / SCALE3D,\n\t\t\t\t\t\t\ttargetX: threeCtx.cameraControls.camTarget.x / SCALE3D,\n\t\t\t\t\t\t\ttargetY: threeCtx.cameraControls.camTarget.z / SCALE3D,\n\t\t\t\t\t\t\ttargetZ: threeCtx.cameraControls.camTarget.y / SCALE3D\n\t\t\t\t\t\t});\n\t\t\t\t\telse \n\t\t\t\t\t\treject(new Error(\"Camera only available on 3D views\"));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'setCamera':\n\t\t\t\t\tif(!threeCtx)\n\t\t\t\t\t\treturn reject(new Error(\"Camera only available on 3D views\"));\n\n\t\t\t\t\tswitch(options.type) {\n\t\t\t\t\t\tcase \"spin\":\n\t\t\t\t\t\t\tresolve(SpinCamera(options));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"stop\":\n\t\t\t\t\t\t\tif(threeCtx.dolly) {\n\t\t\t\t\t\t\t\tdelete threeCtx.animateCallbacks[\"dolly\"];\n\t\t\t\t\t\t\t\tTWEEN.remove(threeCtx.dolly);\n\t\t\t\t\t\t\t\tdelete threeCtx.dolly;\n\t\t\t\t\t\t\t\tthreeCtx.animControl.stop(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"move\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tresolve(MoveCamera(options));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\n\t\t\t\tdefault:\n\t\t\t\t\treject(new Error(\"ViewControl: unsupported command \" + cmd));\n\t\t\t}\n\t\t});\n\t\treturn promise;\n\t}\n\n\tfunction SpinCamera(options) {\n\t\tfunction GetKalman() {\n\t\t\tvar R = .001;\n\t\t\tif(typeof options.smooth!=\"undefined\")\n\t\t\t\tR = options.smooth;\n\t\t\treturn new KalmanFilter({R: R});\n\t\t}\n\t\tvar kalman = {\n\t\t\tx: GetKalman(),\n\t\t\ty: GetKalman(),\n\t\t}\n\t\tvar x0 = threeCtx.cameraControls.camTarget.x;\n\t\tvar y0 = threeCtx.cameraControls.camTarget.z;\n\t\tvar x1 = threeCtx.body.position.x;\n\t\tvar y1 = threeCtx.body.position.z;\n\t\tvar angle0 = Math.atan2(y1-y0,x1-x0);\n\t\tvar angle1 = angle0 - 2 * Math.PI;\n\t\tif(options.direction==\"ccw\")\n\t\t\tangle1 = angle0 + 2 * Math.PI;\n\t\tvar radius = Math.sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));\n\t\tif(threeCtx.dolly) \n\t\t\tTWEEN.remove(threeCtx.dolly);\n\t\tvar state = {};\n\t\tfunction StartSpinning() {\n\t\t\tstate.angle = angle0;\n\t\t\tthreeCtx.dolly = new TWEEN.Tween(state).to({ angle: angle1 }, (options.speed || 30) * 1000)\n\t\t\t\t\t.onComplete( function() {\n\t\t\t\t\t\tStartSpinning();\n\t\t\t\t\t})\n\t\t\t\t\t.onUpdate( function() {\n\t\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t\t}).start();\n\t\t}\n\t\tthreeCtx.animateCallbacks[\"dolly\"] = {\n\t\t\t_this: null,\n\t\t\tcallback: function() {\n\t\t\t\tthreeCtx.body.position.x = kalman.x.filter(x0 + radius * Math.cos(state.angle));\n\t\t\t\tthreeCtx.body.position.z = kalman.y.filter(y0 + radius * Math.sin(state.angle));\n\t\t\t}\n\t\t};\n\t\tStartSpinning();\n\t\tthreeCtx.animControl.trigger();\n\n\t}\n\n\tfunction MoveCamera(options) {\n\t\tfunction GetKalman() {\n\t\t\tvar R = .001;\n\t\t\tif(typeof options.smooth!=\"undefined\")\n\t\t\t\tR = options.smooth;\n\t\t\treturn new KalmanFilter({R: R});\n\t\t}\n\t\tvar kalman = {\n\t\t\tx: GetKalman(),\n\t\t\ty: GetKalman(),\n\t\t\tz: GetKalman(),\n\t\t\ttargetX: GetKalman(),\n\t\t\ttargetY: GetKalman(),\n\t\t\ttargetZ: GetKalman()\n\t\t}\n\t\tvar state = {\n\t\t\tx: threeCtx.body.position.x,\n\t\t\ty: threeCtx.body.position.y,\n\t\t\tz: threeCtx.body.position.z,\n\t\t\ttargetX: threeCtx.cameraControls.camTarget.x,\n\t\t\ttargetY: threeCtx.cameraControls.camTarget.y,\n\t\t\ttargetZ: threeCtx.cameraControls.camTarget.z\n\t\t}\n\t\tvar state1 = {\n\t\t\tx: options.camera.x * SCALE3D,\n\t\t\tz: options.camera.y * SCALE3D,\n\t\t\ty: options.camera.z * SCALE3D,\n\t\t\ttargetX: options.camera.targetX * SCALE3D,\n\t\t\ttargetZ: options.camera.targetY * SCALE3D,\n\t\t\ttargetY: options.camera.targetZ * SCALE3D\n\t\t}\n\t\tvar finalCamera = new THREE.Vector3(state1.x, state1.y, state1.z);\n\t\tvar finalTarget = new THREE.Vector3(state1.targetX, state1.targetY, state1.targetZ);\n\t\tif(threeCtx.dolly)\n\t\t\tTWEEN.remove(threeCtx.dolly);\n\t\tthreeCtx.dolly = new TWEEN.Tween(state).to(state1, options.speed * 1000)\n\t\t\t\t.onUpdate( function() {\n\t\t\t\t\tthreeCtx.animControl.trigger();\n\t\t\t\t}).start();\n\t\tthreeCtx.animateCallbacks[\"dolly\"] = {\n\t\t\t_this: null,\n\t\t\tcallback: function() {\n\t\t\t\tthreeCtx.body.position.x = kalman.x.filter(state.x);\n\t\t\t\tthreeCtx.body.position.y = kalman.y.filter(state.y);\n\t\t\t\tthreeCtx.body.position.z = kalman.z.filter(state.z);\n\t\t\t\tthreeCtx.cameraControls.camTarget.x = kalman.targetX.filter(state.targetX);\n\t\t\t\tthreeCtx.cameraControls.camTarget.y = kalman.targetY.filter(state.targetY);\n\t\t\t\tthreeCtx.cameraControls.camTarget.z = kalman.targetZ.filter(state.targetZ);\n\t\t\t\tvar cameraVec = new THREE.Vector3(\n\t\t\t\t\tthreeCtx.body.position.x,\n\t\t\t\t\tthreeCtx.body.position.y,\n\t\t\t\t\tthreeCtx.body.position.z);\n\t\t\t\tif(cameraVec.distanceTo(finalCamera)<.1) {\n\t\t\t\t\tvar targetVec = new THREE.Vector3(\n\t\t\t\t\t\tthreeCtx.cameraControls.camTarget.x,\n\t\t\t\t\t\tthreeCtx.cameraControls.camTarget.y,\n\t\t\t\t\t\tthreeCtx.cameraControls.camTarget.z);\n\t\t\t\t\tif(targetVec.distanceTo(finalTarget)<.1) {\n\t\t\t\t\t\tdelete threeCtx.animateCallbacks[\"dolly\"];\n\t\t\t\t\t\tTWEEN.remove(threeCtx.dolly);\n\t\t\t\t\t\tdelete threeCtx.dolly;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthreeCtx.animControl.trigger();\n\t}\n\n\tView.Board.Display = function (aGame) {\n\t\t//Log(\"### View.Board.Display\");\n\t\tthis.xdDisplay(xdv, aGame);\n\t\t//xdv.listScene();\n\t}\n\n\tView.Board.xdInput = function (xdv, aGame) {\n\t\tconsole.error(\"View.Board.xdInput must be overriden\");\n\t\treturn {\n\t\t\tinitial: {},\n\t\t\tgetActions: function (moves, currentInput) {\n\t\t\t\treturn {};\n\t\t\t},\n\t\t}\n\t}\n\n\tView.Board.xdBuildHTStateMachine = function (xdv, htsm, aGame) {\n\t\tvar $this = this;\n\t\tvar inputSpec;\n\t\tvar clickGadgets = {}, viewGadgets = {}, highlightGadgets = [];\n\t\tvar inputStack, movesStack, actionStack;\n\t\tfunction Click(action, mode) {\n\t\t\tif (mode == \"select\")\n\t\t\t\thtsm.smQueueEvent(\"E_ACTION\", { action: action });\n\t\t\telse if (mode == \"cancel\")\n\t\t\t\thtsm.smQueueEvent(\"E_CANCEL\", { action: action });\n\t\t}\n\t\tfunction Init(args) {\n\t\t\tinputSpec = $this.xdInput(xdv, aGame);\n\t\t\tinputStack = [inputSpec.initial];\n\t\t\t// ensures moves are not duplicated\n\t\t\tvar movesMap = {};\n\t\t\t$this.mMoves.forEach(function (move) {\n\t\t\t\tmovesMap[JSON.stringify(move)] = move;\n\t\t\t});\n\t\t\tvar moves = [];\n\t\t\tfor (var m in movesMap)\n\t\t\t\tmoves.push(movesMap[m]);\n\t\t\tmovesStack = [moves];\n\t\t\tactionStack = [];\n\t\t}\n\t\tfunction ShowFurnitures(args) {\n\t\t\tif (inputSpec.furnitures)\n\t\t\t\tinputSpec.furnitures.forEach(function (gadget) {\n\t\t\t\t\txdv.updateGadget(gadget, {\n\t\t\t\t\t\tbase: {\n\t\t\t\t\t\t\tvisible: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t}\n\t\tfunction HideFurnitures(args) {\n\t\t\tif (inputSpec.furnitures)\n\t\t\t\tinputSpec.furnitures.forEach(function (gadget) {\n\t\t\t\t\txdv.updateGadget(gadget, {\n\t\t\t\t\t\tbase: {\n\t\t\t\t\t\t\tvisible: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t}\n\t\tfunction SetAction(action, mode) {\n\t\t\tif (mode == \"select\") {\n\t\t\t\tif (action.pre)\n\t\t\t\t\taction.pre.call($this);\n\t\t\t\tif (action.cancel)\n\t\t\t\t\taction.cancel.forEach(function (gid) {\n\t\t\t\t\t\tclickGadgets[gid] = true;\n\t\t\t\t\t\txdv.updateGadget(gid, {\n\t\t\t\t\t\t\tbase: {\n\t\t\t\t\t\t\t\tclick: function () {\n\t\t\t\t\t\t\t\t\tClick(action, \"cancel\");\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t}\n\t\t\tif (action.click)\n\t\t\t\taction.click.forEach(function (gid) {\n\t\t\t\t\tclickGadgets[gid] = true;\n\t\t\t\t\txdv.updateGadget(gid, {\n\t\t\t\t\t\tbase: {\n\t\t\t\t\t\t\tclick: function () {\n\t\t\t\t\t\t\t\tClick(action, mode);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\tif (typeof action.highlight == \"function\") {\n\t\t\t\tif (typeof action.unhighlight != \"function\")\n\t\t\t\t\tconsole.warn(\"No unhighlight function defined for\", action);\n\t\t\t\telse\n\t\t\t\t\thighlightGadgets.push(function () {\n\t\t\t\t\t\taction.unhighlight.call($this, mode);\n\t\t\t\t\t});\n\t\t\t\taction.highlight.call($this, mode);\n\t\t\t}\n\t\t\tif (action.view)\n\t\t\t\taction.view.forEach(function (gid) {\n\t\t\t\t\tviewGadgets[gid] = true;\n\t\t\t\t\txdv.updateGadget(gid, {\n\t\t\t\t\t\tbase: {\n\t\t\t\t\t\t\tvisible: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t}\n\t\tfunction PrepareAction(args) {\n\t\t\tvar nextActions = inputSpec.getActions.call($this, movesStack[movesStack.length - 1], inputStack[inputStack.length - 1]);\n\t\t\tif (nextActions == null) {\n\t\t\t\thtsm.smQueueEvent(\"E_MOVE_DONE\", { move: movesStack[movesStack.length - 1][0] });\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar actionsCount = 0;\n\t\t\tvar action0;\n\t\t\tfor (var action in nextActions) {\n\t\t\t\taction0 = nextActions[action];\n\t\t\t\tactionsCount++;\n\t\t\t}\n\t\t\tif (actionsCount > 1 || (inputStack.length == 1 && !inputSpec.allowForced) || (actionsCount == 1 && !aGame.mAutoComplete && !action0.skipable)) {\n\t\t\t\tfor (var actId in nextActions) {\n\t\t\t\t\tvar action = nextActions[actId];\n\t\t\t\t\taction.forced = false;\n\t\t\t\t\tSetAction(action, \"select\");\n\t\t\t\t}\n\t\t\t} else if (actionsCount == 0) {\n\t\t\t\thtsm.smQueueEvent(\"E_MOVE_DONE\", { move: actionStack[actionStack.length - 1].moves[0] });\n\t\t\t} else {\n\t\t\t\taction0.forced = true;\n\t\t\t\thtsm.smQueueEvent(\"E_ACTION\", { action: action0 });\n\t\t\t}\n\t\t}\n\t\tfunction SendMove(args) {\n\t\t\taGame.HumanMove(args.move);\n\t\t}\n\t\tfunction Clean(args) {\n\t\t\tfor (var gid in clickGadgets)\n\t\t\t\txdv.updateGadget(gid, {\n\t\t\t\t\tbase: {\n\t\t\t\t\t\tclick: null,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\tclickGadgets = {};\n\t\t\tfor (var gid in viewGadgets)\n\t\t\t\txdv.updateGadget(gid, {\n\t\t\t\t\tbase: {\n\t\t\t\t\t\tvisible: false,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\tviewGadgets = {};\n\t\t\tfor (var i = 0; i < highlightGadgets.length; i++)\n\t\t\t\thighlightGadgets[i].call($this);\n\t\t}\n\t\tfunction Execute(action, callback) {\n\t\t\tif (action.execute) {\n\t\t\t\tvar actions = action.execute;\n\t\t\t\tif (typeof actions == \"function\")\n\t\t\t\t\tactions = [actions];\n\t\t\t\tvar actionsCount = 0;\n\t\t\t\tfunction ActionDone(action) {\n\t\t\t\t\tif (--actionsCount == 0)\n\t\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t\tactions.forEach(function (action) {\n\t\t\t\t\tactionsCount++;\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\taction.call($this, ActionDone);\n\t\t\t\t\t}, 0);\n\t\t\t\t});\n\t\t\t} else\n\t\t\t\tcallback();\n\t\t}\n\t\tfunction Action(args) {\n\t\t\tmovesStack.push(args.action.moves);\n\t\t\tExecute(args.action, function () {\n\t\t\t\thtsm.smQueueEvent(\"E_DONE\", { action: args.action });\n\t\t\t});\n\t\t}\n\t\tfunction PostAction(args) {\n\t\t\tif (args.action.post)\n\t\t\t\targs.action.post.call($this);\n\t\t}\n\t\tfunction SetCancel(args) {\n\t\t\tif (actionStack.length > 0 && !actionStack[actionStack.length - 1].noAutoCancel)\n\t\t\t\tSetAction(actionStack[actionStack.length - 1], \"cancel\");\n\t\t}\n\t\tfunction Validate(args) {\n\t\t\tinputStack.push($.extend(true, {}, inputStack[inputStack.length - 1], args.action.validate));\n\t\t}\n\t\tfunction Cancel(args) {\n\t\t\twhile (actionStack.length > 0) {\n\t\t\t\tvar action = actionStack.pop();\n\t\t\t\tinputStack.pop();\n\t\t\t\tmovesStack.pop();\n\t\t\t\tif (action.unexecute)\n\t\t\t\t\taction.unexecute.call($this);\n\t\t\t\tif (action.post)\n\t\t\t\t\taction.post.call($this);\n\t\t\t\tif (action.forced == false)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfunction PushAction(args) {\n\t\t\tactionStack.push(args.action);\n\t\t}\n\t\thtsm.smTransition(\"S_INIT\", \"E_INIT\", \"S_WAIT_ACTION\", [Init, ShowFurnitures]);\n\t\thtsm.smEntering(\"S_WAIT_ACTION\", [PrepareAction, SetCancel]);\n\t\thtsm.smLeaving(\"S_WAIT_ACTION\", [Clean]);\n\t\thtsm.smTransition(\"S_WAIT_ACTION\", \"E_ACTION\", \"S_ACTION\", [PushAction, Validate, Action]);\n\t\thtsm.smTransition(\"S_WAIT_ACTION\", \"E_CANCEL\", null, [Cancel, Clean, PrepareAction, SetCancel]);\n\t\thtsm.smTransition(\"S_WAIT_ACTION\", \"E_MOVE_DONE\", \"S_DONE\", [SendMove, HideFurnitures]);\n\t\thtsm.smTransition([\"S_WAIT_ACTION\", \"S_ACTION\"], \"E_END\", \"S_DONE\", []);\n\t\thtsm.smTransition(\"S_ACTION\", \"E_DONE\", \"S_WAIT_ACTION\", [PostAction]);\n\t\thtsm.smTransition(\"S_DONE\", \"E_END\", null, [HideFurnitures]);\n\t}\n\n\tView.Board.HumanTurn = function (aGame) {\n\t\t//Log(\"### View.Board.HumanTurn\");\n\t\tvar $this = this;\n\t\thtStateMachine = new HTStateMachine();\n\t\thtStateMachine.init();\n\t\tthis.xdBuildHTStateMachine(xdv, htStateMachine, aGame);\n\t\thtStateMachine.smSetInitialState(\"S_INIT\");\n\t\thtStateMachine.smQueueEvent(\"E_INIT\", {});\n\t\thtStateMachine.smPlay();\n\t}\n\n\tView.Board.HumanTurnEnd = function (aGame) {\n\t\t//Log(\"### View.Board.HumanTurnEnd\");\n\t\tif (htStateMachine) {\n\t\t\thtStateMachine.smQueueEvent(\"E_END\", {});\n\t\t\thtStateMachine = null;\n\t\t}\n\t}\n\n\tView.Board.PlayedMove = function (aGame, aMove) {\n\t\t//Log(\"### View.Board.PlayedMove\");\n\t\treturn this.xdPlayedMove(xdv, aGame, aMove);\n\t}\n\n\tView.Board.xdShowEnd = function (xdv, aGame) {\n\t\treturn true;\n\t}\n\n\tView.Board.ShowEnd = function (aGame) {\n\t\treturn this.xdShowEnd(xdv, aGame);\n\t}\n\n\t/* ======================================== */\n\n\tvar THREEx_boundContext = \"\" + Math.random();\n\n\tfunction BuildThree(aGame, areaWidth, areaHeight) {\n\n\t\tvar camera = new THREE.PerspectiveCamera(55, (area.width() / area.height()), 1, 4000);\n\n\t\tvar scene = new THREE.Scene();\n\n\t\tvar body = new THREE.Object3D();\n\t\tscene.add(body);\n\t\tbody.add(camera);\n\n\t\tvar harbor = new THREE.Object3D();\n\t\tscene.add(harbor);\n\n\t\tvar ambientLight = new THREE.AmbientLight(0xbbbbbb);\n\t\tharbor.add(ambientLight);\n\n\t\tvar light = new THREE.SpotLight(0xffffff, 1.75, 0, 1.05, 1, 2);  // test params here https://threejs.org/docs/?q=SpotLight#Reference/Lights/SpotLight\n\t\tlight.position.set(-12, 12, 12);\n\n\t\tlight.castShadow = true;\n\t\t//light.shadowDarkness = .75;\n\n\t\tlight.shadow.camera.near = 1;\n\t\tlight.shadow.camera.far = 27;\n\t\tlight.shadow.camera.fov = 90;\n\n\t\tlight.shadow.mapSize.width = 4096;\n\t\tlight.shadow.mapSize.height = 4096;\n\n\t\tlight.target = harbor;\n\n\t\tharbor.add(light);\n\n\t\tvar skylight = new THREE.PointLight(0xcccccc, 2, 150);//, Math.PI/5, 10);\n\t\tskylight.position.set(-45, 45, 45);\n\t\tharbor.add(skylight);\n\n\t\t//light.shadowCameraVisible = false;\n\t\t// skylight.shadowCameraVisible = true; nonsens! PointLight objects don't have shadow feature\n\n\t\tvar renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n\t\trenderer.setSize(area.width(), area.height());\n\t\t//renderer.setClearColor( scene.fog.color, 1 );\n\n\t\tvar projector = new THREE.Projector();\n\n\t\tarea.append($(renderer.domElement));\n\n\t\trenderer.gammaInput = true;\n\t\trenderer.gammaOutput = true;\n\t\t//renderer.shadowMapEnabled = true;\n\t\trenderer.shadowMap.enabled = true;\n\t\trenderer.shadowMapSoft = true;\n\t\t//renderer.physicallyBasedShading = true; // gives high level of shininess specular\n\t\t//renderer.shadowMapCascade = true;\n\n\t\tvar stereo = false;\n\t\tvar stereoEffect = new THREE.StereoEffect(renderer);\n\t\tstereoEffect.setSize(area.width(), area.height());\n\n\t\tvar anaglyphEffect = new THREE.AnaglyphEffect(renderer);\n\t\tanaglyphEffect.setSize(area.width(), area.height());\n\n\t\tvar gamepads = new VRGamepads({\n\t\t\tcamera: camera,\n\t\t\tscene: scene,\n\t\t\tresBase: aGame.config.baseURL + \"res/vr/\",\n\t\t\tdrag: function (position, direction, pointerObject, pointerRescale) {\n\t\t\t\tvar intersectPoint = null;\n\t\t\t\tvar pointedObject = null;\n\t\t\t\tVRGetIntersect(position, direction, function (object, point) {\n\t\t\t\t\tintersectPoint = point;\n\t\t\t\t\tpointedObject = object;\n\t\t\t\t});\n\t\t\t\treturn intersectPoint ? {\n\t\t\t\t\tpoint: intersectPoint,\n\t\t\t\t\tobject: pointedObject\n\t\t\t\t} : null;\n\t\t\t},\n\t\t\tclick: function (position, direction) {\n\t\t\t\tVRGetIntersect(position, direction, function (object, point) {\n\t\t\t\t\tif (object)\n\t\t\t\t\t\tTHREE.Object3D._threexDomEvent._notify(\"mouseup\", object, null, point);\n\t\t\t\t});\n\t\t\t},\n\t\t\tmove: function (step) {\n\t\t\t\tbody.position.add(step);\n\t\t\t}\n\t\t});\n\n\t\tvar vrRay = new THREE.Raycaster();\n\n\t\tvar camAnim = !!aGame.mViewOptions.camAnim;\n\n\t\tvar animateCallbacks = {};\n\n\t\tvar frameBacklog = 0;\n\n\t\tfunction AnimControl() {\n\t\t\tthis.animating = false;\n\t\t\tthis.animateTimer = null;\n\t\t\tthis.nextStop = 0;\n\t\t}\n\t\tAnimControl.prototype = {\n\t\t\tstart: function () {\n\t\t\t\tbody.updateMatrixWorld();\n\t\t\t\tif (this.animateTimer != null) {\n\t\t\t\t\tclearTimeout(this.animateTimer);\n\t\t\t\t\tthis.animateTimer = null;\n\t\t\t\t}\n\t\t\t\tif (this.animating == false) {\n\t\t\t\t\tthis.animating = true;\n\t\t\t\t\tthis.animate();\n\t\t\t\t}\n\t\t\t},\n\t\t\tstop: function (delay) {\n\t\t\t\tif (threeCtx && vr.vrEffect && vr.vrEffect.isPresenting) {\n\t\t\t\t\tif (this.animateTimer != null) {\n\t\t\t\t\t\tclearTimeout(this.animateTimer);\n\t\t\t\t\t\tthis.animateTimer = null;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (delay === undefined)\n\t\t\t\t\tdelay = 200;\n\t\t\t\tvar now = Date.now();\n\t\t\t\tvar $this = this;\n\t\t\t\tif (this.animating) {\n\t\t\t\t\tif (this.animateTimer != null) {\n\t\t\t\t\t\tif (this.nextStop < now + delay)\n\t\t\t\t\t\t\tclearTimeout(this.animateTimer);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.nextStop = Math.max(this.nextStop, now + delay);\n\t\t\t\t\tthis.animateTimer = setTimeout(function () {\n\t\t\t\t\t\t$this.animateTimer = null;\n\t\t\t\t\t\t$this.animating = false;\n\t\t\t\t\t}, this.nextStop - now);\n\t\t\t\t}\n\t\t\t},\n\t\t\ttrigger: function () {\n\t\t\t\tif (!this.animating || this.animateTimer != null) {\n\t\t\t\t\tthis.start();\n\t\t\t\t\tthis.stop.apply(this, arguments);\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimate: function () {\n\t\t\t\tvar $this = this;\n\t\t\t\tvar statsCurrentSec = 0;\n\t\t\t\tvar statsTic = 0;\n\t\t\t\tvar renderSum = 0;\n\t\t\t\tvar renderCount = 0;\n\n\t\t\t\tfunction Animate(timestamp) {\n\t\t\t\t\tframeBacklog--;\n\t\t\t\t\tvar t0, t1;\n\t\t\t\t\tvar showStats = false;\n\t\t\t\t\tif (showStats) {\n\t\t\t\t\t\tvar sec = Math.floor(Date.now() / 1000);\n\t\t\t\t\t\tif (sec == statsCurrentSec)\n\t\t\t\t\t\t\tstatsTic++;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (statsTic > 0) {\n\t\t\t\t\t\t\t\tvar rate = Math.round(1000 * renderSum / renderCount) / 1000;\n\t\t\t\t\t\t\t\tvar lag = Math.round(1000 * (window.performance.now() - timestamp)) / 1000;\n\t\t\t\t\t\t\t\t/*\n                                console.log(\"fps\",statsTic,\"render\",rate,\"ms\",\"\",\n                                            \"lag\",lag,\"ms\",\"\",\n                                            \"frame backlog\",frameBacklog);\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t$(statsPanel).text(\"fps \" + statsTic);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstatsTic = 1;\n\t\t\t\t\t\t\tstatsCurrentSec = sec;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($this.animating) {\n\t\t\t\t\t\tframeBacklog++;\n\t\t\t\t\t\trequestAnimationFrame(Animate);\n\t\t\t\t\t}\n\t\t\t\t\tTWEEN.update();\n\t\t\t\t\tif (showStats)\n\t\t\t\t\t\tt0 = Date.now();\n\t\t\t\t\tif (vr.vrEffect && vr.vrEffect.isPresenting) {\n\t\t\t\t\t\tgamepads.update();\n\t\t\t\t\t\tvar harborpad = gamepads.getHarborPad();\n\t\t\t\t\t\tif (harborpad) {\n\t\t\t\t\t\t\tharborpad.visible = false;\n\t\t\t\t\t\t\tharborpad.getWorldPosition(ctx.harbor.position);\n\t\t\t\t\t\t\tvar scale = (harborpad.getAxes()[1] + 1.1) * .03;\n\t\t\t\t\t\t\tctx.harbor.scale.set(scale, scale, scale);\n\t\t\t\t\t\t\tharborpad.getWorldQuaternion(ctx.harbor.quaternion);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.harbor.position.set(0, 0, 0);\n\t\t\t\t\t\t\tctx.harbor.scale.set(1, 1, 1);\n\t\t\t\t\t\t\tctx.harbor.quaternion.copy(ctx.defaultHarborQuaternion);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvr.vrControls.update();\n\t\t\t\t\t\tvr.vrEffect.render(scene, camera);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!arStream) {\n\t\t\t\t\t\t\tctx.harbor.position.set(0, 0, 0);\n\t\t\t\t\t\t\tctx.harbor.scale.set(1, 1, 1);\n\t\t\t\t\t\t\tctx.harbor.quaternion.copy(ctx.defaultHarborQuaternion);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n                        if(gamepads)\n                            gamepads.clearAll();\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (!arStream) {\n\t\t\t\t\t\t\tcameraControls.update();\n\t\t\t\t\t\t\tcameraOrientationControls.update();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stereo) {\n\t\t\t\t\t\t\tgamepads.update();\n\t\t\t\t\t\t\tstereoEffect.render(scene, camera);\n\t\t\t\t\t\t} else if (ctx.anaglyph || aGame.mAnaglyph)\n\t\t\t\t\t\t\tanaglyphEffect.render(scene, camera);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\trenderer.render(scene, camera);\n\t\t\t\t\t}\n\t\t\t\t\tif (showStats) {\n\t\t\t\t\t\tt1 = Date.now();\n\t\t\t\t\t\trenderSum += t1 - t0;\n\t\t\t\t\t\trenderCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var cbi in animateCallbacks) {\n\t\t\t\t\t\tvar cb = animateCallbacks[cbi];\n\t\t\t\t\t\tcb.callback.call(cb._this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tframeBacklog++;\n\t\t\t\tAnimate(window.performance.now());\n\t\t\t},\n\t\t}\n\t\tvar animControl = new AnimControl();\n\n\t\tvar statsPanel = null;\n\n\t\tvar cameraControls = new THREE.OrbitControls(camera, body, renderer.domElement);\n\n\t\t$.extend(cameraControls, {\n\t\t\tautoRotate: camAnim,\n\t\t\tanimControl: animControl,\n\t\t});\n\t\tcameraControls.camTarget.set(0, 0.8, 0);\n\n\t\tvar canOrientation = false;\n\t\tvar cameraOrientationControls = new THREE.DeviceOrientationControls(body, function (controls) {\n\t\t\tif (typeof vr != \"undefined\")\n\t\t\t\tanimControl.trigger();\n\t\t\tif (!canOrientation && controls.enabled) {\n\t\t\t\tcanOrientation = true;\n\t\t\t\tarea.find(\".vr-button\").show();\n\t\t\t}\n\t\t});\n\n\n\t\tif (typeof cameraControls.addEventListener == \"function\")\n\t\t\tcameraControls.addEventListener('change', function () {\n\t\t\t\tanimControl.trigger();\n\t\t\t});\n\n\t\tvar ctx = {\n\t\t\tscene: scene,\n\t\t\trenderer: renderer,\n\t\t\tlight: light,\n\t\t\tskyLight: skylight,\n\t\t\tambientLight: ambientLight,\n\t\t\tloader: new THREE.JSONLoader(),\n\t\t\tcamera: camera,\n\t\t\tcameraControls: cameraControls,\n\t\t\tanimateCallbacks: animateCallbacks,\n\t\t\tcamTarget: cameraControls.camTarget,\n\t\t\tanimControl: animControl,\n\t\t\tbody: body,\n\t\t\tharbor: harbor,\n\t\t\tdefaultHarborQuaternion: harbor.quaternion.clone(),\n\t\t\tanaglyphEffect: anaglyphEffect,\n\t\t\tanaglyph: false\n\t\t};\n\n\t\tfunction VRGetIntersect(position, direction, callback) {\n\t\t\tvar threexDomEvent = THREE.Object3D._threexDomEvent;\n\t\t\tvrRay.set(position, direction);\n\t\t\ttry {\n\t\t\t\tvar intersects = vrRay.intersectObjects(threexDomEvent._boundObjs[threexDomEvent._boundContext]);\n\t\t\t} catch (e) {\n\t\t\t\treturn callback(null, null);\n\t\t\t}\n\t\t\tif (intersects.length == 0)\n\t\t\t\treturn callback(null, null);\n\t\t\tvar intersect = intersects[0];\n\t\t\tvar object3d = threexDomEvent.getRootObject(intersect.object);\n\t\t\tvar objectCtx = threexDomEvent._objectCtxGet(object3d);\n\t\t\tif (!objectCtx)\n\t\t\t\tcallback(null, null);\n\t\t\telse\n\t\t\t\tcallback(object3d, intersect.point);\n\t\t}\n\n\t\tfunction VRSetup(ctx) {\n\n\t\t\tfunction LookAtHarbor() {\n\t\t\t\tvr.vrControls.resetPose();\n\t\t\t}\n\n\t\t\tfunction MakeButton() {\n\t\t\t\tctx.vrButton = document.createElement(\"img\");\n\t\t\t\tctx.vrButton.className = \"vr-button\";\n\t\t\t\tctx.vrButton.setAttribute(\"data-vr-enter-src\", aGame.config.baseURL + \"res/vr/vr-enter.png\");\n\t\t\t\tctx.vrButton.setAttribute(\"data-vr-exit-src\", aGame.config.baseURL + \"res/vr/vr-exit.png\");\n\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-enter-src\"));\n\t\t\t\tObject.assign(ctx.vrButton.style, {\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tbottom: \"8px\",\n\t\t\t\t\tright: \"8px\",\n\t\t\t\t\tcursor: \"pointer\",\n\t\t\t\t\t\"z-index\": 2147483647\n\t\t\t\t});\n\t\t\t\tarea[0].appendChild(ctx.vrButton);\n\t\t\t}\n\n\t\t\tfunction CardboardVR() {\n\t\t\t\tMakeButton();\n\t\t\t\tctx.vrButton.style.display = \"none\";\n\t\t\t\tctx.vrButton.addEventListener(\"click\", function () {\n\t\t\t\t\tif (stereo) {\n\t\t\t\t\t\tstereo = false;\n\t\t\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-enter-src\"));\n\t\t\t\t\t\tvar size = renderer.getSize();\n\t\t\t\t\t\trenderer.setViewport(0, 0, size.width, size.height);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstereo = true;\n\t\t\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-exit-src\"));\n\t\t\t\t\t}\n\t\t\t\t\tanimControl.trigger();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction PureVR() {\n\t\t\t\tMakeButton();\n\t\t\t\tvar vrControls = new THREE.VRControls(ctx.camera);\n\t\t\t\tvr.vrControls = vrControls;\n\t\t\t\tif (window.lastVrEffect) {\n\t\t\t\t\tif (window.lastVrEffect.isPresenting)\n\t\t\t\t\t\twindow.lastVrEffect.exitPresent();\n\t\t\t\t}\n\t\t\t\tvar vrEffect = new THREE.VREffect(ctx.renderer);\n\t\t\t\tvr.vrEffect = vrEffect;\n\t\t\t\twindow.lastVrEffect = vrEffect;\n\n\t\t\t\twindow.addEventListener('vrdisplaypresentchange', function (event) {\n\t\t\t\t\tctx.animControl.trigger()\n\t\t\t\t}, false);\n\n\t\t\t\tctx.vrButton.addEventListener(\"click\", function () {\n\t\t\t\t\tif (vrEffect.isPresenting) {\n\t\t\t\t\t\tvrEffect.exitPresent();\n\t\t\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-enter-src\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvrEffect.requestPresent();\n\t\t\t\t\t\tctx.vrButton.setAttribute(\"src\", ctx.vrButton.getAttribute(\"data-vr-exit-src\"));\n\t\t\t\t\t\tLookAtHarbor();\n\t\t\t\t\t}\n\t\t\t\t\tanimControl.trigger();\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\tvr = {};\n\n\t\t\tif (typeof navigator.getVRDisplays != \"undefined\") {\n\t\t\t\tnavigator.getVRDisplays()\n\t\t\t\t\t.then(function (displays) {\n\t\t\t\t\t\tif (displays.length == 0)\n\t\t\t\t\t\t\tCardboardVR();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tPureVR();\n\t\t\t\t\t}).catch(function () {\n\t\t\t\t\t\tCardboardVR();\n\t\t\t\t\t});\n\t\t\t} else\n\t\t\t\tCardboardVR();\n\n\t\t\treturn vr;\n\t\t}\n\n\t\tvar vr = VRSetup(ctx);\n\n\t\treturn $.extend(ctx, vr);\n\t}\n\n\n\tfunction GetEventPosition(event) {\n\t\tif (event.originalEvent)\n\t\t\treturn GetEventPosition(event.originalEvent);\n\t\tif (event.changedTouches && event.changedTouches.length > 0)\n\t\t\treturn [event.changedTouches[0].pageX, event.changedTouches[0].pageY];\n\t\tif (event.touches && event.touches.length > 0)\n\t\t\treturn [event.touches[0].pageX, event.touches[0].pageY];\n\t\treturn [event.pageX, event.pageY];\n\t}\n\n\tfunction AR(stream) {\n\t\tif (!!arStream == !!stream) {\n\t\t\tconsole.warn(\"AR is already\", !!stream);\n\t\t\treturn;\n\t\t}\n\t\tarStream = stream;\n\t\tif (arStream) {\n\t\t\tvar video = $(\"<video/>\").addClass(\"ar-video\").attr(\"autoplay\", \"autoplay\").css({\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: 0,\n\t\t\t\twidth: \"100%\",\n\t\t\t\theight: \"100%\",\n\t\t\t\tleft: 0,\n\t\t\t\t\"z-index\": -1,\n\t\t\t\tbackgroundColor: \"#0f0\",\n\t\t\t\tobjectFit: \"cover\"\n\t\t\t}).appendTo(area.parent());\n\t\t\tJoclyAR.attach({\n\t\t\t\telement: video[0],\n\t\t\t\tstream: arStream,\n\t\t\t\tthreeCtx: threeCtx\n\t\t\t});\n\t\t\txdv.redisplayGadgets();\n\t\t\tthreeCtx.renderer.setClearColor(new THREE.Color(threeCtx.world.color), 0);\n\t\t\tthreeCtx.animControl.trigger();\n\t\t} else {\n\t\t\tvar video = area.parent().find(\".ar-video\");\n\t\t\tif (video.length) {\n\t\t\t\tJoclyAR.detach({\n\t\t\t\t\telement: video[0]\n\t\t\t\t});\n\t\t\t\tvideo.remove();\n\t\t\t}\n\t\t\txdv.redisplayGadgets();\n\t\t\tthreeCtx.renderer.setClearColor(new THREE.Color(threeCtx.world.color), 1);\n\t\t\tthreeCtx.animControl.trigger();\n\t\t}\n\t}\n\n})();\n"]}