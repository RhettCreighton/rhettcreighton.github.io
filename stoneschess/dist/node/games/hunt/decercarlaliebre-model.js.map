{"version":3,"names":[],"mappings":"","sources":["hunt-model.js"],"sourcesContent":["/*\n *\n * Copyright (c) 2012 - Jocly - www.jocly.com\n * \n * This file is part of the Jocly game platform and cannot be used outside of this context without the written permission of Jocly.\n * \n */\n\nModel.Game.HuntInitGame = function() {\n\tthis.g.huntOptions={\n\t\tcompulsoryCatch: false,\n\t\tcatchLongestLine: false,\n\t\tmultipleCatch: true,\n\t};\n\tthis.g.huntEval={\n\t\tpieceCount: 1000000,\n\t\tfreeZone: 100,\n\t\tdist: 1000,\n\t};\n\tthis.g.RC=[];\n\tthis.g.Graph=[];\n\tthis.g.useDrop=false;\n\tthis.g.evaluate0=0;\n\tthis.g.debugEval=false;\n};\n\nModel.Game.HuntPostInitGame = function() {\n\tthis.HuntMakeDist();\n\tthis.zobrist=new JocGame.Zobrist({\n\t\tboard: {\n\t\t\ttype: \"array\",\n\t\t\tsize: this.g.Graph.length,\n\t\t\tvalues: [\"1\",\"-1\"],\n\t\t},\n\t\twho: {\n\t\t\tvalues: [\"1\",\"-1\"],\t\t\t\n\t\t}\n\t});\n\n};\n\nModel.Game.HuntMakeGrid = function(options) {\n\tvar opts={\n\t\trows: 5,\n\t\tcols: 5,\n\t\trow0: 0,\n\t\tcol0: 0,\n\t\tdirs: 4,\n\t};\n\tObject.assign(opts,options);\n\t\n\tvar posByRC={},pos,r,c;\n\t\n\tvar base=this.g.RC.length;\n\tfor(r=0;r<opts.rows;r++)\n\t\tfor(c=0;c<opts.cols;c++) {\n\t\t\tpos=base+r*opts.cols+c;\n\t\t\tthis.g.RC[pos]=[r+opts.row0,c+opts.col0];\n\t\t\tposByRC[\"\"+r+\",\"+c]=pos;\n\t\t}\n\tfor(pos=0;pos<this.g.RC.length;pos++) {\n\t\tr=this.g.RC[pos][0];\n\t\tc=this.g.RC[pos][1];\n\t\tvar graph=[];\n\t\tvar pos1=posByRC[\"\"+(r-1)+\",\"+c];\n\t\tif(typeof pos1 != \"undefined\")\n\t\t\tgraph.push(pos1);\n\t\telse\n\t\t\tgraph.push(null);\n\t\tpos1=posByRC[\"\"+(r+1)+\",\"+c];\n\t\tif(typeof pos1 != \"undefined\")\n\t\t\tgraph.push(pos1);\n\t\telse\n\t\t\tgraph.push(null);\n\t\tpos1=posByRC[\"\"+r+\",\"+(c-1)];\n\t\tif(typeof pos1 != \"undefined\")\n\t\t\tgraph.push(pos1);\n\t\telse\n\t\t\tgraph.push(null);\n\t\tpos1=posByRC[\"\"+r+\",\"+(c+1)];\n\t\tif(typeof pos1 != \"undefined\")\n\t\t\tgraph.push(pos1);\n\t\telse\n\t\t\tgraph.push(null);\n\t\tfor(var i=graph.length;i<opts.dirs;i++)\n\t\t\tgraph.push(null);\n\t\tthis.g.Graph.push(graph);\n\t}\n};\n\nModel.Game.HuntMakeDist=function() {\n\tvar $this=this;\n\tvar pos, pos1, pos2, graph,d;\n\tthis.g.Dist=[];\n\tthis.g.DistMax=0;\n\tfunction SetDist(a,b,c) {\n\t\t$this.g.Dist[a][b]=c;\n\t\tif(c>$this.g.DistMax)\n\t\t\t$this.g.DistMax=c;\n\t}\n\tfor(var i=0;i<this.g.Graph.length;i++) {\n\t\tvar distLine=[];\n\t\tfor(var j=0;j<=i;j++) {\n\t\t\tdistLine.push(-1);\n\t\t}\n\t\tthis.g.Dist.push(distLine);\n\t}\n\tfor(pos=0;pos<this.g.Graph.length;pos++) {\n\t\tgraph=this.g.Graph[pos];\n\t\tfor(d=0;d<graph.length;d++) {\n\t\t\tpos1=graph[d];\n\t\t\tif(pos1!==null) {\n\t\t\t\tif(pos1<pos && this.g.Dist[pos-1][pos1]==-1) {\n\t\t\t\t\tSetDist(pos-1,pos1,1);\n\t\t\t\t} else if(pos1>pos && this.g.Dist[pos1-1][pos]==-1) {\n\t\t\t\t\tSetDist(pos1-1,pos,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvar updated=true;\n\tfor(var loop=1;updated;loop++) {\n\t\tupdated=false;\n\t\tfor(pos=1;pos<this.g.Graph.length;pos++) {\n\t\t\tfor(pos1=0;pos1<pos;pos1++) {\n\t\t\t\tif(this.g.Dist[pos-1][pos1]==loop) {\n\t\t\t\t\tgraph=this.g.Graph[pos1];\n\t\t\t\t\tfor(d=0;d<graph.length;d++) {\n\t\t\t\t\t\tpos2=graph[d];\n\t\t\t\t\t\tif(pos2!==null) {\n\t\t\t\t\t\t\tif(pos2<pos && this.g.Dist[pos-1][pos2]==-1) {\n\t\t\t\t\t\t\t\tSetDist(pos-1,pos2,loop+1);\n\t\t\t\t\t\t\t\tupdated=true;\n\t\t\t\t\t\t\t} else if(pos2>pos && this.g.Dist[pos2-1][pos]==-1) {\n\t\t\t\t\t\t\t\tSetDist(pos2-1,pos,loop+1);\n\t\t\t\t\t\t\t\tupdated=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgraph=this.g.Graph[pos];\n\t\t\t\t\tfor(d=0;d<graph.length;d++) {\n\t\t\t\t\t\tpos2=graph[d];\n\t\t\t\t\t\tif(pos2!==null) {\n\t\t\t\t\t\t\tif(pos2<pos1 && this.g.Dist[pos1-1][pos2]==-1) {\n\t\t\t\t\t\t\t\tSetDist(pos1-1,pos2,loop+1);\n\t\t\t\t\t\t\t\tupdated=true;\n\t\t\t\t\t\t\t} else if(pos2>pos1 && this.g.Dist[pos2-1][pos1]==-1) {\n\t\t\t\t\t\t\t\tSetDist(pos2-1,pos1,loop+1);\n\t\t\t\t\t\t\t\tupdated=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nModel.Game.HuntRemovePositions=function(positions) {\n\tvar gpos;\n\tvar repl={};\n\tvar index=0;\n\tpositions.sort(function(a,b) {\n\t\treturn a-b;\n\t});\n\tfor(gpos=0;gpos<this.g.Graph.length;gpos++) {\n\t\tif(positions.length>0 && gpos==positions[0])\n\t\t\tpositions.shift();\n\t\telse\n\t\t\trepl[gpos]=index++;\n\t}\n\tfor(gpos=0;gpos<this.g.Graph.length;gpos++) {\n\t\tif(typeof repl[gpos]==\"undefined\") {\n\t\t\tthis.g.Graph[gpos]=\"X\";\n\t\t\tcontinue;\n\t\t}\n\t\tvar graph=this.g.Graph[gpos];\n\t\tvar graph1=[];\n\t\tfor(var d=0;d<graph.length;d++) {\n\t\t\tvar npos=graph[d];\n\t\t\tif(npos!==null && typeof repl[npos]!=\"undefined\")\n\t\t\t\tgraph1.push(repl[npos]);\n\t\t\telse\n\t\t\t\tgraph1.push(null);\n\t\t}\n\t\tthis.g.Graph[gpos]=graph1;\n\t}\n\tvar graph0=[];\n\tvar rc0=[];\n\tfor(gpos=0;gpos<this.g.Graph.length;gpos++)\n\t\tif(typeof repl[gpos]!=\"undefined\") {\n\t\t\tgraph0.push(this.g.Graph[gpos]);\n\t\t\trc0.push(this.g.RC[gpos]);\n\t\t}\n\tthis.g.Graph=graph0;\n\tthis.g.RC=rc0;\n\tthis.g.PosName={};\n};\n\nModel.Game.HuntDist=function(pos0,pos1) {\n\tif(pos0==pos1)\n\t\treturn 0;\n\tif(pos1>pos0) {\n\t\tvar tmp=pos0;\n\t\tpos0=pos1;\n\t\tpos1=tmp;\n\t}\n\treturn this.g.Dist[pos0-1][pos1];\n};\n\nModel.Move.Init = function(args) {\n\tif(typeof args !=\"undefined\")\n\t\tthis.CopyFrom(args);\n};\n\nModel.Move.PosName={};\n\nModel.Move.ToString = function() {\n\tvar $this=this;\n\tvar str=\"\";\n\tfunction BuildSerie(field) {\n\t\tif(typeof $this[field]!=\"undefined\" && $this[field].length>0) {\n\t\t\tvar pName=[];\n\t\t\tfor(var i=0; i<$this[field].length; i++) {\n\t\t\t\tvar pos=$this[field][i];\n\t\t\t\tif(typeof $this.PosName[pos]!=\"undefined\")\n\t\t\t\t\tpName.push($this.PosName[pos]);\n\t\t\t\telse\n\t\t\t\t\tpName.push(pos);\n\t\t\t}\n\t\t\treturn pName.join(\",\");\n\t\t} else\n\t\t\treturn \"\";\n\t}\n\tstr+=BuildSerie('p');\n\tvar capt=BuildSerie('c');\n\tif(capt.length>0)\n\t\tstr+=\"x\"+capt;\n\treturn str;\n};\n\nModel.Move.Equals = function(move) {\n\tvar i;\n\tif(move===null)\n\t\treturn false;\n\tif(move.p.length!=this.p.length)\n\t\treturn false;\n\tfor(i=0;i<this.p.length;i++)\n\t\tif(move.p[i]!=this.p[i])\n\t\t\treturn false;\n\tif(move.c===undefined && this.c===undefined)\n\t\treturn true;\n\tif(move.c!==undefined && this.c!==undefined) {\n\t\tfor(i=0;i<this.c.length;i++)\n\t\t\tif(move.c[i]!=this.c[i])\n\t\t\t\treturn false;\t\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nModel.Board.InitialPosition = function(aGame) {\n\tthis.HuntInitialPosition(aGame,aGame.g.initialPos);\n\t//this.Evaluate(aGame,false,true);\n\t//aGame.g.evaluate0=this.mEvaluation+1000000*aGame.g.catcher;\n\tthis.zSign=aGame.zobrist.update(0,\"who\",-1);\n};\n\nModel.Board.CopyFrom = function(aBoard) {\n\tvar i;\n\tthis.board=[];\n\tfor(i=0;i<aBoard.board.length;i++)\n\t\tthis.board.push(null);\n\tthis.pieces=[];\n\tfor(i=0;i<aBoard.pieces.length;i++) {\n\t\tvar piece0=aBoard.pieces[i];\n\t\tvar piece={\n\t\t\tp: piece0.p,\n\t\t\ts: piece0.s,\n\t\t\ti: piece0.i,\n\t\t\ta: piece0.a,\n\t\t\tpv: piece0.pv,\n\t\t\tpv2: piece0.pv2\n\t\t};\n\t\tthis.pieces.push(piece);\n\t\tif(piece.p>-1)\n\t\t\tthis.board[piece.p]=piece;\n\t}\n\tthis.pieceCount=[aBoard.pieceCount[0],aBoard.pieceCount[1]];\n\tthis.lastMoves={\n\t\t\"1\": [aBoard.lastMoves[\"1\"][0],aBoard.lastMoves[\"1\"][1],aBoard.lastMoves[\"1\"][2]],\n\t\t\"-1\": [aBoard.lastMoves[\"-1\"][0],aBoard.lastMoves[\"-1\"][1],aBoard.lastMoves[\"-1\"][2]]\n\t};\n\tthis.mWho=aBoard.mWho;\n\tthis.zSign=aBoard.zSign;\n};\n\nModel.Board.HuntInitialPosition = function(aGame, pieces) {\n\tvar pos;\n\tthis.board=[];\n\tfor(pos=0;pos<aGame.g.Graph.length;pos++)\n\t\tthis.board.push(null);\n\tthis.pieces=[];\t\n\tthis.pieceCount=[0,0];\n\tfor(var who=0;who<2;who++) {\n\t\tfor(var i=0;i<pieces[who].length;i++) {\n\t\t\tpos=pieces[who][i];\n\t\t\tvar piece={\n\t\t\t\tp: pos,       // position on the board or -1 if out \n\t\t\t\ts: 1-(who*2), // 1 = Player A or -1 = player B\n\t\t\t\ti: this.pieces.length, // piece index\n\t\t\t\ta: 0 // piece angle\n\t\t\t};\n\t\t\tthis.board[pos]=piece;\n\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",1-(who*2),pos);\n\t\t\tthis.pieces.push(piece);\n\t\t\tthis.pieceCount[who]++;\n\t\t}\n\t}\n\tthis.lastMoves={\n\t\t\"1\": [null,null,null],\n\t\t\"-1\": [null,null,null],\n\t};\n};\n\nModel.Board.GenerateMoves = function(aGame) {\n\tthis.mMoves = [];\n\tif(aGame.g.useDrop) {\n\t\tthis.mMoves=this.HuntGetAllDropMoves(aGame);\n\t}\n\tif(this.mMoves.length===0) {\n\t\tthis.mMoves=this.HuntGetAllMoves(aGame);\n\t\tif(this.mMoves.length===0) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=-this.mWho;\n\t\t}\n\t}\n};\n\nModel.Board.HuntGetCatcherMoves = function(aGame) {\n\tvar $this=this, i;\n\tvar moves=[];\n\t\n\tfunction CatchPiece(pos,poss,caught,caughtBidir) {\n\t\tvar gotMoves=false;\n\t\tfor(var d=0;d<aGame.g.Graph[pos].length;d++) {\n\t\t\tvar pos1=aGame.g.Graph[pos][d];\n\t\t\tif(pos1!==null) {\n\t\t\t\tvar piece1=$this.board[pos1];\n\t\t\t\tif(piece1!==null && piece1.s==-$this.mWho) {\n\t\t\t\t\tvar pos2=aGame.g.Graph[pos1][d];\n\t\t\t\t\tif(pos2!==null && ($this.board[pos2]===null || poss.indexOf(pos2)>=0)) {\n\t\t\t\t\t\tvar valid=true;\n\t\t\t\t\t\tvar bidir=Math.floor(d/2);\n\t\t\t\t\t\tfor(var i=0;i<caught.length;i++)\n\t\t\t\t\t\t\tif(pos1==caught[i] && bidir==caughtBidir[i]) {\n\t\t\t\t\t\t\t\tvalid=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(valid) {\n\t\t\t\t\t\t\tvar poss0=poss.concat([pos2]);\n\t\t\t\t\t\t\tvar caught0=caught.concat([pos1]);\n\t\t\t\t\t\t\tif(aGame.g.huntOptions.multipleCatch===false) {\n\t\t\t\t\t\t\t\tmoves.push({p:poss0,c:caught0});\n\t\t\t\t\t\t\t\tgotMoves=true;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar gotMoves0=CatchPiece(pos2,poss0,caught0,caughtBidir.concat([bidir]));\n\t\t\t\t\t\t\t\tif(gotMoves0===false || aGame.g.huntOptions.compulsaryCatch===false) {\n\t\t\t\t\t\t\t\t\tmoves.push({p:poss0,c:caught0});\n\t\t\t\t\t\t\t\t\tgotMoves=true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\treturn gotMoves;\n\t}\n\t\n\tfor(i=0;i<this.pieces.length;i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.p>=0 && piece.s==this.mWho) {\n\t\t\tCatchPiece(piece.p,[piece.p],[],[]);\n\t\t}\n\t}\n\t\n\tif(moves.length===0 || aGame.g.huntOptions.compulsaryCatch===false) {\n\t\tmoves=moves.concat(this.HuntGetCatcheeMoves(aGame));\n\t} else if(aGame.g.huntOptions.catchLongestLine) {\n\t\tvar longest=0, moves0=[];\n\t\tfor(i=0; i<moves.length; i++) {\n\t\t\tif(longest<moves[i].c.length) {\n\t\t\t\tlongest=moves[i].c.length;\n\t\t\t\tmoves0=[moves[i]];\n\t\t\t} else if(longest==moves[i].c.length)\n\t\t\t\tmoves0.push(moves[i]);\n\t\t}\n\t\tmoves=moves0;\n\t}\n\treturn moves;\n};\n\nModel.Board.HuntGetCatcheeMoves = function(aGame) {\n\tvar moves=[];\n\tfor(var i=0;i<this.pieces.length;i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.p>=0 && piece.s==this.mWho) {\n\t\t\tfor(var d=0;d<aGame.g.Graph[piece.p].length;d++) {\n\t\t\t\tvar pos=aGame.g.Graph[piece.p][d];\n\t\t\t\tif(pos!==null && this.board[pos]===null)\n\t\t\t\t\tmoves.push({p:[piece.p,pos]});\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn moves;\n};\n\nModel.Board.HuntGetAllMoves = function(aGame) {\n\tif(this.mWho==aGame.g.catcher)\n\t\treturn this.HuntGetCatcherMoves(aGame);\n\telse\n\t\treturn this.HuntGetCatcheeMoves(aGame);\n};\n\nModel.Board.HuntGetAllDropMoves = function(aGame) {\n\tvar moves=[];\n\tvar dockPiece=null;\n\tfor(var i=0;i<this.pieces.length;i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.p==-2 && piece.s==this.mWho) {\n\t\t\tdockPiece=piece;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(dockPiece) {\n\t\tfor(var pos=0;pos<this.board.length;pos++)\n\t\t\tif(this.board[pos]===null)\n\t\t\t\tmoves.push({p:[pos]});\n\t}\n\treturn moves;\n};\n\nModel.Board.HuntMakeEvalData=function(aGame) {\n\tvar evalData={\n\t\tcatcher: aGame.g.catcher,\n\t\tcatchee: -aGame.g.catcher,\n\t\tcatcherSide: (1-aGame.g.catcher)/2,\n\t\tcatcheeSide: (aGame.g.catcher+1)/2,\n\t\tcatcherPieces: [],\n\t\tcatcheePieces: [],\n\t\tcatcherPiecesDock: [],\n\t\tcatcheePiecesDock: [],\n\t};\n\tfor(var i=0;i<this.pieces.length;i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.p>-1)\n\t\t\tif(piece.s==evalData.catcher)\n\t\t\t\tevalData.catcherPieces.push(piece);\n\t\t\telse\n\t\t\t\tevalData.catcheePieces.push(piece);\n\t\telse if(piece.p==-2)\n\t\t\tif(piece.s==evalData.catcher)\n\t\t\t\tevalData.catcherPiecesDock.push(piece);\n\t\t\telse\n\t\t\t\tevalData.catcheePiecesDock.push(piece);\n\t}\n\treturn evalData;\n};\n\nModel.Board.HuntEvaluateFreeZone = function(aGame,evalData,evalMap) {\n\tvar i, pos, pos0, pos1, d;\n\tvar catcherZone={};\n\tvar smallestZone=null;\n\tvar smallestCatcherFreeZone=-1;\n\tfor(i=0; i<evalData.catcherPieces.length; i++) {\n\t\tvar catcherPiece=evalData.catcherPieces[i];\n\t\tvar freePoss={},freePossCount=0,unexplored={},unexploredCount=1;\n\t\tunexplored[catcherPiece.p]=true;\n\t\twhile(unexploredCount>0) {\n\t\t\tfor(pos0 in unexplored) \n\t\t\t\tif(unexplored.hasOwnProperty(pos0)) {\n\t\t\t\t\tpos=parseInt(pos0);\n\t\t\t\t\tunexploredCount--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdelete unexplored[pos];\n\t\t\tfreePoss[pos]=true;\n\t\t\tfreePossCount++;\n\t\t\tcatcherZone[pos]=true;\n\t\t\tfor(d=0; d<aGame.g.Graph[pos].length; d++) {\n\t\t\t\tpos1=aGame.g.Graph[pos][d];\n\t\t\t\tif(pos1!==null && this.board[pos1]===null && !freePoss[pos1] && !unexplored[pos1]) {\n\t\t\t\t\tunexplored[pos1]=true;\n\t\t\t\t\tunexploredCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//JocLog(\"Catcher free zone\",freePossCount-1);\n\t\tif(smallestCatcherFreeZone<0 || smallestCatcherFreeZone<freePossCount-1) {\n\t\t\tsmallestCatcherFreeZone=freePossCount-1;\n\t\t\tsmallestZone=freePoss;\n\t\t}\n\t}\n\tevalData.catcherZone=catcherZone;\n\tevalMap.freeZone=[smallestCatcherFreeZone,0];\n\tevalMap.freeZone2=[smallestCatcherFreeZone*smallestCatcherFreeZone,0];\n\tevalMap.freeZoneSQRT=[Math.sqrt(smallestCatcherFreeZone),0];\n\tvar dist=0;\n\tvar dist2=0;\n\tvar maxDist0=0;\n\tfor(i=0; i<evalData.catcheePieces.length; i++) {\n\t\tvar piece=evalData.catcheePieces[i];\n\t\tvar maxDist=0;\n\t\tfor(pos in smallestZone) \n\t\t\tif(smallestZone.hasOwnProperty(pos)) {\n\t\t\t\td=aGame.HuntDist(pos,piece.p);\n\t\t\t\tif(d>maxDist)\n\t\t\t\t\tmaxDist=d;\n\t\t\t\tif(d>maxDist0)\n\t\t\t\t\tmaxDist0=d;\n\t\t\t}\n\t\tdist+=maxDist;\n\t\tdist2+=maxDist*maxDist;\n\t}\n\tevalMap.distFree=[dist,0];\n\tevalMap.distFree2=[dist2,0];\n\tevalMap.maxDistFree=[maxDist0,0];\n};\n\nModel.Board.HuntEvaluateOppositeDistFromCatcher = function(aGame,evalData,evalMap) {\n\tvar allFarthest=[];\n\tvar dist,i,piece;\n\tfor(i=0; i<evalData.catcherPieces.length; i++) {\n\t\tpiece=evalData.catcherPieces[i];\n\t\tvar farthest=[];\n\t\tvar maxDist=0;\n\t\tfor(var pos=0;pos<aGame.g.Graph.length;pos++) {\n\t\t\tdist=aGame.HuntDist(pos,piece.p);\n\t\t\tif(dist>maxDist) {\n\t\t\t\tmaxDist=dist;\n\t\t\t\tfarthest=[pos];\n\t\t\t} else if(dist==maxDist)\n\t\t\t\tfarthest.push(pos);\n\t\t}\n\t\tallFarthest=allFarthest.concat(farthest);\n\t}\n\tdist=0;\n\tvar dist2=0, dists=0;\n\tfor(i=0; i<evalData.catcheePieces.length; i++) {\n\t\tpiece=evalData.catcheePieces[i];\n\t\tvar d=0,d2=0,ds=0;\n\t\tfor(var j=0;j<allFarthest.length;j++) {\n\t\t\td0=aGame.HuntDist(allFarthest[j],piece.p);\n\t\t\td+=d0;\n\t\t\td2+=d0*d0;\n\t\t\tds+=Math.sqrt(d);\n\t\t}\n\t\tdist+=d/allFarthest.length;\n\t\tdist2+=d2/allFarthest.length;\n\t\tdists+=ds/allFarthest.length;\n\t}\n\tevalMap.oppDist=[-dist,0];\n\tevalMap.oppDist2=[-dist2,0];\n\tevalMap.oppDists=[-dists,0];\n};\n\nModel.Board.HuntEvaluateDistToCatcher = function(aGame,evalData,evalMap) {\n\tvar dist=0, dist2=0, dist3=0;\n\tvar maxDist=0;\n\t//var dists=[];\n\tfor(var i=0; i<evalData.catcheePieces.length; i++) {\n\t\tvar catcheePiece=evalData.catcheePieces[i];\n\t\tvar minDist=-1;\n\t\tfor(var j=0; j<evalData.catcherPieces.length; j++) {\n\t\t\tvar catcherPiece=evalData.catcherPieces[j];\n\t\t\tvar d=aGame.HuntDist(catcherPiece.p,catcheePiece.p);\n\t\t\tif(minDist<0 || minDist<d)\n\t\t\t\tminDist=d;\n\t\t}\n\t\tdist+=minDist;\n\t\tvar minDist2=minDist*minDist;\n\t\tdist2+=minDist2;\n\t\tdist3+=minDist*minDist2;\n\t\tif(minDist>maxDist) {\n\t\t\tmaxDist=minDist;\n\t\t}\n\t}\n\tevalMap.dist3=[dist3,0];\n\tevalMap.dist2=[dist2,0];\n\tevalMap.dist=[dist,0];\n\tevalMap.maxDist=[maxDist,0];\n};\n\nModel.Board.HuntEvaluateCatchable = function(aGame,evalData,evalMap) {\n\tvar catchablePieces=0, catchableDir=0, catchableDangerPieces=0;\n\tfor(var i=0; i<evalData.catcheePieces.length; i++) {\n\t\tvar catcheePiece=evalData.catcheePieces[i];\n\t\tvar pos=catcheePiece.p;\n\t\tvar catchable=false;\n\t\tvar catchDanger=false;\n\t\tvar graph=aGame.g.Graph[pos];\n\t\tfor(var d=0;d<graph.length;d+=2) {\n\t\t\tvar pos1=graph[d];\n\t\t\tvar pos2=graph[d+1];\n\t\t\tif(pos1!==null && pos2!==null) {\n\t\t\t\tif(this.board[pos1]===null && this.board[pos2]===null) {\n\t\t\t\t\tcatchableDir++;\n\t\t\t\t\tcatchable=true;\n\t\t\t\t} else \tif((this.board[pos1]===null && this.board[pos2].s==aGame.g.catcher) ||\n\t\t\t\t\t(this.board[pos2]===null && this.board[pos1].s==aGame.g.catcher)) {\n\t\t\t\t\tcatchableDir++;\n\t\t\t\t\tcatchDanger=true;\n\t\t\t\t\tcatchable=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(catchable)\n\t\t\tcatchablePieces++;\n\t\tif(catchDanger)\n\t\t\tcatchableDangerPieces++;\n\t}\n\tevalMap.catchablePieces=[catchablePieces,0];\n\tevalMap.catchableDir=[catchableDir,0];\n\tevalMap.catchableDir2=[catchableDir*catchableDir,0];\n\tevalMap.catchDangerFork=[catchableDangerPieces>1?1:0,0];\n};\n\nModel.Board.HuntEvaluateRisk = function(aGame,evalData,evalMap) {\n\tvar pos, metric;\n\tvar riskPoss={}, openPoss={};\n\tvar riskCount=0, openCount=0;\n\tfunction AddOpen(pos) {\n\t\tif(evalData.catcherZone[pos]===undefined)\n\t\t\tif(openPoss[pos]===undefined) {\n\t\t\t\topenPoss[pos]=1;\n\t\t\t\topenCount++;\n\t\t\t} else\n\t\t\t\topenPoss[pos]++;\n\t}\n\tfunction AddRisky(pos) {\n\t\tif(riskPoss[pos]===undefined) {\n\t\t\triskPoss[pos]=1;\n\t\t\triskCount++;\n\t\t} else\n\t\t\triskPoss[pos]++;\n\t}\n\tfor(var i=0; i<evalData.catcheePieces.length; i++) {\n\t\tvar piece=evalData.catcheePieces[i];\n\t\tpos=piece.p;\n\t\tvar graph=aGame.g.Graph[pos];\n\t\tfor(var d=0;d<graph.length;d+=2) {\n\t\t\tvar pos1=graph[d];\n\t\t\tvar pos2=graph[d+1];\n\t\t\tif(pos1!==null && pos2!==null && pos2!==undefined) {\n\t\t\t\tvar piece1=this.board[pos1];\n\t\t\t\tvar piece2=this.board[pos2];\n\t\t\t\tif(piece1===null && piece2===null) {\n\t\t\t\t\tAddOpen(pos1);\n\t\t\t\t\tAddOpen(pos2);\n\t\t\t\t} else if(piece1!==null && piece1.s==aGame.g.catcher && piece2===null) {\n\t\t\t\t\tAddOpen(pos1);\n\t\t\t\t\tAddRisky(pos2);\n\t\t\t\t} else if(piece2!==null && piece2.s==aGame.g.catcher && piece1===null) {\n\t\t\t\t\tAddRisky(pos1);\n\t\t\t\t\tAddOpen(pos2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvar openMetric=0;\n\tfor(pos in openPoss) \n\t\tif(openPoss.hasOwnProperty(pos)) {\n\t\t\tmetric=openPoss[pos];\n\t\t\topenMetric+=metric*metric;\n\t\t}\n\tvar riskMetric=0;\n\tfor(pos in riskPoss) \n\t\tif(riskPoss.hasOwnProperty(pos)) {\n\t\t\tmetric=riskPoss[pos];\n\t\t\triskMetric+=metric*metric;\n\t\t}\n\tevalMap.openRisk=[openMetric,0];\n\tevalMap.forkRisk=[riskMetric,0];\n};\n\n\nModel.Board.HuntEvaluateAntiBack = function(aGame,evalData,evalMap) {\n\tvar i, piece;\n\tvar catcherPrev=0, catcheePrev=0, catcherPiecePrev=0, catcheePiecePrev=0;\n\tfor(i=0; i<evalData.catcheePieces.length; i++) {\n\t\tpiece=evalData.catcheePieces[i];\n\t\tif(piece.p==piece.pv2)\n\t\t\tcatcheePiecePrev++;\n\t}\n\tfor(i=0; i<evalData.catcherPieces.length; i++) {\n\t\tpiece=evalData.catcherPieces[i];\n\t\tif(piece.p==piece.pv2)\n\t\t\tcatcherPiecePrev++;\n\t}\n\tfor(var who=-1;who<2;who+=2) {\n\t\tvar last=this.lastMoves[who];\t\n//\t\tif(last[0]!=null && last[1]!=null && typeof last[0].c==\"undefined\" && typeof last[1].c==\"undefined\" && \n//\t\t\t\tlast[0].p.length==2 && last[1].p.length==2 && last[0].p[0]==last[1].p[1] && last[1].p[0]==last[0].p[1])\n\t\t\tif(last[0]!==null && last[0].Equals(last[2]))\n\t\t\t\tif(aGame.g.catcher==who)\n\t\t\t\t\tcatcherPrev++;\n\t\t\t\telse\n\t\t\t\t\tcatcheePrev++;\n\t}\n\tevalMap.antiBack=[catcheePrev,catcherPrev];\n\tevalMap.antiBackPiece=[catcheePiecePrev,catcherPiecePrev];\n};\n\nModel.Board.HuntEvaluateCatcheeConnections = function(aGame,evalData,evalMap) {\n\tvar conn=0;\n\tvar connLog=0;\n\tfor(var i=0;i<this.pieces.length;i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.s==-aGame.g.catcher && piece.p>=0) {\n\t\t\tvar pieceConn=0;\n\t\t\tvar graph=aGame.g.Graph[piece.p];\n\t\t\tfor(var d=0;d<graph.length;d++) {\n\t\t\t\tvar pos1=graph[d];\n\t\t\t\tif(pos1!==null) {\n\t\t\t\t\tvar piece1=this.board[pos1];\n\t\t\t\t\tif(piece1 && piece1.s==piece.s)\n\t\t\t\t\t\tpieceConn++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconn+=pieceConn;\n\t\t\tconnLog+=Math.log(pieceConn+1);\n\t\t}\n\t}\n\tevalMap.catcheeConn=[0,conn];\n\tevalMap.catcheeConnLog=[0,connLog];\n};\n\nModel.Board.HuntEvaluateCatcheeGroups = function(aGame,evalData,evalMap) {\n\tvar i, piece;\n\tvar pieces={};\n\tvar pieceCount=0;\n\tfor(i=0;i<this.pieces.length;i++) {\n\t\tpiece=this.pieces[i];\n\t\tif(piece.s==-aGame.g.catcher && piece.p>=0) {\n\t\t\tpieces[piece.i]=piece;\n\t\t\tpieceCount++;\n\t\t}\n\t}\n\tvar groupCount=0;\n\twhile(pieceCount>0) {\n\t\tgroupCount++;\n\t\tfor(i in pieces)\n\t\t\tif(pieces.hasOwnProperty(i))\n\t\t\t\tbreak;\n\t\tpiece=pieces[i];\n\t\tdelete pieces[i];\n\t\tvar pieces0={};\n\t\tpieces0[i]=piece;\n\t\tvar pieceCount0=1;\n\t\twhile(pieceCount0>0) {\n\t\t\tfor(i in pieces0)\n\t\t\t\tif(pieces0.hasOwnProperty(i))\n\t\t\t\t\tbreak;\n\t\t\tvar piece0=pieces0[i];\n\t\t\tdelete pieces0[i];\n\t\t\tpieceCount0--;\n\t\t\tdelete pieces[i];\n\t\t\tpieceCount--;\n\t\t\tvar graph=aGame.g.Graph[piece0.p];\n\t\t\tfor(var d=0;d<graph.length;d++) {\n\t\t\t\tvar pos1=graph[d];\n\t\t\t\tif(pos1!==null) {\n\t\t\t\t\tvar piece1=this.board[pos1];\n\t\t\t\t\tif(piece1 && (piece1.i in pieces) && !(piece1.i in pieces0)) {\n\t\t\t\t\t\tpieces0[piece1.i]=piece1;\n\t\t\t\t\t\tpieceCount0++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tevalMap.catcheeGroups=[groupCount,0];\n};\n\nModel.Board.HuntEvaluateGroups = function(aGame,evalData,evalMap) {\n\tvar i, piece, d, pos1, group;\n\tvar groups={};\n\tvar groupPos={};\n\tvar groupIndex=0;\n\tfor(var pos=0;pos<aGame.g.Graph.length;pos++) {\n\t\tif(typeof groupPos[pos]==\"undefined\") {\n\t\t\tpiece=this.board[pos];\n\t\t\tvar currentGroup=null;\n\t\t\tvar graph=aGame.g.Graph[pos];\n\t\t\tfor(d=0;d<graph.length;d++) {\n\t\t\t\tpos1=graph[d];\n\t\t\t\tif(pos1!==null) {\n\t\t\t\t\tvar piece1=this.board[pos1];\n\t\t\t\t\tif((piece===null && piece1===null) ||\n\t\t\t\t\t\t(piece!==null && piece1!==null && piece.s==piece1.s)) {\n\t\t\t\t\t\tif(typeof groupPos[pos1]!=\"undefined\") {\n\t\t\t\t\t\t\tvar groupPos1=groupPos[pos1];\n\t\t\t\t\t\t\tif(currentGroup===null) {\n\t\t\t\t\t\t\t\tgroupPos[pos]=groupPos1;\n\t\t\t\t\t\t\t\tgroups[groupPos1].poss.push(pos);\n\t\t\t\t\t\t\t\tcurrentGroup=groupPos1;\n\t\t\t\t\t\t\t} else if(currentGroup!=groupPos1) {\n\t\t\t\t\t\t\t\t// Merge groups\n\t\t\t\t\t\t\t\tgroup=groups[currentGroup];\n\t\t\t\t\t\t\t\tvar group1=groups[groupPos1];\n\t\t\t\t\t\t\t\tgroup.poss=group.poss.concat(group1.poss);\n\t\t\t\t\t\t\t\tfor(i=0; i<group1.poss.length; i++)\n\t\t\t\t\t\t\t\t\tgroupPos[group1.poss[i]]=currentGroup;\n\t\t\t\t\t\t\t\tdelete groups[groupPos1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(currentGroup===null) {\n\t\t\t\tgroups[groupIndex]={\n\t\t\t\t\ttype: piece===null?0:piece.s,\n\t\t\t\t\tposs: [pos],\n\t\t\t\t\ttouchCatcher: false,\n\t\t\t\t};\n\t\t\t\tgroupPos[pos]=groupIndex++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0; i<evalData.catcherPieces.length; i++) {\n\t\tpiece=evalData.catcherPieces[i];\n\t\tfor(d=0;d<aGame.g.Graph[piece.p].length;d++) {\n\t\t\tpos1=aGame.g.Graph[piece.p][d];\n\t\t\tif(pos1!==null) {\n\t\t\t\tgroups[groupPos[pos1]].touchCatcher=true;\n\t\t\t}\n\t\t}\n\t}\n\t//JocLog(\"groups\",groups);\n\tvar catcheeGroups=0;\n\tvar maxEmptyNoCatcherGroup=0;\n\tvar emptyNoCatcherGroup=0;\n\tvar minEmptyCatcherGroup=0;\n\tfor(var g in groups) \n\t\tif(groups.hasOwnProperty(g)) {\n\t\t\tgroup=groups[g];\n\t\t\tif(group.type==-aGame.g.catcher)\n\t\t\t\tcatcheeGroups++;\n\t\t\telse if(group.type===0) {\n\t\t\t\tif(group.touchCatcher===false) {\n\t\t\t\t\tif(group.poss.length>maxEmptyNoCatcherGroup)\n\t\t\t\t\t\tmaxEmptyNoCatcherGroup=group.poss.length;\n\t\t\t\t\temptyNoCatcherGroup+=group.poss.length;\n\t\t\t\t} else if(group.touchCatcher===true)\n\t\t\t\t\tminEmptyCatcherGroup+=group.poss.length;\n\t\t\t}\n\t\t}\n\tevalMap.catcheeGroups=[catcheeGroups,0];\n\tevalMap.maxEmptyNoCatcherGroup=[0,maxEmptyNoCatcherGroup];\n\tevalMap.emptyNoCatcherGroup=[0,emptyNoCatcherGroup];\n\tevalMap.minEmptyCatcherGroup=[minEmptyCatcherGroup<0?0:minEmptyCatcherGroup,0];\n};\n\nModel.Board.HuntGameEvaluate = function(aGame,evalData,evalMap) {\n\treturn { pieceCount: [1,1] };\n};\n\n\nModel.Board.QuickEvaluate = function(aGame) {\n\tthis.Evaluate(aGame,false,true);\n\treturn this.mEvaluation;\n};\n\nModel.Board.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\tvar f;\n\tvar repeat=aGame.GetRepeatOccurence(this);\n\tif(repeat>2) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.DRAW;\n\t}\n\tvar evalData=this.HuntMakeEvalData(aGame);\n\tif(this.pieceCount[evalData.catcherSide]<aGame.g.catcherMin) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=evalData.catchee;\n\t}\n\tif(this.pieceCount[evalData.catcheeSide]<aGame.g.catcheeMin) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=evalData.catcher;\n\t}\n\tthis.mEvaluation=0;\n\tif(this.mFinished)\n\t\treturn;\n\n\tvar evalMap={\n\t\tpieceCount: [\n\t\t \t        this.pieceCount[evalData.catcherSide], \n\t\t\t        this.pieceCount[evalData.catcheeSide], \n\t\t]\n\t};\n\n\tvar evalFactors=this.HuntGameEvaluate(aGame,evalData,evalMap);\n\t\n\tvar debugEval=arguments[3]==\"debug\"; \n\t\n\tfor(f in evalFactors) \n\t\tif(evalFactors.hasOwnProperty(f)) {\n\t\t\tvar factors=evalFactors[f];\n\t\t\tvar values=evalMap[f];\n\t\t\tif(values===undefined)\n\t\t\t\tconsole.error(\"Evaluation undefined map value\",f);\n\t\t\tif(debugEval) {\n\t\t\t\tconsole.log(f+\":\",values[0],\"x\",factors[0],\" - \",values[1],\"x\",factors[1],\"=\",values[0]*factors[0]-values[1]*factors[1]);\n\t\t\t}\n\t\t\tthis.mEvaluation+=values[0]*factors[0]-values[1]*factors[1];\n\t\t}\n\t\t\n\tif(debugEval) {\n\t\tfor(f in evalMap) \n\t\t\tif(evalMap.hasOwnProperty(f)) {\n\t\t\t\tif(typeof evalFactors[f]==\"undefined\")\n\t\t\t\t\tJocLog(\"Unused\",f+\": \",evalMap[f][0],evalMap[f][1]);\n\t\t\t}\n\t\tJocLog(\"==>\",this.mEvaluation,\"=>\",this.mEvaluation*aGame.g.catcher,\"=>\",this.mEvaluation*aGame.g.catcher-aGame.g.evaluate0);\n\t}\n\tthis.mEvaluation*=aGame.g.catcher;\n\tthis.mEvaluation-=aGame.g.evaluate0;\n};\n\nModel.Board.HuntCheckBoard=function(aGame) {\n\tvar i, piece;\n\tfor(i=0; i<aGame.g.Graph.length; i++) {\n\t\tvar pos=aGame.g.Graph[i];\n\t\tpiece=this.board[pos];\n\t\tif(piece!==null) {\n\t\t\tif(piece.p!=pos)\n\t\t\t\treturn \"Piece \"+piece+i+\" has p \"+piece.p+\" while on board pos \"+pos;\n\t\t} \n\t}\n\tfor(i=0; i<this.pieces.length; i++) {\n\t\tpiece=this.pieces[i];\n\t\tif(piece.p!=-1 && this.board[piece.p]!=piece)\n\t\t\treturn \"Piece \"+i+\" not on board \"+piece.p;\n\t}\n\treturn null;\n};\n\nModel.Board.HuntAngle = function(aGame,pos0,pos) {\n\tvar rc0=aGame.g.RC[pos0];\n\tvar r0=rc0[0];\n\tvar c0=rc0[1];\n\tvar rc=aGame.g.RC[pos];\n\tvar r=rc[0];\n\tvar c=rc[1];\n\t/*return {\n\t\t\"-1,-1\": -135,\n\t\t\"0,-1\": -90,\n\t\t\"1,-1\": -45,\n\t\t\"-1,0\": 180,\n\t\t\"1,0\": 0,\n\t\t\"-1,1\": 135,\n\t\t\"0,1\": 90,\n\t\t\"1,1\": 45,\n\t\t\"-2,-2\": -135,\n\t\t\"0,-2\": -90,\n\t\t\"2,-2\": -45,\n\t\t\"-2,0\": 180,\n\t\t\"2,0\": 0,\n\t\t\"-2,2\": 135,\n\t\t\"0,2\": 90,\n\t\t\"2,2\": 45,\n\t}[\"\"+(r-r0)+\",\"+(c-c0)];*/\n\n\tvar a = 0;\n\tvar dx=r-r0;\n\tvar dy=c-c0;\n\tif (dx===0){\n\t\ta = (dy > 0) ? 90 : -90;\n\t}else{\n\t\ta = 180*Math.atan(dy/dx) / Math.PI ; \n\t\tif(dx<0) a= (a+180)%360;\n\t}\n\treturn a; \n};\n\nModel.Board.ApplyMove = function(aGame,aMove) {\n\tvar piece, i;\n\tif(aMove.p.length==1) {\n\t\tfor(i=0;i<this.pieces.length;i++) {\n\t\t\tpiece=this.pieces[i];\n\t\t\tif(piece.s==this.mWho && piece.p==-2) {\n\t\t\t\tpiece.p=aMove.p[0];\n\t\t\t\tpiece.a=0;\n\t\t\t\tthis.board[piece.p]=piece;\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.s,piece.p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpiece=this.board[aMove.p[0]];\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.s,piece.p);\n\t\tthis.board[aMove.p[0]]=null;\n\t\tthis.board[aMove.p[aMove.p.length-1]]=piece;\n\t\tpiece.pv2=piece.pv;\n\t\tpiece.pv=piece.p;\n\t\tpiece.p=aMove.p[aMove.p.length-1];\n\t\tpiece.a=this.HuntAngle(aGame,aMove.p[aMove.p.length-2],aMove.p[aMove.p.length-1]);\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.s,piece.p);\n\t\tif(aMove.c!==undefined) {\n\t\t\tvar side=this.mWho==JocGame.PLAYER_A?0:1;\n\t\t\tfor(i=0;i<aMove.c.length;i++) {\n\t\t\t\tpiece=this.board[aMove.c[i]];\n\t\t\t\tif(piece!==null) {\n\t\t\t\t\tthis.board[aMove.c[i]]=null;\n\t\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",piece.s,piece.p);\n\t\t\t\t\tpiece.p=-1;\n\t\t\t\t\tthis.pieceCount[1-side]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.lastMoves[this.mWho][2]=this.lastMoves[this.mWho][1];\n\tthis.lastMoves[this.mWho][1]=this.lastMoves[this.mWho][0];\n\tthis.lastMoves[this.mWho][0]=new (aGame.GetMoveClass())(aMove);\n\tthis.zSign=aGame.zobrist.update(this.zSign,\"who\",-this.mWho);\n\tthis.zSign=aGame.zobrist.update(this.zSign,\"who\",this.mWho);\t\n};\n\nModel.Board.GetSignature = function() {\n\treturn this.zSign;\n};\t\n"],"file":"decercarlaliebre-model.js"}