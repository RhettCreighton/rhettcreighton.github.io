{"version":3,"names":[],"mappings":"","sources":["spbase-model.js"],"sourcesContent":["/*\n * Copyright (c) 2013 - Jocly - www.jocly.com - All rights reserved\n */\n\nModel.Game.InitGame = function() {\n\tvar aGame=this;\n\tvar size=this.mOptions.size;\n\tvar coord=[]; // coord[position] = [row,col,height]\n\tvar g=[];\t  // g[position][direction] = neighbor_position | null if outside\n\tvar index=0;\n\t//var hBase=[0,16,25,29];\n\tvar hBase0=0;\n\tvar hBase=[];\n\tfor(var h=0;h<size;h++) {\n\t\thBase.push(hBase0);\n\t\thBase0+=(size-h)*(size-h);\n\t} \n\tfor(var h=0;h<size;h++) \n\t\tfor(var r=0;r<size-h;r++)\n\t\t\tfor(var c=0;c<size-h;c++) {\n\t\t\t\tvar pos=index++;\n\t\t\t\tcoord[pos]=[r,c,h];\n\t\t\t\tg[pos]=[];\n\t\t\t\t/* down */\n\t\t\t\tfor(var dr=0;dr<2;dr++)\n\t\t\t\t\tfor(var dc=0;dc<2;dc++) {\n\t\t\t\t\t\tvar h0=h-1;\n\t\t\t\t\t\tvar r0=r+dr;\n\t\t\t\t\t\tvar c0=c+dc;\n\t\t\t\t\t\tif(h0>=0 && h0<size && r0>=0 && r0<size-h0 && c0>=0 && c0<size-h0)\n\t\t\t\t\t\t\tg[pos].push(hBase[h0]+r0*(size-h0)+c0);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tg[pos].push(null);\n\t\t\t\t\t}\n\t\t\t\t/* same level */\n\t\t\t\tvar dirs=[[0,-1],[0,1],[-1,0],[1,0]];\n\t\t\t\tfor(var i=0; i<dirs.length; i++) {\n\t\t\t\t\tvar dir=dirs[i];\n\t\t\t\t\tvar h0=h;\n\t\t\t\t\tvar r0=r+dir[0];\n\t\t\t\t\tvar c0=c+dir[1];\n\t\t\t\t\tif(h0>=0 && h0<size && r0>=0 && r0<size-h0 && c0>=0 && c0<size-h0)\n\t\t\t\t\t\tg[pos].push(hBase[h0]+r0*(size-h0)+c0);\n\t\t\t\t\telse\n\t\t\t\t\t\tg[pos].push(null);\n\t\t\t\t}\n\t\t\t\t/* up */\n\t\t\t\tfor(var dr=-1;dr<1;dr++)\n\t\t\t\t\tfor(var dc=-1;dc<1;dc++) {\n\t\t\t\t\t\tvar h0=h+1;\n\t\t\t\t\t\tvar r0=r+dr;\n\t\t\t\t\t\tvar c0=c+dc;\n\t\t\t\t\t\tif(h0>=0 && h0<size && r0>=0 && r0<size-h0 && c0>=0 && c0<size-h0)\n\t\t\t\t\t\t\tg[pos].push(hBase[h0]+r0*(size-h0)+c0);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tg[pos].push(null);\n\t\t\t\t\t}\n\t\t\t}\n\tthis.g.Graph=g;\n\tthis.g.Coord=coord;\n\t\n\t// go to position at same r and c, 2 levels above /below\n\tthis.g.Over=[];\n\tthis.g.Beneath=[];\n\tfor(var pos=0;pos<this.g.Graph.length;pos++) {\n\t\tthis.g.Over[pos]=null;\n\t\tthis.g.Beneath[pos]=null;\n\t}\n\tfor(var pos=0;pos<this.g.Graph.length;pos++) {\n\t\tvar coord=this.g.Coord[pos];\n\t\tfor(var pos1=pos+1;pos1<this.g.Graph.length;pos1++) {\n\t\t\tvar coord1=this.g.Coord[pos1];\n\t\t\tif(coord1[2]==coord[2]+2 && coord1[0]==coord[0]-1 && coord1[1]==coord[1]-1) {\n\t\t\t\tthis.g.Over[pos]=pos1;\n\t\t\t\tthis.g.Beneath[pos1]=pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// walk through neighbor positions\n\tthis.g.EachDirection = function(pos,fnt) {\n\t\tfor(var i=0;i<12;i++) {\n\t\t\tvar npos=aGame.g.Graph[pos][i];\n\t\t\tif(npos!=null)\n\t\t\t\tif(fnt(npos,i)==false)\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\t// walk through down neighbors positions\n\tthis.g.EachDirectionDown = function(pos,fnt) {\n\t\tvar dirs=[0,1,2,3];\n\t\tfor(var i=0;i<dirs.length;i++) {\n\t\t\tvar npos=aGame.g.Graph[pos][dirs[i]];\n\t\t\tif(npos!=null)\n\t\t\t\tif(fnt(npos,dirs[i])==false)\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\t// walk up neighbors positions\n\tthis.g.EachDirectionUp = function(pos,fnt) {\n\t\tvar dirs=[8,9,10,11];\n\t\tfor(var i=0;i<dirs.length;i++) {\n\t\t\tvar npos=aGame.g.Graph[pos][dirs[i]];\n\t\t\tif(npos!=null)\n\t\t\t\tif(fnt(npos,dirs[i])==false)\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\t// walk up neighbors positions at same z\n\tthis.g.EachDirectionFlat = function(pos,fnt) {\n\t\tvar dirs=[4, 5, 6, 7];\n\t\tfor(var i=0;i<dirs.length;i++) {\n\t\t\tvar npos=aGame.g.Graph[pos][dirs[i]];\n\t\t\tif(npos!=null)\n\t\t\t\tif(fnt(npos,dirs[i])==false)\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\t// walk up neighbors positions at same z or below\n\tthis.g.EachDirectionFlatDown = function(pos,fnt) {\n\t\tvar dirs=[0, 1, 2, 3, 4, 5, 6, 7];\n\t\tfor(var i=0;i<dirs.length;i++) {\n\t\t\tvar npos=aGame.g.Graph[pos][dirs[i]];\n\t\t\tif(npos!=null)\n\t\t\t\tif(fnt(npos,dirs[i])==false)\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\t// walk up neighbors positions at same z or above\n\tthis.g.EachDirectionFlatUp = function(pos,fnt) {\n\t\tvar dirs=[4, 5, 6, 7, 8, 9, 10, 11];\n\t\tfor(var i=0;i<dirs.length;i++) {\n\t\t\tvar npos=aGame.g.Graph[pos][dirs[i]];\n\t\t\tif(npos!=null)\n\t\t\t\tif(fnt(npos,dirs[i])==false)\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\n\tthis.zobrist=new JocGame.Zobrist({\n\t\tboard: {\n\t\t\ttype: \"array\",\n\t\t\tsize: this.g.Graph.length,\n\t\t\tvalues: [0,1],\n\t\t}\n\t});\n\n\tthis.InitGameExtra();\n}\n\nModel.Game.MapSameLevelDiagGraph = function() {\n\tvar hBase=[0,16,25,29];\n\tfor(var h=0;h<4;h++) \n\t\tfor(var r=0;r<4-h;r++)\n\t\t\tfor(var c=0;c<4-h;c++) {\n\t\t\t\tvar pos=hBase[h]+r*(4-h)+c;\n\t\t\t\tfor(var dr=-1;dr<2;dr+=2)\n\t\t\t\t\tfor(var dc=-1;dc<2;dc+=2) {\n\t\t\t\t\t\tvar h0=h;\n\t\t\t\t\t\tvar r0=r+dr;\n\t\t\t\t\t\tvar c0=c+dc;\n\t\t\t\t\t\tif(h0>=0 && h0<4 && r0>=0 && r0<4-h0 && c0>=0 && c0<4-h0)\n\t\t\t\t\t\t\tthis.g.Graph[pos].push(hBase[h0]+r0*(4-h0)+c0);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthis.g.Graph[pos].push(null);\n\t\t\t\t\t}\n\t\t\t}\n}\n\nModel.Game.InitGameExtra = function() {\n}\n\nModel.Game.DestroyGame = function() {\n\tthis.DestroyGameExtra();\n}\n\nModel.Game.DestroyGameExtra = function() {\n}\n\nModel.Game.spUpdateZobrist = function(sign,adds,addsSide,removes,removesSide,who) {\n\tfor(var i=0;i<adds.length;i++)\n\t\tsign=this.zobrist.update(sign,\"board\",addsSide,adds[i]);\n\tfor(var i=0;i<removes.length;i++)\n\t\tsign=this.zobrist.update(sign,\"board\",removesSide,removes[i]);\n\treturn sign;\n}\n\nModel.Move.Init = function(args) {\n\tfor(var p in args) \n\t\tif(args.hasOwnProperty(p))\n\t\t\tthis[p]=JSON.parse(JSON.stringify(args[p]));\n}\n\nModel.Move.ToString = function() {\n\tvar color=['?','W','B','R'][this.clr];\n\tvar str=\"\";\n\tswitch(this.act) {\n\tcase \"+\":\n\t\tstr+=\"+\"+this.pos+color;\n\t\tbreak;\n\tcase \">\":\n\t\tstr+=this.from+\">\"+this.to+color;\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nModel.Board.Init = function(aGame) {\n}\n\nModel.Board.InitialPosition = function(aGame) {\n\tthis.spInitialPosition(aGame);\n}\n\nModel.Board.spInitialPosition = function(aGame) {\n\tthis.board=[]; // access balls by position\n\tfor(var i=0; i<aGame.g.Graph.length; i++)\n\t\tthis.board[i]=0;\n\tthis.maxLayer=0;\n\tthis.ballCount=[0,0,0];\n\tthis.playables={};\n\tthis.height=[0,0,0];\n\tthis.zSign=0;\n\t// can put ball at ground level z=0\n\tfor(var i=0;i<aGame.mOptions.size*aGame.mOptions.size;i++)\n\t\tthis.playables[i]=true;\n}\n\nModel.Board.MakeFreeMoves = function(aGame) {\n\tvar moves=[];\n\tfor(var pos in this.playables)\n\t\tif(this.playables.hasOwnProperty(pos))\n\t\t\tmoves.push({ act: '+', pos: pos, clr: this.mWho==JocGame.PLAYER_A?1:2 });\n\treturn moves;\n}\n\nModel.Board.GenerateMoves = function(aGame) {\n\tvar moves=this.GenerateAllMoves(aGame);\n\tvar moveLimit=aGame.mOptions.moveCount;\n\tif(moves.length==0) {\n\t\tthis.mFinished=true;\n\t\tif(this.ballCount[1]>this.ballCount[2])\n\t\t\tthis.mWinner=JocGame.PLAYER_A;\n\t\telse if(this.ballCount[1]<this.ballCount[2])\n\t\t\tthis.mWinner=JocGame.PLAYER_B;\n\t\telse\n\t\t\tthis.mWinner=JocGame.DRAW;\n\t} else if(moveLimit!==undefined && moves.length>moveLimit) {\n\t\taGame.ArrayShuffle(moves);\n\t\tmoves.sort(function(m1,m2) {\n\t\t\tm2.nextBoard.evaluation-m1.nextBoard.evaluation;\n\t\t});\n\t\tmoves.splice(moveLimit,moves.length-moveLimit);\n\t}\n\tthis.mMoves=moves;\n}\n\nModel.Board.GenerateAllMoves = function(aGame) {\n\tvar moves=this.MakeFreeMoves(aGame);\n\treturn moves;\n}\n\nModel.Board.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\tthis.mEvaluation = 0;\n}\n\nModel.Board.ApplyMove = function(aGame,move) {\n\tthis.spApplyMove(aGame,move);\n}\n\nModel.Board.spApplyMove = function(aGame,move) {\n\t//console.log(\"spApplyMove\",move)\n\tvar $this=this;\n\tfunction UpdatePlayables(pos) {\n\t\tdelete $this.playables[pos]; // position cannot be played anymore\n\t\taGame.g.EachDirectionFlat(pos,function(pos1,dir) {\n\t\t\tif($this.board[pos1]) {\n\t\t\t\tvar dir0,pdir;\n\t\t\t\tswitch(dir) {\n\t\t\t\tcase 4: dir0=7; pdir=10; break;\n\t\t\t\tcase 5: dir0=6; pdir=9; break; \n\t\t\t\tcase 6: dir0=4; pdir=8; break;\n\t\t\t\tcase 7: dir0=5; pdir=11; break;\n\t\t\t\t}\n\t\t\t\tvar pos0=aGame.g.Graph[pos][dir0];\n\t\t\t\tif(pos0!==null && $this.board[pos0]>0 &&\n\t\t\t\t\t\t$this.board[aGame.g.Graph[pos1][dir0]])\n\t\t\t\t\t$this.playables[aGame.g.Graph[pos][pdir]]=true;\n\t\t\t}\n\t\t});\t\t\n\t}\n\tswitch(move.act) {\n\tcase \"+\":\n\t\tthis.board[move.pos]=move.clr;\n\t\tvar h=aGame.g.Coord[move.pos][2];\n\t\tif(h>this.maxLayer)\n\t\t\tthis.maxLayer=h;\n\t\tthis.height[move.clr]+=h;\n\t\tthis.ballCount[move.clr]++;\n\n\t\t// check 2x2 platform \n\t\tUpdatePlayables(move.pos);\n\t\tbreak;\n\tcase \">\":\n\t\tif(move.down.length>0)\n\t\t\tthis.playables[move.down[move.down.length-1]]=true;\n\t\telse\n\t\t\tthis.playables[move.from]=true;\n\t\tvar from=move.from;\n\t\tfor(var i=0; i<move.down.length; i++) {\n\t\t\tvar down=move.down[i];\n\t\t\tthis.height[this.board[down]]--;\n\t\t\tthis.board[from]=this.board[down];\n\t\t\tfrom=down;\n\t\t}\n\t\tthis.board[from]=0;\n\t\tthis.board[move.to]=move.clr;\n\t\tvar h=aGame.g.Coord[move.to][2];\n\t\tthis.height[move.clr]+=h;\n\t\tif(h>this.maxLayer)\n\t\t\tthis.maxLayer=h;\n\t\tUpdatePlayables(move.to);\n\t\tbreak;\n\t}\n}\n\nModel.Board.IsValidMove = function(aGame,move) {\n\treturn true;\n}\n\nModel.Board.ExtendMove = function(aGame,pos) {\n\treturn {};\n}\t\n\nModel.Board.GetSignature = function() {\n\treturn this.zSign;\n}\t\n"],"file":"margo5-model.js"}