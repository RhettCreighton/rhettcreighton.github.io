{"version":3,"names":[],"mappings":"","sources":["mana-model.js"],"sourcesContent":["/*\n *\n * Copyright (c) 2012 - Jocly - www.jocly.com\n * \n * This file is part of the Jocly game platform and cannot be used outside of this context without the written permission of Jocly.\n * \n */\n\nModel.Game.InitGame = function() {\n\tvar $this=this;\n\tthis.g.Graph=[];\n\tthis.g.CValue=[];\n\tvar dPos=[[1,0],[-1,0],[0,1],[0,-1]];\n\tfor(var r=0;r<this.mOptions.height;r++)\n\t\tfor(var c=0;c<this.mOptions.width;c++) {\n\t\t\tvar graph=[];\n\t\t\tfor(var i=0;i<dPos.length;i++) {\n\t\t\t\tvar dc=dPos[i][0];\n\t\t\t\tvar dr=dPos[i][1];\n\t\t\t\tvar r1=r+dr;\n\t\t\t\tvar c1=c+dc;\n\t\t\t\tif(r1>=0 && r1<this.mOptions.height && c1>=0 && c1<this.mOptions.width)\n\t\t\t\t\tgraph.push(r1*this.mOptions.width+c1);\n\t\t\t\telse\n\t\t\t\t\tgraph.push(-1);\n\t\t\t}\n\t\t\tthis.g.Graph.push(graph);\n\t\t\tthis.g.CValue[r*this.mOptions.width+c]=parseInt(this.mOptions.initial[r].charAt(c));\n\t\t}\n\t\n\tfunction GetPath(cell,credits,path,exclude) {\n\t\tvar graph=$this.g.Graph[path[path.length-1]];\n\t\tfor(var j=0;j<4;j++) {\n\t\t\tvar pos=graph[j];\n\t\t\tif(pos>=0 && !exclude[pos]) {\n\t\t\t\tif(credits==0) {\n\t\t\t\t\tif(!cell[pos])\n\t\t\t\t\t\tcell[pos]=[];\n\t\t\t\t\tvar path1=[];\n\t\t\t\t\tfor(var k=0;k<path.length;k++)\n\t\t\t\t\t\tpath1.push(path[k]);\n\t\t\t\t\tpath1.push(pos);\n\t\t\t\t\tcell[pos].push(path1);\n\t\t\t\t} else {\n\t\t\t\t\tpath.push(pos);\n\t\t\t\t\texclude[pos]=true;\n\t\t\t\t\tGetPath(cell,credits-1,path,exclude);\n\t\t\t\t\tdelete exclude[pos];\n\t\t\t\t\tpath.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.g.Targets=[];\n\tfor(var pos=0;pos<this.g.Graph.length;pos++) {\n\t\tvar cell={};\n\t\tvar exclude={};\n\t\texclude[pos]=true;\n\t\tGetPath(cell,this.g.CValue[pos]-1,[pos],exclude);\n\t\tthis.g.Targets[pos]=cell;\n\t}\n\n\tthis.g.Orients={\n\t\t\"NW\": {\n\t\t\tangle: -90,\n\t\t},\n\t\t\"NE\": {\n\t\t\tangle: 180,\n\t\t},\n\t\t\"SW\": {\n\t\t\tangle: 0,\n\t\t},\n\t\t\"SE\": {\n\t\t\tangle: 90,\n\t\t},\n\t}\n\t\n\tvar dist=[];\n\tfor(var pos1=0;pos1<this.g.Graph.length;pos1++) {\n\t\tdist.push([]);\n\t\tfor(var pos2=0;pos2<this.g.Graph.length;pos2++)\n\t\t\tdist[pos1].push(pos1==pos2?0:-1);\n\t}\n\twhile(true) {\n\t\tvar changes=0;\n\t\tfor(var pos1=0;pos1<this.g.Graph.length;pos1++)\n\t\t\tfor(var pos2=0;pos2<this.g.Graph.length;pos2++) {\n\t\t\t\tif(dist[pos1][pos2]>=0) {\n\t\t\t\t\tvar targets=this.g.Targets[pos2];\n\t\t\t\t\tfor(var t in targets) \n\t\t\t\t\t\tif(targets.hasOwnProperty(t)) {\n\t\t\t\t\t\t\tvar target=parseInt(t);\n\t\t\t\t\t\t\tif(dist[pos1][target]<0) {\n\t\t\t\t\t\t\t\tdist[pos1][target]=dist[pos1][pos2]+1;\n\t\t\t\t\t\t\t\tchanges++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(changes==0)\n\t\t\tbreak;\n\t}\n\tthis.g.Dist=dist;\n}\n\nModel.Game.DestroyGame = function() {\n}\n\nModel.Move.Init = function(args) {\n\tif(typeof(args)!=\"undefined\")\n\t\tthis.CopyFrom(args);\n}\n\nModel.Move.ToString = function() {\n\tvar notations=[];\n\tif(this.o)\n\t\tnotations.push(\"o\"+this.o);\n\tif(this.p) {\n\t\tfor(var i=0;i<this.p.d.length;i++)\n\t\t\tnotations.push(\"d\"+this.p.d[i]);\n\t\tfor(var i=0;i<this.p.r.length;i++)\n\t\t\tnotations.push(\"r\"+this.p.r[i]);\n\t}\n\tif(this.m)\n\t\tnotations.push(\"m\"+this.m[0]+\">\"+this.m[1]);\n\tif(this.i!==undefined)\n\t\tnotations.push(\"p\"+this.i);\n\treturn notations.join(\" \");\n}\n\nModel.Move.CopyFrom = function(move) {\n\tObject.assign(this,JSON.parse(JSON.stringify(move)));\n}\n\nModel.Board.Init = function(aGame) {\n}\n\nModel.Board.InitialPosition = function(aGame) {\n\tvar pieces=[];\n\tvar board=[];\n\tfor(var i=0;i<aGame.g.Graph.length;i++)\n\t\tboard[i]=-1;\n\tthis.pieces=pieces;\n\tthis.board=board;\n\tthis.stage=1; // 1: orient board + place A pieces, 2: place B pieces, 3: play\n\tthis.mana=-1;\n\tthis.roninOut={\n\t\t\t\"1\": 0,\n\t\t\t\"-1\": 0,\n\t\t}\n\tthis.damyoOut={\n\t\t\t\"1\": 0,\n\t\t\t\"-1\": 0,\n\t\t}\n}\n\nModel.Board._getRCCoord = function(aGame,pos,orient) {\n\tvar r=Math.floor(pos/aGame.mOptions.width);\n\tvar c=pos%aGame.mOptions.width;\n\tif(arguments.length<3)\n\t\torient=this.orient;\n\tif(orient==\"NE\" || orient==\"SW\") {\n\t\tvar t=r;\n\t\tr=c;\n\t\tc=t;\n\t}\n\tif(orient==\"NE\" || orient==\"NW\")\n\t\tc=aGame.mOptions.width-1-c;\n\tif(orient==\"NE\" || orient==\"SE\")\n\t\tr=aGame.mOptions.height-1-r;\n\treturn [r,c];\n}\n\n\nModel.Board.manaCreatePlacement = function(aGame,orient) {\n\tvar poss=[];\n\tfor(var pos=0;pos<aGame.g.Graph.length;pos++) {\n\t\tvar rc=this._getRCCoord(aGame,pos,orient);\n\t\tif((this.mWho==-1 && rc[1]<=1) || (this.mWho==1 && rc[1]>=aGame.mOptions.width-2)) {\n\t\t\tposs.push(pos);\n\t\t}\n\t}\n\tvar placement={\n\t\td: [],\n\t\tr: [],\n\t}\n\tfor(var i=0;i<aGame.mOptions.damyoCount;i++) {\n\t\tvar posIndex=aGame.Random(poss.length);\n\t\tvar pos=poss[posIndex];\n\t\tposs.splice(posIndex,1);\n\t\tplacement.d.push(pos);\n\t}\n\tfor(var i=0;i<aGame.mOptions.roninCount;i++) {\n\t\tvar posIndex=aGame.Random(poss.length);\n\t\tvar pos=poss[posIndex];\n\t\tposs.splice(posIndex,1);\n\t\tplacement.r.push(pos);\n\t}\n\treturn placement;\n}\n\nModel.Board.GenerateMoves = function(aGame) {\n\tthis.mMoves = [];\n\tif(this.stage==1) {\n\t\tvar orients=[\"NE\",\"SE\",\"SW\",\"NW\"];\n\t\tfor(var i=0;i<aGame.mOptions.stage1start;i++) {\n\t\t\tvar orient=orients[aGame.Random(4)];\n\t\t\tvar placement=this.manaCreatePlacement(aGame,orient);\n\t\t\tthis.mMoves.push({\n\t\t\t\to: orient,\n\t\t\t\tp: placement,\n\t\t\t});\n\t\t}\n\t} else if(this.stage==2) {\n\t\tfor(var i=0;i<aGame.mOptions.stage2start;i++) {\n\t\t\tvar placement=this.manaCreatePlacement(aGame,this.orient);\n\t\t\tthis.mMoves.push({\n\t\t\t\tp: placement,\n\t\t\t});\n\t\t}\t\t\n\t} else {\n\t\tvar movables=this.manaMovablePieces(aGame);\n\t\tvar validMoves=[];\n\t\tvar mana=-1;\n\t\tif(this.mana>=0)\n\t\t\tmana=aGame.g.CValue[this.mana];\n\t\tfor(var i in movables) \n\t\t\tif(movables.hasOwnProperty(i)) {\n\t\t\t\tvar piece=this.pieces[i];\n\t\t\t\tif(mana<0 || aGame.g.CValue[piece.p]==mana) {\n\t\t\t\t\tfor(var pos in movables[i])\n\t\t\t\t\t\tif(movables[i].hasOwnProperty(pos))\n\t\t\t\t\t\t\tvalidMoves.push({\n\t\t\t\t\t\t\t\tm: [piece.p,parseInt(pos)],\n\t\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\tif(validMoves.length==0) {\n\t\t\tfor(var i in movables) \n\t\t\t\tif(movables.hasOwnProperty(i)) {\n\t\t\t\t\tvar piece=this.pieces[i];\n\t\t\t\t\tfor(var pos in movables[i])\n\t\t\t\t\t\tif(movables[i].hasOwnProperty(pos))\n\t\t\t\t\t\t\tvalidMoves.push({\n\t\t\t\t\t\t\t\tm: [piece.p,parseInt(pos)],\n\t\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\tif(this.roninOut[this.mWho]>0)\n\t\t\t\tfor(var pos=0;pos<aGame.g.Graph.length;pos++) {\n\t\t\t\t\tif(this.board[pos]<0 && (aGame.mOptions.insertAnywhere || aGame.g.CValue[pos]==mana))\n\t\t\t\t\t\tvalidMoves.push({\n\t\t\t\t\t\t\ti: pos,\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t}\n\t\tthis.mMoves=validMoves;\n\t}\n}\n\n\nModel.Board.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\tthis.mEvaluation=0;\n\tif(this.damyoOut[JocGame.PLAYER_A]>=aGame.mOptions.damyoKillWin) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.PLAYER_B;\n\t\treturn;\n\t} else if(this.damyoOut[JocGame.PLAYER_B]>=aGame.mOptions.damyoKillWin) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.PLAYER_A;\n\t\treturn;\n\t}\n\tvar cellTypesPieceCount={\n\t\t\t\"1\": { 1: 0, 2: 0, 3: 0 },\n\t\t\t\"-1\": { 1: 0, 2: 0, 3: 0 },\n\t\t}\n\tvar cellTypesDamyoCount={\n\t\t\t\"1\": { 1: 0, 2: 0, 3: 0 },\n\t\t\t\"-1\": { 1: 0, 2: 0, 3: 0 },\n\t\t}\n\tvar damyoPoss={\n\t\t\t\"1\": [],\n\t\t\t\"-1\": [],\n\t}\n\tfor(var pIndex=0;pIndex<this.pieces.length;pIndex++) {\n\t\tvar piece=this.pieces[pIndex];\n\t\tif(piece.p>=0) {\n\t\t\tcellTypesPieceCount[piece.s][aGame.g.CValue[piece.p]]++;\n\t\t\tif(piece.t==\"d\") {\n\t\t\t\tcellTypesDamyoCount[piece.s][aGame.g.CValue[piece.p]]++;\n\t\t\t\tdamyoPoss[piece.s].push(piece.p);\n\t\t\t}\n\t\t}\n\t}\n\tfor(var pos=0;pos<aGame.g.Graph.length;pos++) {\n\t\tvar pIndex=this.board[pos];\n\t\tif(pIndex>=0) {\n\t\t\tvar piece=this.pieces[pIndex];\n\t\t}\n\t}\n\tvar typeCount={\n\t\t\"1\": 0,\n\t\t\"-1\": 0,\n\t}\n\tfor(var who=-1;who<=1;who+=2)\n\t\tfor(var type=1;type<=3;type++)\n\t\t\tif(cellTypesPieceCount[who][type]>0)\n\t\t\t\ttypeCount[who]++;\n\tvar sameAsDamyo={\n\t\t\"1\": 0,\n\t\t\"-1\": 0,\n\t}\n\tfor(var who=-1;who<=1;who+=2) \n\t\tfor(var type=1;type<=3;type++)\n\t\t\tsameAsDamyo[who]+=(cellTypesDamyoCount[who][type]*cellTypesPieceCount[who][type]);\n\tvar roninCount={\n\t\t\"1\": 0,\n\t\t\"-1\": 0,\t\t\t\n\t}\n\tfor(var who=-1;who<=1;who+=2)\n\t\troninCount[who]=aGame.mOptions.roninCount-this.roninOut[who];\n\n\tvar dist2Damyo={\n\t\t\"1\": {\n\t\t\tdist: 0,\n\t\t\tinvSquare: 0,\n\t\t},\n\t\t\"-1\": {\n\t\t\tdist: 0,\n\t\t\tinvSquare: 0,\n\t\t},\n\t}\n\tfor(var pIndex=0;pIndex<this.pieces.length;pIndex++) {\n\t\tvar piece=this.pieces[pIndex];\n\t\tif(piece.p>=0 && piece.t==\"r\") {\n\t\t\tvar minDist=-1;\n\t\t\tfor(var i=0;i<damyoPoss[-piece.s].length;i++) {\n\t\t\t\tvar damyoPos=damyoPoss[-piece.s][i];\n\t\t\t\tvar dist=aGame.g.Dist[piece.p][damyoPos];\n\t\t\t\tif(minDist<0 || dist<minDist)\n\t\t\t\t\tminDist=dist;\n\t\t\t}\n\t\t\tif(minDist==0)\n\t\t\t\tdebugger;\n\t\t\tdist2Damyo[piece.s].dist+=minDist;\n\t\t\tdist2Damyo[piece.s].invSquare+=1/(minDist*minDist);\n\t\t}\n\t}\n\t\n\tvar eval=0;\n\tvar factors=aGame.mOptions.factors;\n\teval+=factors.typeCount[typeCount[1]]-factors.typeCount[typeCount[-1]];\n\teval+=factors.sameAsDamyo*(sameAsDamyo[1]-sameAsDamyo[-1]);\n\teval+=factors.roninCount[roninCount[1]]-factors.roninCount[roninCount[-1]];\n\teval+=factors.dist2Damyo*(dist2Damyo[1].dist-dist2Damyo[-1].dist);\n\teval+=factors.dist2DamyoInvSquare*(dist2Damyo[1].invSquare-dist2Damyo[-1].invSquare);\n\t/*\n\tconsole.log(\"eval\",eval,\n\t\t\t\"d\",factors.dist2Damyo*(dist2Damyo[1].dist-dist2Damyo[-1].dist),\n\t\t\t\"dis\",factors.dist2DamyoInvSquare*(dist2Damyo[1].invSquare-dist2Damyo[-1].invSquare),\n\t\t\t\"rc\",factors.roninCount[roninCount[1]]-factors.roninCount[roninCount[-1]],\n\t\t\t\"sd\",factors.sameAsDamyo*(sameAsDamyo[1]-sameAsDamyo[-1]),\n\t\t\t\"tc\",factors.typeCount[typeCount[1]]-factors.typeCount[typeCount[-1]]\n\t\t\t);\n\t*/\n\tif(isNaN(eval))\n\t\tdebugger;\n\tthis.mEvaluation=eval;\n}\n\nModel.Board.ApplyMove = function(aGame,move) {\n\tif(this.stage==1)\n\t\tthis.orient=move.o;\n\tif(this.stage==1 || this.stage==2) {\n\t\tvar index=0;\n\t\tfor(var i=0;i<move.p.d.length;i++) {\n\t\t\tvar p=move.p.d[i];\n\t\t\tvar piece={\n\t\t\t\ts: this.mWho,\n\t\t\t\tt: 'd',\n\t\t\t\tp: p,\n\t\t\t\ti: index++,\n\t\t\t}\n\t\t\tthis.pieces.push(piece);\n\t\t\tthis.board[p]=this.pieces.length-1;\n\t\t}\n\t\tindex=0;\n\t\tfor(var i=0;i<move.p.r.length;i++) {\n\t\t\tvar p=move.p.r[i];\n\t\t\tvar piece={\n\t\t\t\ts: this.mWho,\n\t\t\t\tt: 'r',\n\t\t\t\tp: p,\n\t\t\t\ti: index++,\n\t\t\t}\n\t\t\tthis.pieces.push(piece);\n\t\t\tthis.board[p]=this.pieces.length-1;\n\t\t}\n\t\tthis.stage++;\n\t}\n\tif(move.m) {\n\t\tvar pieceIndex=this.board[move.m[0]];\n\t\tvar piece=this.pieces[pieceIndex];\n\t\tthis.board[move.m[0]]=-1;\n\t\tvar pieceIndex1=this.board[move.m[1]];\n\t\tif(pieceIndex1>=0) {\n\t\t\tvar piece1=this.pieces[pieceIndex1];\n\t\t\tpiece1.p=-1;\n\t\t\tif(piece1.t==\"r\")\n\t\t\t\tthis.roninOut[-this.mWho]++;\n\t\t\telse if(piece1.t==\"d\")\n\t\t\t\tthis.damyoOut[-this.mWho]++;\n\t\t}\n\t\tpiece.p=move.m[1];\n\t\tthis.board[move.m[1]]=pieceIndex;\n\t\tthis.mana=move.m[1];\n\t}\n\tif(move.i!==undefined) {\n\t\tvar piece,i;\n\t\tfor(i=0;i<this.pieces.length;i++) {\n\t\t\tpiece=this.pieces[i];\n\t\t\tif(piece.t==\"r\" && piece.s==this.mWho && piece.p<0)\n\t\t\t\tbreak;\n\t\t}\n\t\tpiece.p=move.i;\n\t\tthis.board[move.i]=i;\n\t\tthis.mana=move.i;\n\t\tthis.roninOut[this.mWho]--;\n\t}\n}\n\t\nModel.Board.IsValidMove = function(aGame,move) {\n\treturn true;\n}\n\t\nModel.Board.manaMovablePieces = function(aGame) {\n\tvar pieces={};\n\tfor(var i=0;i<this.pieces.length;i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.s==this.mWho) {\n\t\t\tvar pos=piece.p;\n\t\t\tfor(var pos1 in aGame.g.Targets[pos]) \n\t\t\t\tif(aGame.g.Targets[pos].hasOwnProperty(pos1)) {\n\t\t\t\t\tif(this.board[pos1]>=0 && this.pieces[this.board[pos1]].s==this.mWho)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar validPath=null;\n\t\t\t\t\tvar pathes=aGame.g.Targets[pos][pos1];\n\t\t\t\t\tfor(var j=0;j<pathes.length;j++) {\n\t\t\t\t\t\tvar valid=true;\n\t\t\t\t\t\tvar path=pathes[j];\n\t\t\t\t\t\tfor(var k=1;k<path.length-1;k++)\n\t\t\t\t\t\t\tif(this.board[path[k]]>=0) {\n\t\t\t\t\t\t\t\tvalid=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(valid) {\n\t\t\t\t\t\t\tvalidPath=path;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(validPath) {\n\t\t\t\t\t\tif(!pieces[i])\n\t\t\t\t\t\t\tpieces[i]={};\n\t\t\t\t\t\tpieces[i][pos1]=validPath;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\treturn pieces;\n}\n\n"],"file":"mana-model.js"}