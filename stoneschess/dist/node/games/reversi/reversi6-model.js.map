{"version":3,"names":[],"mappings":"","sources":["reversi-model.js"],"sourcesContent":["/*\n *\n * Copyright (c) 2012 - Jocly - www.jocly.com\n * \n * This file is part of the Jocly game platform and cannot be used outside of this context without the written permission of Jocly.\n * \n */\n\n(function() {\n\t\n\tvar USE_TYPED_ARRAYS = typeof Int8Array != \"undefined\", ArrayCreate, ArrayClone;\n\t\n\tif(USE_TYPED_ARRAYS) {\n\t\tArrayCreate = function(size) {\n\t\t\treturn new Int8Array(size);\n\t\t}\n\t\tArrayClone = function(array) {\n\t\t\tvar tArray=new Int8Array(array.length);\n\t\t\ttArray.set(array);\n\t\t\treturn tArray;\t\t\t\n\t\t}\n\t} else {\n\t\tArrayCreate = function(size) {\n\t\t\tvar arr=[];\n\t\t\tfor(var i=0;i<size;i++)\n\t\t\t\tarr.push(0);\n\t\t\treturn arr;\n\t\t}\n\t\tArrayClone = function(array) {\n\t\t\tvar arr=[];\n\t\t\tvar arrLength=array.length;\n\t\t\tfor(var i=0;i<arrLength;i++)\n\t\t\t\tarr.push(array[i]);\n\t\t\treturn arr;\n\t\t}\t\t\n\t}\n\t\t\n\tModel.Game.isAlive = function(r,c){\n\t\treturn this.POS(c,r) in this.g.confine;\n\t}\n\t\n\tModel.Game.C = function(pos) {\n\t\treturn pos%this.mOptions.width;\n\t}\n\n\tModel.Game.R = function(pos) {\n\t\treturn Math.floor(pos/this.mOptions.width);\n\t}\n\n\tModel.Game.RC = function(pos) {\n\t\treturn {\n\t\t\tr: Math.floor(pos/this.mOptions.width),\n\t\t\tc: pos%this.mOptions.width,\n\t\t}\n\t}\n\t\n\tModel.Game.POS = function(c,r) {\n\t\treturn r*this.mOptions.width+c;\n\t}\n\t\n\tModel.Game.STR2POS = function(key) {\n\t\tvar m=/^(\\d+):(\\d+)$/.exec(key);\n\t\tif(m) {\n\t\t\tvar r=parseInt(m[1]);\n\t\t\tvar c=parseInt(m[2]);\n\t\t\treturn this.POS(c,r);\n\t\t}\n\t\treturn null;\n\t}\n\n\tModel.Game.InitGame = function() {\n\t\tvar NBCOLS=this.NBCOLS=this.mOptions.width;\n\t\tvar NBROWS=this.NBROWS=this.mOptions.height;\n\t\t\n\t\tthis.g.confine={};\n\t\t\n\t\tthis.g.totalCount=NBROWS*NBCOLS;\n\t\t\n\t\tfor(var r=0;r<NBROWS;r++)\n\t\t\tfor(var c=0;c<NBCOLS;c++)\n\t\t\t\tthis.g.confine[this.POS(c,r)]=1;\n\t\t\n\t\tif(this.mOptions.deadCells)\n\t\t\tfor(var key in this.mOptions.deadCells) {\n\t\t\t\tvar pos=this.STR2POS(key);\n\t\t\t\tif(pos!=null) {\n\t\t\t\t\tthis.g.totalCount--;\n\t\t\t\t\tdelete this.g.confine[pos];\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tthis.g.dirDeltaRC=[[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1],[0,-1]];\n\t\t\n\t\tthis.g.Graph={};\n\t\tfor(var r=0;r<NBROWS;r++) \n\t\t\tfor(var c=0;c<NBCOLS;c++) {\n\t\t\t\tvar pos=this.POS(c,r);\n\t\t\t\tif(!(pos in this.g.confine))\n\t\t\t\t\tcontinue;\n\t\t\t\tvar dirs=ArrayCreate(this.g.dirDeltaRC.length);\n\t\t\t\tfor(var i=0;i<this.g.dirDeltaRC.length;i++) {\n\t\t\t\t\tvar d=this.g.dirDeltaRC[i];\n\t\t\t\t\tvar r1=r+d[0];\n\t\t\t\t\tvar c1=c+d[1];\n\t\t\t\t\tvar pos1=r1*NBCOLS+c1;\n\t\t\t\t\tif(r1>=0 && c1>=0 && r1<NBROWS && c1<NBCOLS && (pos1 in this.g.confine))\n\t\t\t\t\t\tdirs[i]=pos1;\n\t\t\t\t\telse\n\t\t\t\t\t\tdirs[i]=-1;\n\t\t\t\t}\n\t\t\t\tthis.g.Graph[pos]=dirs;\n\t\t\t}\n\t\t\n\t\tthis.g.corners={};\n\t\tfor(var pos in this.g.confine) {\n\t\t\tvar ngb=0;\n\t\t\tfor(var d=0;d<8;d++) {\n\t\t\t\tvar pos1=this.g.Graph[pos][d];\n\t\t\t\tif(pos1<0)\n\t\t\t\t\tngb|=1<<d;\n\t\t\t}\n\t\t\tif((ngb&0xf)==0xf || (ngb&0x1e)==0x1e || (ngb&0x3c)==0x3c || (ngb&0x78)==0x78 ||\n\t\t\t\t(ngb&0xf0)==0xf0 || (ngb&0xe1)==0xe1 || (ngb&0xc3)==0xc3 || (ngb&0x87)==0x87)\n\t\t\t\tthis.g.corners[pos]=1;\n\t\t}\n\t\t\n\t\tthis.g.borders={};\n\t\tfor(var pos in this.g.confine) {\n\t\t\tif(pos in this.g.corners)\n\t\t\t\tcontinue;\n\t\t\tvar ngb=0;\n\t\t\tfor(var d=0;d<8;d++) {\n\t\t\t\tvar pos1=this.g.Graph[pos][d];\n\t\t\t\tif(pos1<0)\n\t\t\t\t\tngb|=1<<d;\n\t\t\t}\n\t\t\tif((ngb&0x7)==0x7 || (ngb&0xe)==0xe || (ngb&0x1c)==0x1c || (ngb&0x38)==0x38 ||\n\t\t\t\t(ngb&0x70)==0x70 || (ngb&0xe0)==0xe0 || (ngb&0xc1)==0xc1 || (ngb&0x83)==0x83)\n\t\t\t\tthis.g.borders[pos]=1;\n\t\t}\n\t\t\n\t\tthis.zobrist=new JocGame.Zobrist({\n\t\t\tboard: {\n\t\t\t\ttype: \"array\",\n\t\t\t\tsize: NBCOLS*NBROWS,\n\t\t\t\tvalues: [\"1\",\"-1\"],\n\t\t\t}\n\t\t});\n\t}\n\t\n\tModel.Move.Init = function(args) {\n\t\tthis.row=args.row;\n\t\tthis.col=args.col;\n\t\tthis.pass=args.pass;\n\t}\n\t\n\tModel.Move.CopyFrom=function(aMove) {\n\t\tthis.row=aMove.row;\n\t\tthis.col=aMove.col;\n\t\tthis.pass=aMove.pass;\n\t}\n\t\n\tModel.Move.ToString=function() {\n\t\tif(this.pass)\n\t\t\treturn \"-\";\n\t\treturn String.fromCharCode(\"a\".charCodeAt(0)+this.col)+(this.row+1);\n\t}\n\t\n\tModel.Move.Equals=function(move) {\n\t\tif(move.pass && this.pass)\n\t\t\treturn true;\n\t\treturn this.row==move.row && this.col==move.col;\n\t}\n\t\n\tModel.Board.Init = function(aGame) {\n\t\tthis.zSign=0;\n\t}\n\n\tModel.Board.InitialPosition = function(aGame) {\n\t\tthis.board=ArrayCreate(aGame.mOptions.width*aGame.mOptions.height);\n\t\tthis.counts=[0,0];\n\t\tthis.freeClose={};\n\t\tthis.passes=0;\n\t\tthis.lastMove=null;\n\t\tvar $this=this;\n\t\t[1,-1].forEach(function(side) {\n\t\t\tvar side01=(1-side)/2;\n\t\t\taGame.mOptions.initial[side].forEach(function(strpos) {\n\t\t\t\t$this.counts[side01]++;\n\t\t\t\tvar pos=aGame.STR2POS(strpos);\n\t\t\t\t$this.board[pos]=side;\n\t\t\t\tdelete $this.freeClose[pos];\n\t\t\t\tfor(var d=0;d<8;d++) {\n\t\t\t\t\tvar pos1=aGame.g.Graph[pos][d];\n\t\t\t\t\tif(pos1<0) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(!$this.board[pos1])\n\t\t\t\t\t\t$this.freeClose[pos1]=1;\n\t\t\t\t}\n\t\t\t\t$this.zSign=aGame.zobrist.update($this.zSign,\"board\",side,pos);\n\t\t\t});\n\t\t});\n\t\tthis.FindMoves(aGame);\n\t\tthis.stable={};\n\t\tfor(var pos in aGame,aGame.g.corners)\n\t\t\tthis.stable[pos]=3;\n\t\tthis.aboutStable={};\n\t\tthis.aboutBorder={};\n\t\tthis.rvUpdateStable(aGame,aGame.g.corners);\n\t\tthis.rvUpdateAboutBorder(aGame);\n\t}\n\t\n\tModel.Board.CopyFrom=function(aBoard) {\n\t\t\n\t\tthis.mWho=aBoard.mWho;\n\t\tthis.zSign=aBoard.zSign;\n\t\tthis.board=ArrayClone(aBoard.board);\n\t\tthis.counts=[aBoard.counts[0],aBoard.counts[1]];\n\t\tthis.freeClose={};\n\t\tfor(var pos in aBoard.freeClose)\n\t\t\tthis.freeClose[pos]=1;\n\t\tthis.passes=aBoard.passes;\n\t\tthis.lastMove=null;\n\t\tif(aBoard.lastMove)\n\t\t\tthis.lastMove={\n\t\t\t\trow: aBoard.lastMove.row,\n\t\t\t\tcol: aBoard.lastMove.col,\n\t\t\t}\n\t\telse\n\t\t\tthis.lastMove=null;\n\t\tthis.movePoss={\n\t\t\t\"1\": ArrayClone(aBoard.movePoss[1]),\n\t\t\t\"-1\": ArrayClone(aBoard.movePoss[-1]),\n\t\t}\n\t\t/*\n\t\tthis.freeStable={};\n\t\tfor(var pos in aBoard.freeStable)\n\t\t\tthis.freeStable[pos]=aBoard.freeStable[pos];\n\t\t*/\n\t\t/*\n\t\tthis.stable={};\n\t\tfor(var pos in aBoard.stable)\n\t\t\tthis.stable[pos]=aBoard.stable[pos];\n\t\t*/\n\t\tthis.stable=aBoard.stable; // !!! stable object member is shared with parent boards, so it must never be modified, but replaced instead\n\t\tthis.aboutStable=aBoard.aboutStable; // !!! idem for aboutStable\n\t\tthis.aboutBorder=aBoard.aboutBorder; // !!! idem for aboutBorder\n\t}\n\n\tModel.Board.GenerateMoves=function(aGame) {\n\t\tthis.mMoves = [];\n\t\tfor(var i=0;i<this.movePoss[this.mWho].length;i++) {\n\t\t\tvar pos=this.movePoss[this.mWho][i];\n\t\t\tvar rc=aGame.RC(pos);\n\t\t\tthis.PushMove(aGame,{row: rc.r, col: rc.c });\n\t\t}\n\t\tif(this.mMoves.length==0)\n\t\t\tthis.PushMove(aGame,{pass: true, row: -1, col: -1 });\n\t\t//console.log(\"GenerateMoves\",this.mWho,this.mMoves.length,\"freeClose\",this.freeClose,\"moves\",this.mMoves);\n\t}\n\n\tModel.Board.FindMoves=function(aGame) {\n\t\tthis.movePoss={\n\t\t\t\"1\": [],\n\t\t\t\"-1\": [],\n\t\t};\n\t\tvar graph=aGame.g.Graph;\n\t\tfor(var pos in this.freeClose) {\n\t\t\tvar posGraph=graph[pos];\n\t\t\tvar isMove=0;\n\t\t\tfor(var d=0;d<8;d++) {\n\t\t\t\tvar pos1=posGraph[d];\n\t\t\t\tvar captured=false;\n\t\t\t\tif(pos1>=0) {\n\t\t\t\t\tvar who=-this.board[pos1];\n\t\t\t\t\tif(who) {\n\t\t\t\t\t\tvar sideBit=who==1?1:2;\n\t\t\t\t\t\tif(!(isMove&sideBit)) {\n\t\t\t\t\t\t\tcaptured=true;\n\t\t\t\t\t\t\tpos1=graph[pos1][d];\n\t\t\t\t\t\t\twhile(this.board[pos1]==-who)\n\t\t\t\t\t\t\t\tpos1=graph[pos1][d];\n\t\t\t\t\t\t\tif(pos1>=0 && this.board[pos1]==who)\n\t\t\t\t\t\t\t\tisMove|=sideBit;\n\t\t\t\t\t\t\tif(isMove==3)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isMove & 1)\n\t\t\t\tthis.movePoss[1].push(pos);\n\t\t\tif(isMove & 2)\n\t\t\t\tthis.movePoss[-1].push(pos);\n\t\t}\n\t\t//console.info(\"FindMoves\",this.movePoss);\n\t}\n\t\n\tModel.Board.ApplyMove=function(aGame,move) {\n\t\tthis.lastMove=null;\n\t\tif(move.pass) {\n\t\t\tthis.passes++;\n\t\t\treturn;\n\t\t}\n\t\tthis.lastMove={\n\t\t\trow: move.row, \n\t\t\tcol: move.col\n\t\t};\n\t\tthis.passes=0;\n\t\tvar side01=(1-this.mWho)/2;\n\t\tvar sideBit=1<<side01;\n\t\tthis.counts[side01]++;\n\t\tvar pos=aGame.POS(move.col,move.row);\n\t\tvar graph=aGame.g.Graph;\n\t\tvar posGraph=graph[pos];\n\t\tthis.board[pos]=this.mWho;\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",this.mWho,pos);\n\t\tdelete this.freeClose[pos];\n\t\tvar stableChange=false;\n\t\t/*\n\t\tif((this.freeStable[pos] || 0) & (1<<side01)) {\n\t\t\tdelete this.freeStable[pos];\n\t\t\tstableChange=true;\n\t\t\tthis.stable[pos]=this.mWho;\n\t\t}\n\t\t*/\n\t\tvar stableSeeds={};\n\t\tif((this.stable[pos] || 0) & sideBit) {\n\t\t\tstableChange=true;\n\t\t\tstableSeeds[pos]=1;\n\t\t}\n\t\tfor(var d=0;d<8;d++) {\n\t\t\tvar pos1=posGraph[d];\n\t\t\tif(pos1>=0 && this.board[pos1]==0) {\n\t\t\t\tthis.freeClose[pos1]=1;\n\t\t\t\t//if(stable)\n\t\t\t\t//\tstableCandidates[pos1]=1;\n\t\t\t}\n\t\t\tvar captured=[];\n\t\t\twhile(pos1>=0 && this.board[pos1]==-this.mWho) {\n\t\t\t\tcaptured.push(pos1);\n\t\t\t\tpos1=graph[pos1][d];\n\t\t\t}\n\t\t\tif(pos1>=0 && captured.length>0 && this.board[pos1]==this.mWho) {\n\t\t\t\tfor(var i=captured.length-1;i>=0;i--) {\n\t\t\t\t\tvar pos2=captured[i];\n\t\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",-this.mWho,pos2);\n\t\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",this.mWho,pos2);\n\t\t\t\t\tthis.board[pos2]=this.mWho;\n\t\t\t\t\tthis.counts[side01]++;\n\t\t\t\t\tthis.counts[1-side01]--;\n\t\t\t\t\tif((this.stable[pos2] || 0) & sideBit) {\n\t\t\t\t\t\tstableChange=true;\n\t\t\t\t\t\tstableSeeds[pos2]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(stableChange)\n\t\t\tthis.rvUpdateStable(aGame,stableSeeds);\n\t\tif(pos in aGame.g.borders)\n\t\t\tthis.rvUpdateAboutBorder(aGame);\t\t\t\n\t\tthis.FindMoves(aGame);\n\t}\n\t\n\tModel.Board.rvUpdateStable=function(aGame,seeds) {\n\t\tvar stable=this.stable;\n\t\tthis.stable={};\n\t\tfor(var pos in stable)\n\t\t\tthis.stable[pos]=stable[pos];\n\t\tvar looping=true;\n\t\tvar sideBit=this.mWho==1?1:2;\n\t\tvar graph=aGame.g.Graph;\n\t\twhile(looping) {\n\t\t\tlooping=false;\n\t\t\tvar seeds2={};\n\t\t\tfor(var pos in seeds) {\n\t\t\t\tvar posGraph=graph[pos];\n\t\t\t\tfor(var d=0;d<8;d++) {\n\t\t\t\t\tvar pos1=posGraph[d];\n\t\t\t\t\tif(pos1>=0 && !((this.stable[pos1] || 0) & sideBit))\n\t\t\t\t\t\tseeds2[pos1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar seeds={};\n\t\t\tfor(var pos in seeds2) {\n\t\t\t\tvar posGraph=graph[pos];\n\t\t\t\tvar ngb=0;\n\t\t\t\tfor(var d=0;d<8;d++) {\n\t\t\t\t\tvar pos1=posGraph[d];\n\t\t\t\t\tif(pos1<0 || (this.board[pos1]==this.mWho && (this.stable[pos1] || 0) & sideBit))\n\t\t\t\t\t\tngb|=1<<d;\n\t\t\t\t}\n\t\t\t\tif((ngb&0xf)==0xf || (ngb&0x1e)==0x1e || (ngb&0x3c)==0x3c || (ngb&0x78)==0x78 ||\n\t\t\t\t\t(ngb&0xf0)==0xf0 || (ngb&0xe1)==0xe1 || (ngb&0xc3)==0xc3 || (ngb&0x87)==0x87) {\n\t\t\t\t\tthis.stable[pos] = (this.stable[pos] || 0) | sideBit;\n\t\t\t\t\tlooping=true;\n\t\t\t\t\tseeds[pos]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.aboutStable={};\n\t\tfor(var pos in this.stable) {\n\t\t\tif(this.board[pos])\n\t\t\t\tcontinue;\n\t\t\tvar posGraph=graph[pos];\n\t\t\tfor(var d=0;d<8;d++) {\n\t\t\t\tvar pos1=posGraph[d];\n\t\t\t\tif(pos1>=0 && !(pos1 in this.stable))\n\t\t\t\t\tthis.aboutStable[pos1] = (this.aboutStable[pos1] || 0) | this.stable[pos];\n\t\t\t}\n\t\t}\n\t\t//console.info(\"stable\",this.stable,\"aboutStable\",this.aboutStable);\n\t}\n\n\tModel.Board.rvUpdateAboutBorder=function(aGame) {\n\t\tthis.aboutBorder={};\n\t\tvar graph=aGame.g.Graph;\n\t\tvar borders=aGame.g.borders;\n\t\tfor(var pos in borders) {\n\t\t\tif(this.board[pos])\n\t\t\t\tcontinue;\n\t\t\tvar posGraph=graph[pos];\n\t\t\tfor(var d=0;d<8;d++) {\n\t\t\t\tvar pos1=posGraph[d];\n\t\t\t\tif(pos1>=0 && !(pos1 in this.stable) && !(pos1 in this.aboutStable) && !(pos1 in borders))\n\t\t\t\t\tthis.aboutBorder[pos1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tModel.Board.Evaluate=function(aGame) {\n\t\tthis.mEvaluation=0;\n\t\tvar NBCOLS=aGame.mOptions.width;\n\t\tvar NBROWS=aGame.mOptions.height;\n\t\tif(this.passes==2 || this.counts[0]+this.counts[1]==aGame.g.totalCount || this.counts[0]==0 || this.counts[1]==0) {\n\t\t\tthis.mFinished=true;\n\t\t\tif(this.counts[0]>this.counts[1])\n\t\t\t\tthis.mWinner=JocGame.PLAYER_A;\n\t\t\telse if(this.counts[0]<this.counts[1])\n\t\t\t\tthis.mWinner=JocGame.PLAYER_B;\n\t\t\telse\n\t\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\treturn;\n\t\t}\n\n\t\tvar evParams=aGame.mOptions.levelOptions;\n\t\tvar evalValues={};\n\n\t\tvar stableCount={\n\t\t\t'1': 0,\n\t\t\t'-1': 0,\n\t\t};\n\t\tvar aboutStableCount={\n\t\t\t'1': 0,\n\t\t\t'-1': 0,\n\t\t};\n\t\tvar aboutStableBorderCount={\n\t\t\t'1': 0,\n\t\t\t'-1': 0,\n\t\t};\n\t\tvar borderCount={\n\t\t\t'1': 0,\n\t\t\t'-1': 0,\n\t\t};\n\t\tvar confine=aGame.g.confine;\n\t\tvar borders=aGame.g.borders;\n\t\tfor(var pos in confine) {\n\t\t\tvar who=this.board[pos];\n\t\t\tif(!who)\n\t\t\t\tcontinue;\n\t\t\tvar sideBit=who==1?1:2;\n\t\t\tvar sideBitInv=who==1?2:1;\n\t\t\tif((this.stable[pos] || 0) & sideBit)\n\t\t\t\tstableCount[who]++;\n\t\t\telse if((this.aboutStable[pos] || 0) & sideBitInv) {\n\t\t\t\tif(pos in borders)\n\t\t\t\t\taboutStableBorderCount[who]++;\n\t\t\t\telse\n\t\t\t\t\taboutStableCount[who]++;\n\t\t\t} else if(pos in borders)\n\t\t\t\tborderCount[who]++;\n\t\t}\n\t\t\n\t\tevalValues.stable=(stableCount[1]-stableCount[-1]);\n\n\t\tevalValues.aboutStable=(aboutStableCount[1]-aboutStableCount[-1]);\n\n\t\tevalValues.aboutStableBorder=(aboutStableBorderCount[1]-aboutStableBorderCount[-1]);\n\n\t\tevalValues.border=(borderCount[1]-borderCount[-1]);\n\n\t\tevalValues.count=(this.counts[0]-this.counts[1]);\n\n\t\tvar totalMovePoss = (this.movePoss[1].length+this.movePoss[-1].length);\n\t\tif(totalMovePoss)\n\t\t\tevalValues.mobility=(this.movePoss[1].length-this.movePoss[-1].length)/totalMovePoss;\n\t\telse\n\t\t\tevalValues.mobility=0;\n\n\t\tfor(var name in evalValues) {\n\t\t\tvar value=evalValues[name];\n\t\t\tvar factor=evParams[name+'Factor'] || 0;\n\t\t\tvar weighted=value*factor;\n\t\t\tthis.mEvaluation+=weighted;\n\t\t}\n\t}\n\n\tModel.Board.GetSignature = function() {\n\t\treturn this.zSign;\n\t}\t\n\t\n})();\n"],"file":"reversi6-model.js"}