{"version":3,"names":[],"mappings":"","sources":["mills-model.js"],"sourcesContent":["/*\n *\n * Copyright (c) 2012 - Jocly - www.jocly.com\n * \n * This file is part of the Jocly game platform and cannot be used outside of this context without the written permission of Jocly.\n * \n */\n\nModel.Game.InitGameInfo = function() {\n\t// overload to set game feature options\n}\n\nModel.Game.BuildGraphCoord = function() {\n\tvar g=[];\n\tvar coord=[];\n\tthis.g.Graph=g;\n\tthis.g.Coord=coord;\n}\n\n/* Optional method.\n * Called when the game is created.\n */\nModel.Game.InitGame = function() {\n\tthis.BuildGraphCoord();\n\t/*\n\t * Access possible triplets from each position\n\t */\n\tthis.g.TripletsByPos=[];\n\tfor(var i=0;i<this.g.Coord.length;i++)\n\t\tthis.g.TripletsByPos[i]=[];\n\tfor(var i in this.g.Triplets)\n\t\tif(this.g.Triplets.hasOwnProperty(i)) {\n\t\t\tvar triplet=this.g.Triplets[i];\n\t\t\tfor(var j in triplet)\n\t\t\t\tif(triplet.hasOwnProperty(j)) {\n\t\t\t\t\tvar pos1=triplet[j];\n\t\t\t\t\tthis.g.TripletsByPos[pos1].push(triplet);\n\t\t\t\t}\n\t\t}\n\tthis.InitGameExtra();\n}\n\n/* Optional method.\n * Called when the game is over.\n */\nModel.Game.DestroyGame = function() {\n}\n\nModel.Game.MillsDirections = 4;\n\n// walk through neighbor positions\nModel.Game.MillsEachDirection = function(pos,fnt) {\n\tfor(var i=0;i<this.MillsDirections;i++) {\n\t\tvar npos=this.g.Graph[pos][i];\n\t\tif(npos!=null)\n\t\t\tfnt(npos);\n\t}\n}\n\n/* Constructs an instance of the Move object for the game.\n * args is either an empty object ({}), or contains the data passed to the InitUI parameter.\n */\nModel.Move.Init = function(args) {\n\tthis.f=args.f; // from position, -1 if placing\n\tthis.t=args.t; // to position\n\tthis.c=args.c; // opponent catch position, -1 if none, -2 any capture => end of game\n}\n\n/* Optional method.\n * Copy the given board data to self.\n * Even if optional, it is better to implement the method for performance reasons. \n */\nModel.Move.CopyFrom = function(aMove) {\n\tthis.f=aMove.f;\n\tthis.t=aMove.t;\n\tthis.c=aMove.c;\n}\n\n/* Optional method.\n * Verify move equality. If not defined, comparison is performed from JSON stringification of move objects.\n */\nModel.Move.Equals = function(move) {\n\treturn this.t==move.t && this.c==move.c && this.f==move.f;\n}\n\n/* Optional method.\n * Returns a string to represent the move for display to human. If not defined JSON is used.\n */\nModel.Move.ToString = function() {\n\tvar str=\"\";\n\tif(this.f>-1)\n\t\tstr+=this.f+\">\";\n\tstr+=this.t;\n\tif(this.c>-1)\n\t\tstr+=\"x\"+this.c;\n\treturn str;\n}\n\n/* Board object constructor.\n */\nModel.Board.Init = function(aGame) {\n}\n\nModel.Board.InitialPosition = function(aGame) {\n\tvar posCount=aGame.g.Coord.length;    // how many board positions\n\tvar menCount=aGame.mOptions.mencount; // how many men per side\n\t\n\t\n\tthis.board=[]; // access pieces by position\n\tfor(var p=0;p<posCount;p++) {\n\t\tthis.board[p]=-1; // index in this.pieces. -1 => no piece at this position\n\t}\n\t\n\tthis.pieces=[];\n\tthis.dock={\n\t\t\"1\": [],\n\t\t\"-1\": [],\n\t}\n\tthis.menCount={\n\t\t\"1\": 0,\n\t\t\"-1\": 0,\t\t\t\n\t}\n\tvar index=0;\n\tfor(var i=0;i<2;i++) {\n\t\tvar side=(i==0)?1:-1;\n\t\tfor(var m=0;m<menCount;m++) {\n\t\t\tthis.dock[side].unshift(index);\n\t\t\tthis.pieces.push({\n\t\t\t\ts: side,    // which side is that piece: 1=A, -1=B\n\t\t\t\ta: true,    // piece is active (not yet placed or on the board)\n\t\t\t\td: m,   \t// dock rank, -1 => piece on the board\n\t\t\t\tp: -1,       // position on the piece on the board, -1=piece has not yet been placed\n\t\t\t\ti: index++,  // piece index in Board.pieces\n\t\t\t});\t\t\t\n\t\t}\n\t}\n\t\n\tthis.placing=true; // placing stage\n}\n\nModel.Board.StaticGenerateMoves = function(aGame) {\n\t//JocLog(\"StaticGenerateMoves\",aGame);\n\tif(aGame.mFullPlayedMoves.length==0) { // very first move: pick randomly\n\t\tvar moves=[];\n\t\tfor(var i=0;i<aGame.g.Coord.length;i++) {\n\t\t\tmoves.push({f:-1,t:i,c:-1});\n\t\t}\n\t\treturn moves;\n\t}\n\treturn null;\n}\n\n/* Push into the mMoves array, every possible move\n */\nModel.Board.GenerateMoves = function(aGame) {\n\t/*\n\tJocLog(\"Level\",aGame.mCurrentLevel,aGame.mLevelInfo);\n\tif(aGame.mCurrentLevel>=0) { // computing generation\n\t\tif(aGame.mLevelInfo.maxDepth-aGame.mCurrentLevel>=2)\n\t\t\t// only \"meaningful\" moves\n\t}\n\t*/\n\tthis.mMoves = [];\n\tif(this.placing)\n\t\tthis.GeneratePlacingMoves(aGame);\n\telse if(aGame.mOptions.canFly)\n\t\tthis.GenerateFlyingMoves(aGame);\n\telse\n\t\tthis.GenerateMovingMoves(aGame);\n\tif(this.mMoves.length==0) {\n\t\tthis.mFinished=true;\n\t\tif(this.menCount[JocGame.PLAYER_A]+this.menCount[JocGame.PLAYER_B]==aGame.g.Coord.length)\n\t\t\tthis.mWinner=JocGame.DRAW;\n\t\telse\n\t\t\tthis.mWinner=-this.mWho;\n\t}\n}\n\nModel.Board.GeneratePlacingMoves = function(aGame) {\n\tfor(var p=0;p<aGame.g.Coord.length;p++)\n\t\tif(this.board[p]==-1) {\n\t\t\tvar considerPos=true;\n\t\t\tif(typeof aGame.mLevelInfo != \"undefined\" && aGame.mCurrentLevel>=0) { // computing generation\n\t\t\t\tvar vDepth=aGame.mLevelInfo.maxDepth-aGame.mCurrentLevel;\n\t\t\t\tif(vDepth>=aGame.mLevelInfo.placingRace) { // if deep in calculation, only consider meaningful moves\n\t\t\t\t\tconsiderPos=false;\n\t\t\t\t\tfor(var i in aGame.g.TripletsByPos[p]) \n\t\t\t\t\t\tif(aGame.g.TripletsByPos[p].hasOwnProperty(i)) { // for each triplet the position belongs to\n\t\t\t\t\t\t\tvar triplet=aGame.g.TripletsByPos[p][i];\n\t\t\t\t\t\t\tvar self=0, other=0, empty=0; \n\t\t\t\t\t\t\tfor(var j=0;j<3;j++) {\n\t\t\t\t\t\t\t\tif(this.board[triplet[j]]==-1)\n\t\t\t\t\t\t\t\t\tempty++;\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif(this.pieces[this.board[triplet[j]]].s==this.mWho)\n\t\t\t\t\t\t\t\t\t\tself++;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tother++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(self==2 || (self==1 && other==0) || other==2) {\n\t\t\t\t\t\t\t\tconsiderPos=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(considerPos)\n\t\t\t\tthis.GenerateCapturingMoves(aGame,{\n\t\t\t\t\tf: -1,\n\t\t\t\t\tt: p,\n\t\t\t\t\tc: -1,\n\t\t\t\t});\n\t\t}\n}\n\nModel.Board.GenerateMovingMoves = function(aGame) {\n\t$this=this;\n\tfor(var i=0; i< this.pieces.length; i++) {\n\t\tvar piece=this.pieces[i];\n\t\tif(piece.a && piece.s==this.mWho) {\n\t\t\taGame.MillsEachDirection(piece.p,function(pos) {\n\t\t\t\tif($this.board[pos]==-1) {\n\t\t\t\t\t$this.GenerateCapturingMoves(aGame,{\n\t\t\t\t\t\tf: piece.p,\n\t\t\t\t\t\tt: pos,\n\t\t\t\t\t\tc: -1,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\nModel.Board.GenerateFlyingMoves = function(aGame) {\n\tif(this.menCount[this.mWho]!=3)\n\t\tthis.GenerateMovingMoves(aGame);\n\telse {\n\t\tfor(var i=0; i<this.pieces.length; i++) {\n\t\t\tvar piece=this.pieces[i];\n\t\t\tif(piece.a && piece.s==this.mWho) {\n\t\t\t\tfor(var pos=0; pos<this.board.length; pos++) {\n\t\t\t\t\tif(this.board[pos]==-1) {\n\t\t\t\t\t\tthis.GenerateCapturingMoves(aGame,{\n\t\t\t\t\t\t\tf: piece.p,\n\t\t\t\t\t\t\tt: pos,\n\t\t\t\t\t\t\tc: -1,\n\t\t\t\t\t\t});\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nModel.Board.GenerateCapturingMoves = function(aGame,move) {\n\tfor(var i in aGame.g.TripletsByPos[move.t]) \n\t\tif(aGame.g.TripletsByPos[move.t].hasOwnProperty(i)) {\n\t\t\tvar triplet=aGame.g.TripletsByPos[move.t][i];\n\t\t\tvar capture=true;\n\t\t\tfor(var j=0;j<3;j++) {\n\t\t\t\tvar pos=triplet[j];\n\t\t\t\tif(pos!=move.t) {\n\t\t\t\t\tif(this.board[pos]==-1 || move.f==pos) {\n\t\t\t\t\t\tcapture=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvar piece=this.pieces[this.board[pos]];\n\t\t\t\t\tif(piece.a==false || piece.d>-1 || piece.s!=this.mWho) {\n\t\t\t\t\t\tcapture=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(capture) {\n\t\t\t\tif(this.menCount[-this.mWho]==3 && this.placing==false) {\n\t\t\t\t\tthis.mMoves.push({\n\t\t\t\t\t\tf: move.f,\n\t\t\t\t\t\tt: move.t,\n\t\t\t\t\t\tc: -2,\n\t\t\t\t\t});\t\t\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar moves=[]\n\t\t\t\tfor(var j=0; j<this.pieces.length; j++) {\n\t\t\t\t\tvar piece=this.pieces[j];\n\t\t\t\t\tif(piece.a==true && piece.d==-1 && piece.s==-this.mWho) {\n\t\t\t\t\t\tvar cMove={\n\t\t\t\t\t\t\t\tf: move.f,\n\t\t\t\t\t\t\t\tt: move.t,\n\t\t\t\t\t\t\t\tc: piece.p,\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmoves.push(cMove);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(aGame.mOptions.poundInMill==false) {\n\t\t\t\t\tvar inMill={};\n\t\t\t\t\tfor(var k in aGame.g.Triplets) \n\t\t\t\t\t\tif(aGame.g.Triplets.hasOwnProperty(k)) {\n\t\t\t\t\t\t\tvar t=aGame.g.Triplets[k];\n\t\t\t\t\t\t\tif((this.board[t[0]]!=-1 && this.pieces[this.board[t[0]]].s==-this.mWho) &&\n\t\t\t\t\t\t\t\t\t(this.board[t[1]]!=-1 && this.pieces[this.board[t[1]]].s==-this.mWho) &&\n\t\t\t\t\t\t\t\t\t(this.board[t[2]]!=-1 && this.pieces[this.board[t[2]]].s==-this.mWho)) {\n\t\t\t\t\t\t\t\tinMill[t[0]]=true;\n\t\t\t\t\t\t\t\tinMill[t[1]]=true;\n\t\t\t\t\t\t\t\tinMill[t[2]]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tvar moves0=[];\n\t\t\t\t\tfor(var k=0; k<moves.length; k++) {\n\t\t\t\t\t\tif(!inMill[moves[k].c])\n\t\t\t\t\t\t\tmoves0.push(moves[k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(moves0.length>0)\n\t\t\t\t\t\tmoves=moves0;\n\t\t\t\t}\n\t\t\t\tthis.mMoves=this.mMoves.concat(moves);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t// no capture\n\tthis.mMoves.push({\n\t\tf: move.f,\n\t\tt: move.t,\n\t\tc: -1,\n\t});\n}\n\n/* The Evaluate method must:\n * - detects whether the game is finished by setting mFinished to true, and determine the winner by assigning\n * mWinner (to JocGame.PLAYER_A, JocGame.PLAYER_B, JocGame.DRAW).\n * - calculate mEvaluation to indicate apparent advantage to PLAYER_A (higher positive evaluation) or to\n * PLAYER_B (lower negative evaluation)\n * Parameters:\n * - aFinishOnly: it is safe to ignore this parameter value, but for better performance, the mEvaluation setting\n * can be skipped if aFinishOnly is true (function caller is only interested if the game is finished).\n * - aTopLevel: it is safe to ignore this parameter value. For convenience, if true, there is no performance involved \n * so it is safe to make additional calculation and storing data, for instance to simplify the display of the last move.\n */\nModel.Board.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\tif(aGame.GetRepeatOccurence(this)>2) {\n\t\tthis.mFinished=true;\n\t\tthis.mWinner=JocGame.DRAW;\n\t\treturn;\n\t}\n\tif(this.placing==false) {\n\t\tif(this.menCount[JocGame.PLAYER_A]<3) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.PLAYER_B;\n\t\t\treturn;\n\t\t}\n\t\tif(this.menCount[JocGame.PLAYER_B]<3) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.PLAYER_A;\n\t\t\treturn;\n\t\t}\n\t}\n\tvar menCountDiff=this.menCount[JocGame.PLAYER_A]-this.menCount[JocGame.PLAYER_B];\n\tvar linesDiff1=0;\n\tvar linesDiff2=0;\n\tfor(var i in aGame.g.Triplets) \n\t\tif(aGame.g.Triplets.hasOwnProperty(i)) {\n\t\t\tvar count={\n\t\t\t\t\"-1\": 0,\n\t\t\t\t\"0\": 0,\n\t\t\t\t\"1\": 0,\n\t\t\t}\n\t\t\tvar triplet=aGame.g.Triplets[i];\n\t\t\tfor(var j=0;j<3;j++) {\n\t\t\t\tvar pos=triplet[j];\n\t\t\t\tvar index=this.board[pos];\n\t\t\t\tif(index>-1) {\n\t\t\t\t\tvar piece=this.pieces[index];\n\t\t\t\t\tcount[piece.s]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count[1]==1 && count[-1]==0)\n\t\t\t\tlinesDiff1++;\n\t\t\telse if(count[1]==2 && count[-1]==0)\n\t\t\t\tlinesDiff2++;\n\t\t\tif(count[-1]==1 && count[1]==0)\n\t\t\t\tlinesDiff1--;\n\t\t\telse if(count[-1]==2 && count[1]==0)\n\t\t\t\tlinesDiff2--;\n\t\t}\n\tthis.mEvaluation=menCountDiff*10;\n\tthis.mEvaluation+=linesDiff1*1;\n\tthis.mEvaluation+=linesDiff2*3;\n}\n\n/* Modify the current board instance to apply the move.\n */\nModel.Board.ApplyMove = function(aGame,move) {\n\tif(this.placing) {\n\t\tvar index=this.dock[this.mWho].shift();\n\t\tvar piece=this.pieces[index];\n\t\tpiece.d=-1;\n\t\tpiece.p=move.t;\n\t\tthis.board[move.t]=index;\n\t\tthis.lastMoveIndex=index;\n\t\tthis.menCount[this.mWho]++;\n\t\tif(this.dock[JocGame.PLAYER_B].length==0)\n\t\t\tthis.placing=false;\n\t} else {\n\t\tvar piece=this.pieces[this.board[move.f]];\n\t\tthis.board[piece.p]=-1;\n\t\tthis.board[move.t]=piece.i;\n\t\tpiece.p=move.t;\n\t\tthis.lastMoveIndex=piece.i;\t\t\n\t}\n\tif(move.c>-1) {\n\t\tvar index=this.board[move.c];\n\t\tthis.board[move.c]=-1;\n\t\tvar piece=this.pieces[index];\n\t\tpiece.a=false;\n\t\tthis.menCount[-this.mWho]--;\n\t} else if(move.c==-2)\n\t\tthis.menCount[-this.mWho]--;\n}\n\t\nModel.Board.IsValidMove = function(aGame,move) {\n\treturn true;\n}\n\n\t"],"file":"9-men-morris-fly-model.js"}