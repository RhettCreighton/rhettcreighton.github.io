{"version":3,"names":[],"mappings":"","sources":["pensoc-model.js"],"sourcesContent":["/*\n *\n * Copyright (c) 2012 - Jocly - www.jocly.com\n * \n * This file is part of the Jocly game platform and cannot be used outside of this context without the written permission of Jocly.\n * \n */\n\n(function() {\n\n\tfunction Pos2RC(pos) {\n\t\treturn [Math.floor(pos/8),pos%8];\n\t}\n\n\tvar Dist2Goal=[];\n\tfor(var pos=0;pos<64;pos++) {\n\t\tvar rc=Pos2RC(pos);\n\t\tvar r=rc[0];\n\t\tvar c=rc[1];\n\t\tDist2Goal.push(Math.max(r,c));\n\t}\n\n\tvar Distance=[];\n\tfor(var pos0=0;pos0<64;pos0++) {\n\t\tvar line=[];\n\t\tDistance.push(line);\n\t\tvar rc0=Pos2RC(pos0);\n\t\tvar r0=rc0[0];\n\t\tvar c0=rc0[1];\n\t\tfor(var pos1=0;pos1<pos0;pos1++) {\n\t\t\tvar rc1=Pos2RC(pos1);\n\t\t\tvar r1=rc1[0];\n\t\t\tvar c1=rc1[1];\n\t\t\tline.push(Math.max(Math.abs(r0-r1),Math.abs(c0-c1)));\n\t\t}\n\t}\n\tfunction PSDist(pos0,pos1) {\n\t\tif(pos0==pos1)\n\t\t\treturn 0;\n\t\tif(pos1>pos0) {\n\t\t\tvar tmp=pos1;\n\t\t\tpos1=pos0;\n\t\t\tpos0=tmp;\n\t\t}\n\t\treturn Distance[pos0][pos1];\n\t}\n\t\n\tvar DirsRC=[\n\t\t[1,1],\n\t\t[1,0],\n\t\t[1,-1],\n\t\t[0,-1],\n\t\t[-1,-1],\n\t\t[-1,0],\n\t\t[-1,1],\n\t\t[0,1],\n\t];\n\tvar Graph=[];\n\tfor(var pos=0;pos<64;pos++) {\n\t\tvar cell=[];\n\t\tvar rc=Pos2RC(pos);\n\t\tfor(var d=0;d<8;d++) {\n\t\t\tvar r=rc[0]+DirsRC[d][0];\n\t\t\tvar c=rc[1]+DirsRC[d][1];\n\t\t\tif(r<0 || r>=8 || c<0 || c>=8)\n\t\t\t\tcell.push(null);\n\t\t\telse\n\t\t\t\tcell.push(r*8+c);\n\t\t}\n\t\tGraph.push(cell);\n\t}\n\n\tvar Reachable=[];\n\tfor(var pos=0;pos<64;pos++) {\n\t\tvar all={};\n\t\tvar reach={\n\t\t\t'-1': all,\n\t\t};\n\t\tReachable.push(reach);\n\t\tfor(var d=0;d<8;d++) {\n\t\t\tvar dir={};\n\t\t\treach[d]=dir;\n\t\t\tvar pos1=Graph[pos][d];\n\t\t\tfor(var i=1;i<4 && pos1!=null;i++) {\n\t\t\t\tdir[pos1]=i;\n\t\t\t\tall[pos1]=i;\n\t\t\t\tpos1=Graph[pos1][d];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tModel.Game.InitGame = function() {\n\t\tthis.g.Graph=Graph;\n\t\tthis.zobrist=new JocGame.Zobrist({\n\t\t\tboard: {\n\t\t\t\ttype: \"array\",\n\t\t\t\tsize: 65,\n\t\t\t\tvalues: [\"-1\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"],\n\t\t\t},\n\t\t\tdirs: {\n\t\t\t\ttype: \"array\",\n\t\t\t\tsize: 9,\n\t\t\t\tvalues: [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"],\n\t\t\t},\n\t\t});\n\t}\n\t\n\tModel.Move.Init = function(args) {\n\t\tthis.i=parseInt(args.i); // piece index: 0=WM,1=WP,2=WB,3=BM,4=BP,5=BB\n\t\tthis.p=parseInt(args.p); // destination for the penguin or the ball\n\t\tthis.d=parseInt(args.d); // direction 0 to 7 or -1: the penguin will face after the move, -1 means standing up\n\t\tthis.md=parseInt(args.md); // direction of the movement, for the penguin or the ball\n\t}\n\t\n\tModel.Move.CopyFrom = function(args) {\n\t\tthis.Init(args);\n\t}\n\t\n\tModel.Move.ToString = function() {\n\t\tvar str=\"\";\n\t\tstr+=this.p;\n\t\tstr+=['M','P','B','M','P','B'][this.i];\n\t\tstr+=this.d;\n\t\treturn str;\n\t}\n\t\n\tModel.Move.Equals = function(move) {\n\t\treturn this.p==move.p && this.i==move.i && this.d==move.d && this.md==move.md;\n\t}\n\t\n\tModel.Board.Init = function(aGame) {\n\t\tthis.zSign=0;\n\t}\n\t\n\tModel.Board.InitialPosition = function(aGame) {\n\t\tthis.board=[];\n\t\tfor(var i=0;i<64;i++)\n\t\t\tthis.board.push(null);\n\t\tthis.penguins=[];\n\t\tfor(var who=1;who>-2;who-=2)  \n\t\t\tfor(var type=0;type<3;type++) {\n\t\t\t\tvar index=this.penguins.length;\n\t\t\t\tvar penguin={\n\t\t\t\t\tp: -1,\n\t\t\t\t\ti: index,\n\t\t\t\t\ts: who,\n\t\t\t\t\tt: type,\n\t\t\t\t\td: -1,\n\t\t\t\t};\n\t\t\t\tthis.penguins.push(penguin);\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",index,0);\n\t\t\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"dirs\",index,0);\n\t\t\t}\n\t\tthis.ball=-1;\n\t\tthis.zSign=aGame.zobrist.update(this.zSign,\"board\",-1,0);\n\t}\n\t\n\tModel.Board.CopyFrom = function(aBoard) {\n\t\tthis.board=[];\n\t\tfor(var i=0;i<aBoard.board.length;i++)\n\t\t\tthis.board.push(null);\n\t\tthis.penguins=[];\n\t\tfor(var i in aBoard.penguins) {\n\t\t\tvar penguin0=aBoard.penguins[i];\n\t\t\tvar penguin={\n\t\t\t\tp: penguin0.p,\n\t\t\t\ts: penguin0.s,\n\t\t\t\ti: penguin0.i,\n\t\t\t\tt: penguin0.t,\n\t\t\t\td: penguin0.d,\n\t\t\t}\n\t\t\tthis.penguins.push(penguin);\n\t\t\tif(penguin.p>-1)\n\t\t\t\tthis.board[penguin.p]=penguin;\n\t\t}\n\t\tthis.ball=aBoard.ball;\n\t\tthis.mWho=aBoard.mWho;\n\t\tthis.zSign=aBoard.zSign;\n\t}\n\t\n\tModel.Board.GenerateMoves = function(aGame) {\n\t\tthis.mMoves=this.PenSocGetAllMoves(aGame);\n\t}\n\t\n\tModel.Board.PenSocGetAllMoves = function(aGame) {\n\t\tvar moves=[];\n\t\tfor(var i=0;i<this.penguins.length;i++) {\n\t\t\tvar penguin=this.penguins[i];\n\t\t\tif(penguin.s==this.mWho) {\n\t\t\t\tmoves=moves.concat(this.PenSocGetBoardMoves(aGame,penguin));\n\t\t\t}\n\t\t}\n\t\treturn moves;\n\t}\n\t\n\tModel.Board.PenSocGetRotatingMoves=function(aGame,index,pos,dir,dirSteps) {\n\t\tvar moves=[];\n\t\tfor(var d=dir-dirSteps;d<=dir+dirSteps;d++) {\n\t\t\tmoves.push({\n\t\t\t\ti:index,\n\t\t\t\tp: pos,\n\t\t\t\td: (d+8)%8,\n\t\t\t\tmd: (dir+8)%8,\n\t\t\t});\n\t\t}\n\t\treturn moves;\n\t}\n\t\n\tModel.Board.PenSocGetBoardMoves = function(aGame,penguin) {\n\t\tvar moves=[];\n\t\tvar forbiddenPos=this.mWho==JocGame.PLAYER_A?63:0;\n\t\tvar dirs;\n\t\tif(penguin.d==-1) { // penguin up\n\t\t\tdirs=[0,1,2,3,4,5,6,7];\n\t\t} else {\n\t\t\tdirs=[parseInt(penguin.d)];\n\t\t}\n\t\tvar pos0=penguin.p;\n\t\tvar dist=penguin.t+1;\n\t\tvar angleSteps=penguin.t+1;\n\t\tif(pos0==-1) {\n\t\t\tpos0=this.mWho==JocGame.PLAYER_A?0:63;\n\t\t\tdirs=this.mWho==JocGame.PLAYER_A?[0,1,7]:[4,3,5];\n\t\t\tdist=penguin.t;\n\t\t\tif(this.board[pos0]!=null)\n\t\t\t\treturn moves;\n\t\t}\n\t\t\n\t\tif(penguin.p>-1 && penguin.d>-1) {\n\t\t\tmoves.push({\n\t\t\t\ti: penguin.i,\n\t\t\t\tp: penguin.p,\n\t\t\t\td: -1,\n\t\t\t\tmd: -1,\n\t\t\t})\n\t\t}\n\t\t\n\t\tif(this.ball!=-1 && this.ball==penguin.p) {\n\t\t\tdist=3-penguin.t;\n\t\n\t\t\tfor(var dir=0;dir<8;dir++) {\n\t\t\t\tvar pos=pos0, pos1=pos0;\n\t\t\t\tvar interrupted=false;\n\t\t\t\tfor(var i=0;i<dist;i++) {\n\t\t\t\t\tpos=aGame.g.Graph[pos][dir];\n\t\t\t\t\tif(pos==null) {\n\t\t\t\t\t\tif(i>0)\n\t\t\t\t\t\t\tmoves.push({\n\t\t\t\t\t\t\t\ti: penguin.i,\n\t\t\t\t\t\t\t\tp: pos1,\n\t\t\t\t\t\t\t\td: -1,\n\t\t\t\t\t\t\t\tmd: dir,\n\t\t\t\t\t\t\t});\t\t\t\n\t\t\t\t\t\tinterrupted=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos!=null && this.board[pos]!=null) {\n\t\t\t\t\t\tmoves.push({\n\t\t\t\t\t\t\ti: penguin.i,\n\t\t\t\t\t\t\tp: pos,\n\t\t\t\t\t\t\td: -1,\n\t\t\t\t\t\t\tmd: dir,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinterrupted=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpos1=pos;\n\t\t\t\t}\n\t\t\t\tif(!interrupted) {\n\t\t\t\t\tmoves.push({\n\t\t\t\t\t\ti: penguin.i,\n\t\t\t\t\t\tp: pos1,\n\t\t\t\t\t\td: -1,\n\t\t\t\t\t\tmd: dir,\n\t\t\t\t\t});\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} else {\n\t\t\tfor(var di=0;di<dirs.length;di++) {\n\t\t\t\tvar dir=dirs[di];\n\t\t\t\tvar pos=pos0, pos1=pos0;\n\t\t\t\tvar sliding=true;\n\t\t\t\tfor(var i=0;i<dist;i++) {\n\t\t\t\t\t//JocLog(\"Penguin\",penguin.t,\"dir\",dir,\"Pos\",pos,aGame.g.Graph[pos]);\n\t\t\t\t\tpos=aGame.g.Graph[pos][dir];\n\t\t\t\t\tif(pos==null || this.board[pos]!=null) {\n\t\t\t\t\t\tif(pos!=null && this.ball!=-1 && pos==this.ball) {\n\t\t\t\t\t\t\tvar penguin2=this.board[pos];\n\t\t\t\t\t\t\tif(penguin2 && penguin2.s==penguin.s) {\n\t\t\t\t\t\t\t\tsliding=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar valid=true;\n\t\t\t\t\t\t\tvar pos2=pos;\n\t\t\t\t\t\t\twhile(pos2) {\n\t\t\t\t\t\t\t\tif(pos2==forbiddenPos) {\n\t\t\t\t\t\t\t\t\tvalid=false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(this.board[pos2]==null)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tpos2=aGame.g.Graph[pos2][dir];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(valid) {\n\t\t\t\t\t\t\t\tmoves.push({\n\t\t\t\t\t\t\t\t\ti: penguin.i,\n\t\t\t\t\t\t\t\t\tp: pos,\n\t\t\t\t\t\t\t\t\td: penguin.d,\n\t\t\t\t\t\t\t\t\tmd: dir,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else \tif(i>0 && pos==null) {\n\t\t\t\t\t\t\tmoves.push({\n\t\t\t\t\t\t\t\ti: penguin.i,\n\t\t\t\t\t\t\t\tp: pos1,\n\t\t\t\t\t\t\t\td: -1,\n\t\t\t\t\t\t\t\tmd: dir,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tsliding=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.ball==-1 && (pos==27 || pos==28 || pos==35 || pos==36)) {\n\t\t\t\t\t\tmoves.push({\n\t\t\t\t\t\t\ti: penguin.i,\n\t\t\t\t\t\t\tp: pos,\n\t\t\t\t\t\t\td: -1,\n\t\t\t\t\t\t\tmd: dir,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsliding=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos!=null && this.ball!=-1 && this.ball==pos) {\n\t\t\t\t\t\tmoves.push({\n\t\t\t\t\t\t\ti: penguin.i,\n\t\t\t\t\t\t\tp: pos,\n\t\t\t\t\t\t\td: -1,\n\t\t\t\t\t\t\tmd: dir,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsliding=false;\n\t\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tpos1=pos;\n\t\t\t\t}\n\t\t\t\tif(sliding && pos1!=forbiddenPos) {\n\t\t\t\t\tmoves=moves.concat(this.PenSocGetRotatingMoves(aGame,penguin.i,pos1,dir,angleSteps));\n\t\t\t\t}\n\t\t\t\tif(penguin.p==-1 && penguin.t==0 && di==0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn moves;\n\t}\n\t\n\t/* Optional method.\n\t * If not defined, verification is made by checking move is equal to one of the moves generated by GenerateMove\n\t */\n\tModel.Board.IsValidMove = function(aGame,move) {\n\t\t// TODO: truly verify move validity to prevent hacked clients in duel\n\t\treturn true;\n\t}\n\t\n\tModel.Board.Evaluate = function(aGame,aFinishOnly,aTopLevel) {\n\t\tvar debug=arguments[3]==\"debug\";\n\t\tthis.mEvaluation=0;\n\t\tif(this.ball==0) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.PLAYER_B;\n\t\t} else if(this.ball==63) {\n\t\t\tthis.mFinished=true;\n\t\t\tthis.mWinner=JocGame.PLAYER_A;\n\t\t}\n\t\tif(this.mFinished)\n\t\t\treturn;\n\t\tvar distBall=0;\n\t\tvar ballReachable=0;\n\t\tvar reachable=0;\n\t\tfor(var i=0;i<6;i++) {\n\t\t\tvar penguin=this.penguins[i];\n\t\t\tvar db;\n\t\t\tif(penguin.p>=0) {\n\t\t\t\tif(this.ball<0)\n\t\t\t\t\tdb=Math.min(PSDist(penguin.p,27),PSDist(penguin.p,28),PSDist(penguin.p,35),PSDist(penguin.p,36));\n\t\t\t\telse\n\t\t\t\t\tdb=PSDist(penguin.p,this.ball);\n\t\t\t\tvar line=Reachable[penguin.p][penguin.d];\n\t\t\t\tfor(var pos in line) {\n\t\t\t\t\tvar reach=line[pos];\n\t\t\t\t\tif(reach<=penguin.t+1) {\n\t\t\t\t\t\treachable+=penguin.s;\n\t\t\t\t\t\tif(this.ball>=0 && pos==this.ball)\n\t\t\t\t\t\t\tballReachable+=penguin.s;\n\t\t\t\t\t\telse if(this.ball<0 && (pos==27 || pos==28 || pos==35 || pos==36))\n\t\t\t\t\t\t\tballReachable+=penguin.s;\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tdb=8;\n\t\t\tdistBall+=db*penguin.s;\n\t\t}\n\t\tvar distGoal=0;\n\t\tvar haveBall=0;\n\t\tif(this.ball>=0) {\n\t\t\tdistGoal=Dist2Goal[this.ball]-Dist2Goal[63-this.ball];\n\t\t\tvar penguin0=this.board[this.ball];\n\t\t\tif(penguin0!=null)\n\t\t\t\thaveBall=penguin0.s;\n\t\t}\n\t\tvar evParams=aGame.mOptions.levelOptions;\n\t\tif(debug) {\n\t\t\tconsole.log(\"distBall\",distBall,\"*\",evParams.distBallFactor);\n\t\t\tconsole.log(\"distGoal\",distGoal,\"*\",evParams.distGoalFactor);\n\t\t\tconsole.log(\"haveBall\",haveBall,\"*\",evParams.haveBallFactor);\n\t\t\tconsole.log(\"reachable\",reachable,\"*\",evParams.reachableFactor);\n\t\t\tconsole.log(\"ballReachable\",ballReachable,\"*\",evParams.ballReachableFactor);\n\t\t\tconsole.log(\"distBall details\",this.ball,Dist2Goal[this.ball],Dist2Goal[63-this.ball]);\n\t\t}\n\t\tthis.mEvaluation=\n\t\t\tdistBall*evParams.distBallFactor+\n\t\t\tdistGoal*evParams.distGoalFactor+\n\t\t\thaveBall*evParams.haveBallFactor+\n\t\t\treachable*evParams.reachableFactor;\n\t}\n\t\n\tModel.Board.ApplyMove = function(aGame,aMove) {\n\t\t var penguin=this.penguins[aMove.i];\n\t\t aMove.d=parseInt(aMove.d);\n\t\t \n\t\t if(this.ball!=-1 && this.ball==penguin.p) {\n\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",-1,this.ball+1);\n\t\t\t this.ball=aMove.p;\n\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",-1,this.ball+1);\n\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin.i,penguin.d+1);\n\t\t\t penguin.d=aMove.md;\n\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin.i,penguin.d+1);\n\t\t\t var penguin1=this.board[aMove.p];\n\t\t\t if(penguin1!=null) {\n\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin1.i,penguin1.d+1);\n\t\t\t\t penguin1.d=-1;\n\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin1.i,penguin1.d+1);\n\t\t\t }\n\t\t } else {\n\t\t\t if(penguin.p>-1)\n\t\t\t\t this.board[penguin.p]=null;\n\t\t\t if(aMove.p>-1) {\n\t\t\t\t var pos1=aMove.p;\n\t\t\t\t var penguin0=penguin;\n\t\t\t\t while(pos1!=null) {\n\t\t\t\t\t var penguin1=this.board[pos1];\n\t\t\t\t\t this.board[pos1]=penguin0;\n\t\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",penguin0.i,penguin0.p+1);\n\t\t\t\t\t penguin0.p=pos1;\n\t\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",penguin0.i,penguin0.p+1);\n\t\t\t\t\t if(penguin1==null)\n\t\t\t\t\t\t break;\n\t\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin1.i,penguin1.d+1);\n\t\t\t\t\t penguin1.d=aMove.md;\n\t\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin1.i,penguin1.d+1);\n\t\t\t\t\t penguin0=penguin1;\n\t\t\t\t\t pos1=aGame.g.Graph[pos1][aMove.md];\n\t\t\t\t }\n\t\t\t\t if(pos1==null) {\n\t\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",penguin0.i,penguin0.p+1);\n\t\t\t\t\t penguin0.p=-1;\n\t\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",penguin0.i,penguin0.p+1);\n\t\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin0.i,penguin0.d+1);\n\t\t\t\t\t penguin0.d=-1;\n\t\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin0.i,penguin0.d+1);\n\t\t\t\t }\n\t\t\t }\n\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",penguin.i,penguin.p+1);\n\t\t\t penguin.p=aMove.p;\n\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",penguin.i,penguin.p+1);\n\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin.i,penguin.d+1);\n\t\t\t penguin.d=aMove.d;\n\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin.i,penguin.d+1);\n\t\t\t if(this.ball==-1 && (aMove.p==27 || aMove.p==28 || aMove.p==35 || aMove.p==36)) { \n\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",-1,this.ball+1);\n\t\t\t\t this.ball=aMove.p;\n\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"board\",-1,this.ball+1);\n\t\t\t }\n\t\t\t if(this.ball!=-1 && this.ball==penguin.p) {\n\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin.i,penguin.d+1);\n\t\t\t\t penguin.d=-1;\n\t\t\t\t this.zSign=aGame.zobrist.update(this.zSign,\"dirs\",penguin.i,penguin.d+1);\n\t\t\t }\n\t\t }\n\t}\n\t\n\tModel.Board.GetSignature = function() {\n\t\treturn this.zSign;\n\t}\t\n\n})();\n"],"file":"pensoc-model.js"}