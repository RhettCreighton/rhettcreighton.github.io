{"version":3,"names":[],"mappings":"","sources":["rollerball-model.js"],"sourcesContent":["\n(function() {\n\t\n\tvar geometry = Model.Game.cbBoardGeometryGrid(7,7);\n\t\n\tvar confine = {};\n\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\tif(!(\n\t\t\t\t(pos>=16 && pos<=18) ||\n\t\t\t\t(pos>=23 && pos<=25) ||\n\t\t\t\t(pos>=30 && pos<=32) \n\t\t\t\t))\n\t\t\tconfine[pos]=1;\n\t}\n\t\n\tvar zones={\n\t\tbottom: {\n\t\t\tposs: [1,2,3,4,5,6,9,10,11,12],\n\t\t\ttrans: [[0,-1],[1,0]],\n\t\t},\n\t\tleft: {\n\t\t\tposs: [0,7,8,14,15,21,22,28,29,35],\n\t\t\ttrans: [[1,0],[0,1]],\n\t\t},\n\t\ttop: {\n\t\t\tposs: [36,37,38,39,42,43,44,45,46,47],\n\t\t\ttrans: [[0,1],[-1,0]],\n\t\t},\n\t\tright: {\n\t\t\tposs: [13,19,20,26,27,33,34,40,41,48],\n\t\t\ttrans: [[-1,0],[0,-1]],\n\t\t},\n\t}\n\t\n\tvar pos2trans={};\n\tfor(var zi in zones) {\n\t\tvar zone=zones[zi];\n\t\tfor(var pos in zone.poss)\n\t\t\tpos2trans[zone.poss[pos]]=zone.trans;\n\t} \n\n\tvar distance={};\n\n\t(function() {\n\t\tfor(var pos in confine) {\n\t\t\tdistance[pos]={};\n\t\t\tdistance[pos][pos]=0;\n\t\t}\n\t\tvar steps=[[-1,1],[0,1],[1,1]];\n\t\tvar modifs=true;\n\t\twhile(modifs) {\n\t\t\tmodifs=false;\n\t\t\tfor(var pos in confine) {\n\t\t\t\tsteps.forEach(function(deltav) {\n\t\t\t\t\tvar trans=pos2trans[pos];\n\t\t\t\t\tvar delta=[trans[0][0]*deltav[0]+trans[0][1]*deltav[1],trans[1][0]*deltav[0]+trans[1][1]*deltav[1]];\n\t\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\t\tif(pos1==null || !(pos1 in confine))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif(distance[pos][pos1]!=1) {\n\t\t\t\t\t\tdistance[pos][pos1]=1;\n\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t} \n\t\t\t\t\tfor(var pos2 in confine) {\n\t\t\t\t\t\tif(pos2==pos)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(distance[pos][pos2]===undefined && distance[pos1][pos2]!==undefined) {\n\t\t\t\t\t\t\tdistance[pos][pos2]=distance[pos1][pos2]+1;\n\t\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t\t} else if(distance[pos1][pos2]!==undefined && distance[pos][pos2]!==undefined && distance[pos][pos2]>distance[pos1][pos2]+1) {\n\t\t\t\t\t\t\tdistance[pos][pos2]=distance[pos1][pos2]+1;\n\t\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t//console.log(\"distance\",distance);\n\t\tgeometry.GetDistance=function() {\n\t\t\treturn distance;\n\t\t}\n\t})();\n\t\n\tvar promo = {\n\t\t\"1\": { 46:1, 39:1 },\n\t\t\"-1\": { 2:1, 9:1 },\n\t}\n\t\n\tvar distancePromo={\t\"1\": {}, \"-1\": {} };\n\t[\"1\",\"-1\"].forEach(function(side) {\n\t\tfor(var pos in confine) {\n\t\t\tvar minDist=Infinity;\n\t\t\tfor(var pos1 in promo[side]) {\n\t\t\t\tvar dist=distance[pos][pos1];\n\t\t\t\tif(dist<minDist) {\n\t\t\t\t\tdistancePromo[side][pos]=dist;\n\t\t\t\t\tminDist=dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t});\n\n\tModel.Game.cbRbGraph = function(geometry,deltas,maxDist,rebound,sideRebound) {\n\t\tvar $this=this;\n\t\tvar flags=this.cbConstants.FLAG_MOVE | this.cbConstants.FLAG_CAPTURE;\n\t\tmaxDist = maxDist || 12;\n\t\trebound = rebound || {};\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\tif(confine && !(pos in confine))\n\t\t\t\tcontinue;\n\t\t\tdeltas.forEach(function(delta) {\n\t\t\t\tvar direction=[];\n\t\t\t\tvar trans0=pos2trans[pos];\n\t\t\t\tvar delta0=[trans0[0][0]*delta[0]+trans0[0][1]*delta[1],trans0[1][0]*delta[0]+trans0[1][1]*delta[1]];\n\t\t\t\tvar pos1=geometry.Graph(pos,delta0);\n\t\t\t\tvar dist=0;\n\t\t\t\tvar rebounded=false;\n\t\t\t\twhile(pos1!=null) {\n\t\t\t\t\tif(dist++==maxDist)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(confine && !(pos1 in confine))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdirection.push(pos1 | flags);\n\t\t\t\t\tvar pos2=pos1;\n\t\t\t\t\tpos1=geometry.Graph(pos1,delta0);\n\t\t\t\t\tif(!rebounded && (pos2 in rebound)) {\n\t\t\t\t\t\tif(pos1==null || (confine && !(pos1 in confine))) {\n\t\t\t\t\t\t\tvar trans2=pos2trans[pos2];\n\t\t\t\t\t\t\tif(sideRebound) {\n\t\t\t\t\t\t\t\tif(trans0[0]==trans2[0] && trans0[1]==trans2[1]) // same zone, invert deltaX\n\t\t\t\t\t\t\t\t\tdelta0=[trans2[0][0]*-delta[0]+trans2[0][1]*delta[1],trans2[1][0]*-delta[0]+trans2[1][1]*delta[1]];\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tdelta0=[trans2[0][0]*delta[0]+trans2[0][1]*delta[1],trans2[1][0]*delta[0]+trans2[1][1]*delta[1]];\n\t\t\t\t\t\t\t} else \n\t\t\t\t\t\t\t\tdelta0=[trans2[0][0]*delta[0]+trans2[0][1]*delta[1],trans2[1][0]*delta[0]+trans2[1][1]*delta[1]];\n\t\t\t\t\t\t\tpos1=geometry.Graph(pos2,delta0);\n\t\t\t\t\t\t\trebounded=true;\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(direction.length>0)\n\t\t\t\t\tgraph[pos].push($this.cbTypedArray(direction));\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\n\t}\n\n\tModel.Game.cbRbRookExtraGraph = function(geometry) {\n\t\tvar graph={};\n\t\tvar extras={\n\t\t\t1: [0,1],\n\t\t\t35: [1,0],\n\t\t\t47: [0,-1],\n\t\t\t13: [-1,0],\n\t\t}\n\t\tvar flags=this.cbConstants.FLAG_MOVE | this.cbConstants.FLAG_CAPTURE;\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\tvar delta=extras[pos];\n\t\t\tvar direction=[];\n\t\t\tif(delta) {\n\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\tvar skipped=false;\n\t\t\t\twhile(pos1!=null) {\n\t\t\t\t\tif(skipped)\n\t\t\t\t\t\tdirection.push(pos1 | flags);\n\t\t\t\t\telse {\n\t\t\t\t\t\tskipped=true;\n\t\t\t\t\t\tdirection.push(pos1 | this.cbConstants.FLAG_STOP);\n\t\t\t\t\t}\n\t\t\t\t\tpos1=geometry.Graph(pos1,delta);\n\t\t\t\t}\t\t\t\t\n\t\t\t\tgraph[pos].push(this.cbTypedArray(direction));\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\t\n\tvar passLine={\n\t\t\"1\": [{2:1,9:1},{3:1,10:1}],\n\t\t\"-1\": [{39:1,46:1},{38:1,45:1}],\n\t}\n\n\tModel.Game.cbDefine = function() {\n\n\t\treturn {\n\t\t\t\n\t\t\tgeometry: geometry,\n\t\t\t\n\t\t\tpieceTypes: {\n\n\t\t\t\t0: {\n\t\t\t\t\tname: 'pawn',\n\t\t\t\t\taspect: 'pawn',\n\t\t\t\t\tgraph: this.cbRbGraph(geometry,[[-1,1],[0,1],[1,1]],1),\n\t\t\t\t\tvalue: 1,\n\t\t\t\t\tabbrev: '',\n\t\t\t\t\tfenAbbrev: 'P',\n\t\t\t\t\tinitial: [{s:1,p:2},{s:1,p:9},{s:-1,p:39},{s:-1,p:46}],\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t5: {\n\t\t\t\t\tname: 'bishop',\n\t\t\t\t\tgraph: this.cbMergeGraphs(geometry,\n\t\t\t\t\t\t\tthis.cbRbGraph(geometry,[[-1,1],[1,1]],6,confine,true),\n\t\t\t\t\t\t\tthis.cbRbGraph(geometry,[[-1,-1],[1,-1]],1)),\n\t\t\t\t\tvalue: 2.4,\n\t\t\t\t\tabbrev: 'B',\n\t\t\t\t\tinitial: [{s:1,p:3},{s:-1,p:45}],\n\t\t\t\t},\n\n\t\t\t\t6: {\n\t\t\t\t\tname: 'rook',\n\t\t\t\t\tgraph: this.cbMergeGraphs(geometry,\n\t\t\t\t\t\t\tthis.cbRbGraph(geometry,[[0,1]],12,{0:1,6:1,42:1,48:1}),\n\t\t\t\t\t\t\tthis.cbRbGraph(geometry,[[1,0],[-1,0],[0,-1]],1),\n\t\t\t\t\t\t\tthis.cbRbRookExtraGraph(geometry)),\n\t\t\t\t\tvalue: 3.1,\n\t\t\t\t\tabbrev: 'R',\n\t\t\t\t\tinitial: [{s:1,p:4},{s:1,p:11},{s:-1,p:37},{s:-1,p:44}],\n\t\t\t\t\tcastle: true,\n\t\t\t\t},\n\n\t\t\t\t8: {\n\t\t\t\t\tname: 'king',\n\t\t\t\t\tisKing: true,\n\t\t\t\t\tgraph: this.cbKingGraph(geometry,confine),\n\t\t\t\t\tabbrev: 'K',\n\t\t\t\t\tinitial: [{s:1,p:10},{s:-1,p:38}],\n\t\t\t\t},\n\n\t\t\t\t9: {\n\t\t\t\t\tname: 'king-out',\n\t\t\t\t\taspect: 'king',\n\t\t\t\t\tisKing: true,\n\t\t\t\t\tgraph: this.cbKingGraph(geometry,confine),\n\t\t\t\t\tabbrev: 'K',\n\t\t\t\t},\n\t\t\t\t\n\t\t\t},\n\n\t\t\tpromote: function(aGame,piece,move) {\n\t\t\t\tif(piece.t==8) {\n\t\t\t\t\tvar pLine=passLine[piece.s];\n\t\t\t\t\tif((move.f in pLine[1]) && (move.t in pLine[0]))\n\t\t\t\t\t\treturn [9];\n\t\t\t\t} else if(piece.t==9) {\n\t\t\t\t\tvar pLine=passLine[piece.s];\n\t\t\t\t\tif((move.f in pLine[0]) && (move.t in pLine[1]))\n\t\t\t\t\t\treturn [8];\n\t\t\t\t} \n\t\t\t\tif(piece.t==0 && promo[piece.s][move.t])\n\t\t\t\t\treturn [5,6];\n\t\t\t\treturn [];\n\t\t\t},\n\n\t\t\tevaluate: function(aGame,evalValues,material) {\n\n\t\t\t\t// handle additional win condition\n\t\t\t\tif(this.kings[1]==38 && this.pieces[this.board[38]].t==9) {\n\t\t\t\t\tthis.mFinished=true;\n\t\t\t\t\tthis.mWinner=JocGame.PLAYER_A;\n\t\t\t\t}\n\t\t\t\tif(this.kings[-1]==10 && this.pieces[this.board[10]].t==9) {\n\t\t\t\t\tthis.mFinished=true;\n\t\t\t\t\tthis.mWinner=JocGame.PLAYER_B;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// check lack of material to checkmate\n\t\t\t\tvar white=material[1].count;\n\t\t\t\tvar black=material[-1].count;\n\t\t\t\tif(!white[0] && !white[5] && !white[6]) { // white king single\n\t\t\t\t\tif(!black[0] && !black[6]) {\n\t\t\t\t\t\tthis.mFinished=true;\n\t\t\t\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!black[0] && !black[5] && !black[6]) { // black king single\n\t\t\t\t\tif(!white[0] && !white[6]) {\n\t\t\t\t\t\tthis.mFinished=true;\n\t\t\t\t\t\tthis.mWinner=JocGame.DRAW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// check 50 moves without capture\n\t\t\t\tif(this.noCaptCount>=100) {\n\t\t\t\t\tthis.mFinished=true;\n\t\t\t\t\tthis.mWinner=JocGame.DRAW;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// motivate pawns to reach the promotion line\n\t\t\t\tvar distPromo=0;\n\t\t\t\tfor(var side=-1;side<=1;side+=2) {\n\t\t\t\t\tvar pawns=material[side].byType[0],pawnsLength;\n\t\t\t\t\tif(pawns) {\n\t\t\t\t\t\tpawnsLength=pawns.length;\n\t\t\t\t\t\tfor(var i=0;i<pawnsLength;i++)\n\t\t\t\t\t\t\tdistPromo+=distancePromo[side][pawns[i].p]*side;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tevalValues['distPawnPromo']=distPromo;\n\n\t\t\t\t// motivate king to reach opponent throne\n\t\t\t\tevalValues['distKingThrone']=distance[this.kings[1]][38]-distance[this.kings[-1]][10];\n\t\t\t\t\n\t\t\t},\n\t\t\t\n\t\t};\n\t}\n\t\n})();"],"file":"rollerball-chess-model.js"}