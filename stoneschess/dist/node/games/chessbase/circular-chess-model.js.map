{"version":3,"names":[],"mappings":"","sources":["cylinder-geo-model.js"],"sourcesContent":["\n(function() {\n\t\n\tModel.Game.cbBoardGeometryCylinder = function(width,height) {\n\n\t\tvar boardSize = width*height;\n\t\t\n\t\tfunction C(pos) {\n\t\t\treturn pos%width;\n\t\t}\n\t\tfunction R(pos) {\n\t\t\treturn Math.floor(pos/width);\n\t\t}\n\t\tfunction POS(c,r) {\n\t\t\treturn r*width+c;\n\t\t}\n\t\tfunction Graph(pos,delta) {\n\t\t\tvar c0=C(pos);\n\t\t\tvar r0=R(pos);\n\t\t\tvar c=c0+delta[0]\n\t\t\twhile(c<0)\n\t\t\t\tc+=width;\n\t\t\tc%=width;\n\t\t\tvar r=r0+delta[1];\n\t\t\tif(r<0 || r>=height)\n\t\t\t\treturn null;\n\t\t\treturn POS(c,r);\n\t\t}\n\t\t\n\t\tvar distance={};\n\t\tfor(var pos=0;pos<boardSize;pos++) {\n\t\t\tdistance[pos]={};\n\t\t\tdistance[pos][pos]=0;\n\t\t}\n\t\tvar steps=[[1,-1],[1,0],[1,1],[0,-1],[0,1],[-1,-1],[-1,0],[-1,-1]];\n\t\tvar modifs=true;\n\t\twhile(modifs) {\n\t\t\tmodifs=false;\n\t\t\tfor(var pos=0;pos<boardSize;pos++) {\n\t\t\t\tsteps.forEach(function(delta) {\n\t\t\t\t\tvar pos1=Graph(pos,delta);\n\t\t\t\t\tif(pos1==null)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif(distance[pos][pos1]!=1) {\n\t\t\t\t\t\tdistance[pos][pos1]=1;\n\t\t\t\t\t\tdistance[pos1][pos]=1;\n\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t} \n\t\t\t\t\tfor(var pos2=0;pos2<boardSize;pos2++) {\n\t\t\t\t\t\tif(pos2==pos)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(distance[pos1][pos2]===undefined && distance[pos][pos2]!==undefined) {\n\t\t\t\t\t\t\tdistance[pos1][pos2]=distance[pos][pos2]+1;\n\t\t\t\t\t\t\tdistance[pos2][pos1]=distance[pos][pos2]+1;\n\t\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t\t} else if(distance[pos1][pos2]!==undefined && distance[pos][pos2]!==undefined && distance[pos1][pos2]>distance[pos][pos2]+1) {\n\t\t\t\t\t\t\tdistance[pos1][pos2]=distance[pos][pos2]+1;\n\t\t\t\t\t\t\tdistance[pos2][pos1]=distance[pos][pos2]+1;\n\t\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar distEdges={};\n\t\tvar modifs=true;\n\t\twhile(modifs) {\n\t\t\tmodifs=false;\n\t\t\tfor(var pos=0;pos<boardSize;pos++) {\n\t\t\t\tif(pos in distEdges)\n\t\t\t\t\tcontinue;\n\t\t\t\tsteps.forEach(function(delta) {\n\t\t\t\t\tvar pos1=Graph(pos,delta);\n\t\t\t\t\tif(pos1==null)\n\t\t\t\t\t\tdistEdges[pos]=1;\n\t\t\t\t\telse if(pos1 in distEdges) {\n\t\t\t\t\t\tif(!(pos in distEdges) || distEdges[pos]>distEdges[pos1]+1) {\n\t\t\t\t\t\t\tdistEdges[pos]=distEdges[pos1]+1;\n\t\t\t\t\t\t\tmodifs=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction PosName(pos) {\n\t\t\t return String.fromCharCode((\"a\".charCodeAt(0))+C(pos)) + (R(pos)+1);\n\t\t}\n\t\tfunction PosByName(str) {\n\t\t\tvar m=/^([a-z])([0-9]+)$/.exec(str);\n\t\t\tif(!m)\n\t\t\t\treturn -1;\n\t\t\tvar c=m[1].charCodeAt(0)-\"a\".charCodeAt(0);\n\t\t\tvar r=parseInt(m[2])-1;\n\t\t\treturn POS(c,r);\n\t\t}\n\t\tfunction CompactCrit(pos,index) {\n\t\t\tif(index==0)\n\t\t\t\treturn String.fromCharCode((\"a\".charCodeAt(0))+C(pos));\n\t\t\telse if(index==1)\n\t\t\t\treturn (R(pos)+1);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t\tfunction GetDistances() {\n\t\t\treturn distance;\n\t\t}\n\t\t\n\t\treturn {\n\t\t\tboardSize: boardSize,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tC: C,\n\t\t\tR: R,\n\t\t\tPOS: POS,\n\t\t\tGraph: Graph, \n\t\t\tPosName: PosName,\n\t\t\tPosByName: PosByName,\n\t\t\tCompactCrit: CompactCrit,\n\t\t\tGetDistances: GetDistances,\n\t\t\tdistEdge: distEdges,\n\t\t\tcorners: null,\n\t\t};\n\t}\n\n\t/*\n \tPiece graph: [ directions ]\n \tDirection: [ Targets ]\n \tTarget: <position> | <flags bitmask>\n \t<position>: 0xffff (invalid) or next position\n\t*/\n\t\n\tModel.Game.cbPawnGraph = function(geometry,side) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tvar directions=[];\n\t\t\tvar pos1=geometry.Graph(pos,[0,side]);\n\t\t\tif(pos1!=null)\n\t\t\t\tdirections.push($this.cbTypedArray([pos1 | $this.cbConstants.FLAG_MOVE]));\n\t\t\t[-1,1].forEach(function(dc) {\n\t\t\t\tvar pos2=geometry.Graph(pos,[dc,side]);\n\t\t\t\tif(pos2!=null)\n\t\t\t\t\tdirections.push($this.cbTypedArray([pos2 | $this.cbConstants.FLAG_CAPTURE]));\t\t\t\t\n\t\t\t});\n\t\t\tgraph[pos]=directions;\n\t\t}\n\t\treturn graph;\n\t}\n\t\t\n\tModel.Game.cbInitialPawnGraph = function(geometry,side) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tvar directions=[];\n\t\t\tvar pos1=geometry.Graph(pos,[0,side]);\n\t\t\tif(pos1!=null) {\n\t\t\t\tvar direction=[pos1 | $this.cbConstants.FLAG_MOVE];\n\t\t\t\tvar pos2=geometry.Graph(pos1,[0,side]);\n\t\t\t\tif(pos2!=null)\n\t\t\t\t\tdirection.push(pos2 | $this.cbConstants.FLAG_MOVE);\n\t\t\t\tdirections.push($this.cbTypedArray(direction));\n\t\t\t}\n\t\t\t[-1,1].forEach(function(dc) {\n\t\t\t\tvar pos2=geometry.Graph(pos,[dc,side]);\n\t\t\t\tif(pos2!=null)\n\t\t\t\t\tdirections.push($this.cbTypedArray([pos2 | $this.cbConstants.FLAG_CAPTURE]));\t\t\t\t\n\t\t\t});\n\t\t\tgraph[pos]=directions;\n\t\t}\n\t\treturn graph;\n\t}\n\n\tModel.Game.cbKingGraph = function(geometry) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]);\n\t}\n\n\tModel.Game.cbKnightGraph = function(geometry) {\n\t\treturn this.cbShortRangeGraph(geometry,[[2,-1],[2,1],[-2,-1],[-2,1],[-1,2],[-1,-2],[1,2],[1,-2]]);\n\t}\n\n\tModel.Game.cbHorseGraph = function(geometry) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\t[[1,0,2,-1],[1,0,2,1],[-1,0,-2,-1],[-1,0,-2,1],[0,1,-1,2],[0,-1,-1,-2],[0,1,1,2],[0,-1,1,-2]].forEach(function(desc) {\n\t\t\t\tvar pos1=geometry.Graph(pos,[desc[0],desc[1]]);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tvar pos2=geometry.Graph(pos,[desc[2],desc[3]]);\n\t\t\t\t\tif(pos2!=null)\n\t\t\t\t\t\tgraph[pos].push($this.cbTypedArray([pos1 | $this.cbConstants.FLAG_STOP, pos2 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE]));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\t}\n\n\t\n\tModel.Game.cbRookGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,[[0,-1],[0,1],[-1,0],[1,0]]);\n\t}\n\t\n\tModel.Game.cbBishopGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,[[1,-1],[1,1],[-1,1],[-1,-1]]);\n\t}\n\t\n\tModel.Game.cbQueenGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,[[0,-1],[0,1],[-1,0],[1,0],[1,-1],[1,1],[-1,1],[-1,-1]]);\n\t}\n\n\tModel.Game.cbXQGeneralGraph = function(geometry,confine) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\t[[-1,0,false],[0,-1,true],[0,1,true],[1,0,false]].forEach(function(delta) {\n\t\t\t\tvar direction=[];\n\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tif(!confine || (pos1 in confine))\n\t\t\t\t\tdirection.push(pos1 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE);\n\t\t\t\t\tif(delta[2]) {\n\t\t\t\t\t\tvar pos2=geometry.Graph(pos1,delta);\n\t\t\t\t\t\twhile(pos2!=null) {\n\t\t\t\t\t\t\tif(!confine || (pos2 in confine))\n\t\t\t\t\t\t\t\tdirection.push(pos2 | $this.cbConstants.FLAG_CAPTURE | $this.cbConstants.FLAG_CAPTURE_KING);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdirection.push(pos2 | $this.cbConstants.FLAG_STOP);\n\t\t\t\t\t\t\tpos2=geometry.Graph(pos2,delta);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(direction.length>0)\n\t\t\t\t\tgraph[pos].push($this.cbTypedArray(direction));\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\t}\n\t\n\tModel.Game.cbXQSoldierGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[0,side]]);\n\t}\n\n\tModel.Game.cbXQPromoSoldierGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[0,side],[-1,0],[1,0]]);\n\t}\n\n\tModel.Game.cbXQAdvisorGraph = function(geometry,confine) {\n\t\treturn this.cbShortRangeGraph(geometry,[[1,1],[-1,1],[1,-1],[-1,-1]],confine);\n\t}\n\n\tModel.Game.cbXQCannonGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,[[0,-1],[0,1],[-1,0],[1,0]],null,this.cbConstants.FLAG_MOVE | this.cbConstants.FLAG_SCREEN_CAPTURE);\n\t}\n\t\n\tModel.Game.cbXQElephantGraph = function(geometry,confine) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\tif(confine && !(pos in confine))\n\t\t\t\tcontinue;\n\t\t\t[[1,1,2,2],[1,-1,2,-2],[-1,1,-2,2],[-1,-1,-2,-2]].forEach(function(desc) {\n\t\t\t\tvar pos1=geometry.Graph(pos,[desc[0],desc[1]]);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tvar pos2=geometry.Graph(pos,[desc[2],desc[3]]);\n\t\t\t\t\tif(pos2!=null && (!confine || (pos2 in confine)))\n\t\t\t\t\t\tgraph[pos].push($this.cbTypedArray([pos1 | $this.cbConstants.FLAG_STOP, pos2 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE]));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\t}\n\t\n\tModel.Game.cbSilverGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[0,side],[-1,-1],[-1,1],[1,-1],[1,1]]);\n\t}\n\t\n\tModel.Game.cbFersGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1]]);\n\t}\t\n\n\tModel.Game.cbElephantGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-2,-2],[-2,2],[2,-2],[2,2]]);\n\t}\t\n\n\tModel.Game.cbSchleichGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-1,0],[1,0],[0,-1],[0,1]]);\n\t}\t\n\t\n\tModel.Game.cbAlfilGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-2,-2],[-2,2],[2,2],[2,-2]]);\n\t}\t\n\n\tModel.Game.cbCylinderRookGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,[[0,-1],[0,1],[-1,0],[1,0]],null,null,Math.max(geometry.width,geometry.height)-1);\n\t}\n\n\tModel.Game.cbCircularPawnGraph = function(geometry,cc,range) {\n\t\tvar moveGraph = this.cbLongRangeGraph(geometry,cc?[[1,0]]:[[-1,0]],null,this.cbConstants.FLAG_MOVE,range);\n\t\tvar captGraph = this.cbShortRangeGraph(geometry,cc?[[1,1],[1,-1]]:[[-1,1],[-1,-1]],null,this.cbConstants.FLAG_CAPTURE);\n\t\treturn this.cbMergeGraphs(geometry,moveGraph,captGraph);\n\t}\n\t\n})();\n"],"file":"circular-chess-model.js"}