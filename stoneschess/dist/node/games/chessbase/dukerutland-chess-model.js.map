{"version":3,"names":[],"mappings":"","sources":["grid-geo-model.js"],"sourcesContent":["\n(function() {\n\t\n\tModel.Game.cbBoardGeometryGrid = function(width,height) {\n\t\tfunction C(pos) {\n\t\t\treturn pos%width;\n\t\t}\n\t\tfunction R(pos) {\n\t\t\treturn Math.floor(pos/width);\n\t\t}\n\t\tfunction POS(c,r) {\n\t\t\treturn r*width+c;\n\t\t}\n\t\tfunction Graph(pos,delta) {\n\t\t\tvar c0=C(pos);\n\t\t\tvar r0=R(pos);\n\t\t\tvar c=c0+delta[0];\n\t\t\tvar r=r0+delta[1];\n\t\t\tif(c<0 || c>=width || r<0 || r>=height)\n\t\t\t\treturn null;\n\t\t\treturn POS(c,r);\n\t\t}\n\t\tfunction PosName(pos) {\n\t\t\t return String.fromCharCode((\"a\".charCodeAt(0))+C(pos)) + (R(pos)+1);\n\t\t}\n\t\tfunction PosByName(str) {\n\t\t\tvar m=/^([a-z])([0-9]+)$/.exec(str);\n\t\t\tif(!m)\n\t\t\t\treturn -1;\n\t\t\tvar c=m[1].charCodeAt(0)-\"a\".charCodeAt(0);\n\t\t\tvar r=parseInt(m[2])-1;\n\t\t\treturn POS(c,r);\n\t\t}\n\t\tfunction CompactCrit(pos,index) {\n\t\t\tif(index==0)\n\t\t\t\treturn String.fromCharCode((\"a\".charCodeAt(0))+C(pos));\n\t\t\telse if(index==1)\n\t\t\t\treturn (R(pos)+1);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t\tfunction GetDistances() {\n\t\t\tvar dist=[];\n\t\t\tfor(var pos1=0;pos1<width*height;pos1++) {\n\t\t\t\tvar dist1=[];\n\t\t\t\tdist.push(dist1);\n\t\t\t\tfor(var pos2=0;pos2<width*height;pos2++) {\n\t\t\t\t\tvar r1=R(pos1), c1=C(pos1), r2=R(pos2), c2=C(pos2);\n\t\t\t\t\tdist1.push(Math.max(Math.abs(r1-r2),Math.abs(c1-c2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dist;\n\t\t}\n\t\tfunction DistEdges() {\n\t\t\tvar dist=[];\n\t\t\tfor(var pos=0;pos<width*height;pos++) {\n\t\t\t\tvar c=C(pos);\n\t\t\t\tvar r=R(pos);\n\t\t\t\tdist[pos]=Math.min(\n\t\t\t\t\tc, Math.abs(width-c-1),\n\t\t\t\t\tr, Math.abs(height-r-1)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn dist;\n\t\t}\n\t\tfunction Corners() {\n\t\t\tvar corners={};\n\t\t\tcorners[POS(0,0)]=1;\n\t\t\tcorners[POS(0,height-1)]=1;\n\t\t\tcorners[POS(width-1,0)]=1;\n\t\t\tcorners[POS(width-1,height-1)]=1;\n\t\t\treturn corners;\n\t\t}\n\n\t\tfunction ExportBoardState(board,cbVar,moveCount) {\n\t\t\tvar fenRows = [];\n\t\t\tfor(var r=height-1;r>=0;r--) {\n\t\t\t\tvar fenRow = \"\";\n\t\t\t\tvar emptyCount = 0;\n\t\t\t\tfor(var c=0;c<width;c++) {\n\t\t\t\t\tvar pieceIndex = board.board[POS(c,r)];\n\t\t\t\t\tif(pieceIndex<0)\n\t\t\t\t\t\temptyCount++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(emptyCount>0) {\n\t\t\t\t\t\t\tfenRow += emptyCount;\n\t\t\t\t\t\t\temptyCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar piece = board.pieces[pieceIndex];\n\t\t\t\t\t\tvar abbrev = cbVar.pieceTypes[piece.t].fenAbbrev || cbVar.pieceTypes[piece.t].abbrev || \"?\";\n\t\t\t\t\t\tif(piece.s==-1)\n\t\t\t\t\t\t\tfenRow += abbrev.toLowerCase();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfenRow += abbrev.toUpperCase();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(emptyCount)\n\t\t\t\t\tfenRow += emptyCount;\n\t\t\t\tfenRows.push(fenRow);\n\t\t\t}\n\t\t\tvar fen = fenRows.join(\"/\");\n\t\t\tfen += \" \";\n\t\t\tif(board.mWho==1)\n\t\t\t\tfen += \"w\";\n\t\t\telse\n\t\t\t\tfen += \"b\";\n\t\t\tfen += \" \";\n\t\t\tvar castle = \"\";\n\t\t\tif(board.castled) {\n\t\t\t\tif(board.castled[1]===false)\n\t\t\t\t\tcastle += \"KQ\";\n\t\t\t\telse {\n\t\t\t\t\tif(board.castled[1].k)\n\t\t\t\t\t\tcastle+= \"K\";\n\t\t\t\t\tif(board.castled[1].q)\n\t\t\t\t\t\tcastle+= \"Q\";\n\t\t\t\t}\n\t\t\t\tif(board.castled[-1]===false)\n\t\t\t\t\tcastle += \"kq\";\n\t\t\t\telse {\n\t\t\t\t\tif(board.castled[-1].k)\n\t\t\t\t\t\tcastle+= \"k\";\n\t\t\t\t\tif(board.castled[-1].q)\n\t\t\t\t\t\tcastle+= \"q\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(castle.length==0)\n\t\t\t\tcastle = \"-\";\n\t\t\tfen += castle;\n\t\t\tfen += \" \";\n\t\t\tif(!board.epTarget)\n\t\t\t\tfen += \"-\";\n\t\t\telse\n\t\t\t\tfen += PosName(board.epTarget.p);\n\t\t\tfen += \" \";\n\t\t\tfen += board.noCaptCount;\n\t\t\tfen += \" \";\n\t\t\tfen += Math.floor(moveCount/2)+1;\n\t\t\treturn fen;\n\t\t}\n\t\t\n\t\treturn {\n\t\t\tboardSize: width*height,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tC: C,\n\t\t\tR: R,\n\t\t\tPOS: POS,\n\t\t\tGraph: Graph, \n\t\t\tPosName: PosName,\n\t\t\tPosByName: PosByName,\n\t\t\tCompactCrit: CompactCrit,\n\t\t\tGetDistances: GetDistances,\n\t\t\tdistEdge: DistEdges(),\n\t\t\tcorners: Corners(),\n\t\t\tExportBoardState: ExportBoardState\n\t\t};\n\t}\n\n\t/*\n \tPiece graph: [ directions ]\n \tDirection: [ Targets ]\n \tTarget: <position> | <flags bitmask>\n \t<position>: 0xffff (invalid) or next position\n\t*/\n\t\n\tModel.Game.cbPawnGraph = function(geometry,side,confine) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tif(confine && !(pos in confine)){\n\t\t\t\tgraph[pos]=[];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar directions=[];\n\t\t\tvar pos1=geometry.Graph(pos,[0,side]);\n\t\t\tif(pos1!=null && (!confine || (pos1 in confine)))\n\t\t\t\tdirections.push($this.cbTypedArray([pos1 | $this.cbConstants.FLAG_MOVE]));\n\t\t\t[-1,1].forEach(function(dc) {\n\t\t\t\tvar pos2=geometry.Graph(pos,[dc,side]);\n\t\t\t\tif(pos2!=null && (!confine || (pos2 in confine)))\n\t\t\t\t\tdirections.push($this.cbTypedArray([pos2 | $this.cbConstants.FLAG_CAPTURE]));\t\t\t\t\n\t\t\t});\n\t\t\tgraph[pos]=directions;\n\t\t}\n\t\treturn graph;\n\t}\n\t\t\n\tModel.Game.cbInitialPawnGraph = function(geometry,side,confine) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tif(confine && !(pos in confine)){\n\t\t\t\tgraph[pos]=[];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar directions=[];\n\t\t\tvar pos1=geometry.Graph(pos,[0,side]);\n\t\t\tif(pos1!=null && (!confine || (pos1 in confine))) {\n\t\t\t\tvar direction=[pos1 | $this.cbConstants.FLAG_MOVE];\n\t\t\t\tvar pos2=geometry.Graph(pos1,[0,side]);\n\t\t\t\tif(pos2!=null && (!confine || (pos2 in confine)))\n\t\t\t\t\tdirection.push(pos2 | $this.cbConstants.FLAG_MOVE);\n\t\t\t\tdirections.push($this.cbTypedArray(direction));\n\t\t\t}\n\t\t\t[-1,1].forEach(function(dc) {\n\t\t\t\tvar pos2=geometry.Graph(pos,[dc,side]);\n\t\t\t\tif(pos2!=null && (!confine || (pos2 in confine)))\n\t\t\t\t\tdirections.push($this.cbTypedArray([pos2 | $this.cbConstants.FLAG_CAPTURE]));\t\t\t\t\n\t\t\t});\n\t\t\tgraph[pos]=directions;\n\t\t}\n\t\treturn graph;\n\t}\n\n\tModel.Game.cbKingGraph = function(geometry,confine) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]],confine);\n\t}\n\n\tModel.Game.cbKnightGraph = function(geometry,confine) {\n\t\treturn this.cbShortRangeGraph(geometry,[[2,-1],[2,1],[-2,-1],[-2,1],[-1,2],[-1,-2],[1,2],[1,-2]],confine);\n\t}\n\n\tModel.Game.cbHorseGraph = function(geometry) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\t[[1,0,2,-1],[1,0,2,1],[-1,0,-2,-1],[-1,0,-2,1],[0,1,-1,2],[0,-1,-1,-2],[0,1,1,2],[0,-1,1,-2]].forEach(function(desc) {\n\t\t\t\tvar pos1=geometry.Graph(pos,[desc[0],desc[1]]);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tvar pos2=geometry.Graph(pos,[desc[2],desc[3]]);\n\t\t\t\t\tif(pos2!=null)\n\t\t\t\t\t\tgraph[pos].push($this.cbTypedArray([pos1 | $this.cbConstants.FLAG_STOP, pos2 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE]));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\t}\n\n\t\n\tModel.Game.cbRookGraph = function(geometry,confine) {\n\t\treturn this.cbLongRangeGraph(geometry,[[0,-1],[0,1],[-1,0],[1,0]],confine);\n\t}\n\t\n\tModel.Game.cbBishopGraph = function(geometry,confine) {\n\t\treturn this.cbLongRangeGraph(geometry,[[1,-1],[1,1],[-1,1],[-1,-1]],confine);\n\t}\n\t\n\tModel.Game.cbQueenGraph = function(geometry,confine) {\n\t\treturn this.cbLongRangeGraph(geometry,[[0,-1],[0,1],[-1,0],[1,0],[1,-1],[1,1],[-1,1],[-1,-1]],confine);\n\t}\n\n\tModel.Game.cbXQGeneralGraph = function(geometry,confine) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\t[[-1,0,false],[0,-1,true],[0,1,true],[1,0,false]].forEach(function(delta) {\n\t\t\t\tvar direction=[];\n\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tif(!confine || (pos1 in confine))\n\t\t\t\t\tdirection.push(pos1 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE);\n\t\t\t\t\tif(delta[2]) {\n\t\t\t\t\t\tvar pos2=geometry.Graph(pos1,delta);\n\t\t\t\t\t\twhile(pos2!=null) {\n\t\t\t\t\t\t\tif(!confine || (pos2 in confine))\n\t\t\t\t\t\t\t\tdirection.push(pos2 | $this.cbConstants.FLAG_CAPTURE | $this.cbConstants.FLAG_CAPTURE_KING);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdirection.push(pos2 | $this.cbConstants.FLAG_STOP);\n\t\t\t\t\t\t\tpos2=geometry.Graph(pos2,delta);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(direction.length>0)\n\t\t\t\t\tgraph[pos].push($this.cbTypedArray(direction));\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\t}\n\t\n\tModel.Game.cbXQSoldierGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[0,side]]);\n\t}\n\n\tModel.Game.cbXQPromoSoldierGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[0,side],[-1,0],[1,0]]);\n\t}\n\n\tModel.Game.cbXQAdvisorGraph = function(geometry,confine) {\n\t\treturn this.cbShortRangeGraph(geometry,[[1,1],[-1,1],[1,-1],[-1,-1]],confine);\n\t}\n\n\tModel.Game.cbXQCannonGraph = function(geometry) {\n\t\treturn this.cbLongRangeGraph(geometry,[[0,-1],[0,1],[-1,0],[1,0]],null,this.cbConstants.FLAG_MOVE | this.cbConstants.FLAG_SCREEN_CAPTURE);\n\t}\n\t\n\tModel.Game.cbXQElephantGraph = function(geometry,confine) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\tif(confine && !(pos in confine))\n\t\t\t\tcontinue;\n\t\t\t[[1,1,2,2],[1,-1,2,-2],[-1,1,-2,2],[-1,-1,-2,-2]].forEach(function(desc) {\n\t\t\t\tvar pos1=geometry.Graph(pos,[desc[0],desc[1]]);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tvar pos2=geometry.Graph(pos,[desc[2],desc[3]]);\n\t\t\t\t\tif(pos2!=null && (!confine || (pos2 in confine)))\n\t\t\t\t\t\tgraph[pos].push($this.cbTypedArray([pos1 | $this.cbConstants.FLAG_STOP, pos2 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE]));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn graph;\n\t}\n\t\n\tModel.Game.cbSilverGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[0,side],[-1,-1],[-1,1],[1,-1],[1,1]]);\n\t}\n\t\n\tModel.Game.cbFersGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1]]);\n\t}\t\n\n\tModel.Game.cbSchleichGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-1,0],[1,0],[0,-1],[0,1]]);\n\t}\t\n\t\n\tModel.Game.cbAlfilGraph = function(geometry,side) {\n\t\treturn this.cbShortRangeGraph(geometry,[[-2,-2],[-2,2],[2,2],[2,-2]]);\n\t}\t\n\n})();\n"],"file":"dukerutland-chess-model.js"}