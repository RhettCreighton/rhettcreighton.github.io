{"version":3,"names":[],"mappings":"","sources":["terachess-model.js"],"sourcesContent":["/*\n * Copyright(c) 2013-2014 - jocly.com\n *\n * You are allowed to use and modify this source code as long as it is exclusively for use in the Jocly API.\n *\n * Original authors: Jocly team\n *\n */\n(function() {\n\n\tvar firstRow=0;\n\tvar lastRow=15;\n\tvar firstCol=0;\n\tvar lastCol=15;\n\n\tvar geometry = Model.Game.cbBoardGeometryGrid(16,16);\n\n\t// graphs\n\tModel.Game.cbCorporalGraph = function(geometry,side,confine) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tif(confine && !(pos in confine)){\n\t\t\t\tgraph[pos]=[];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar directions=[];\n\t\t\tvar pos1=geometry.Graph(pos,[0,side]);\n\t\t\tif(pos1!=null && (!confine || (pos1 in confine))) {\n\t\t\t\tvar direction=[pos1 | $this.cbConstants.FLAG_MOVE];\n\t\t\t\tvar pos2=geometry.Graph(pos1,[0,side]);\n\t\t\t\tif(pos2!=null && (!confine || (pos2 in confine)))\n\t\t\t\t\tdirection.push(pos2 | $this.cbConstants.FLAG_MOVE);\n\t\t\t\tdirections.push($this.cbTypedArray(direction));\n\t\t\t}\n\t\t\t[-1,1].forEach(function(dc) {\n\t\t\t\tvar pos2=geometry.Graph(pos,[dc,side]);\n\t\t\t\tif(pos2!=null && (!confine || (pos2 in confine)))\n\t\t\t\t\tdirections.push($this.cbTypedArray([pos2 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE]));\n\t\t\t});\n\t\t\tgraph[pos]=directions;\n\t\t}\n\t\treturn graph;\n\t}\n\n\tModel.Game.cbPrinceGraph = function(geometry,side,confine) {\n\t\tvar $this=this;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tif(confine && !(pos in confine)){\n\t\t\t\tgraph[pos]=[];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgraph[pos]=[];\n\t\t\tvar forward=[]; // hold the pos line in front of the piece\n\t\t\tvar pos1=geometry.Graph(pos,[0,side]);\n\t\t\tif(pos1!=null && (!confine || (pos1 in confine))) {\n\t\t\t\tforward.push(pos1 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE); // capture and move allowed at first forward position\n\t\t\t\tpos1=geometry.Graph(pos1,[0,side]);\n\t\t\t\tif(pos1!=null && (!confine || (pos1 in confine)))\n\t\t\t\t\tforward.push(pos1 | $this.cbConstants.FLAG_MOVE); // move to second forward only, no capture\n\t\t\t\tgraph[pos].push($this.cbTypedArray(forward));\n\t\t\t}\n\t\t}\n\t\treturn $this.cbMergeGraphs(geometry,\n\t\t\t$this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[-1,0],[1,0],[1,-1],[1,1],[0,-side]]), // direction other than forward\n\t\t\tgraph // forward direction\n\t\t);\n\t}\n\n\tModel.Game.cbEagleGraph = function(geometry){\n\t\tvar $this=this;\n\n\t\tvar flags = $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\t[[-1,-1],[-1,1],[1,-1],[1,1]].forEach(function(delta) { // loop on all 4 diagonals\n\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tfor(var dir=0;dir<2;dir++) { // dir=0 for row, dir=1 for column\n\t\t\t\t\t\tvar nbMax = (dir==0) ? lastRow : lastCol;\n\t\t\t\t\t\tvar away=[] // hold the sliding line\n\t\t\t\t\t\tfor(var n=1;n<nbMax;n++) {\n\t\t\t\t\t\t\tvar delta2=[];\n\t\t\t\t\t\t\tdelta2[dir]=delta[dir]*n;\n\t\t\t\t\t\t\tdelta2[1-dir]=0; // delta2 is now only about moving orthogonally, away from the piece\n\t\t\t\t\t\t\tvar pos2=geometry.Graph(pos1,delta2);\n\t\t\t\t\t\t\tif(pos2!=null) {\n\t\t\t\t\t\t\t\tif(n==1) // possible to slide at least 1 cell, make sure the diagonal cell is not occupied, but cannot move to this cell\n\t\t\t\t\t\t\t\t\taway.push(pos1 | $this.cbConstants.FLAG_STOP);\n\t\t\t\t\t\t\t\taway.push(pos2 | flags);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(away.length>0)\n\t\t\t\t\t\t\tgraph[pos].push($this.cbTypedArray(away));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn $this.cbMergeGraphs(geometry,\n\t\t   $this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1]]),\n\t\t   graph\n\t\t);\n\t}\n\n\tModel.Game.cbShipGraph = function(geometry){\n\t\tvar $this=this;\n\n\t\tvar flags = $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tgraph[pos]=[];\n\t\t\t[[-1,-1],[-1,1],[1,-1],[1,1]].forEach(function(delta) { // loop on all 4 diagonals\n\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\tif(pos1!=null) {\n\t\t\t\t\tfor(var dir=1;dir<2;dir++) { // dir=0 for row, dir=1 for column\n\t\t\t\t\t\tvar nbMax = (dir==0) ? lastRow : lastCol;\n\t\t\t\t\t\tvar away=[] // hold the sliding line\n\t\t\t\t\t\tfor(var n=1;n<nbMax;n++) {\n\t\t\t\t\t\t\tvar delta2=[];\n\t\t\t\t\t\t\tdelta2[dir]=delta[dir]*n;\n\t\t\t\t\t\t\tdelta2[1-dir]=0; // delta2 is now only about moving orthogonally, away from the piece\n\t\t\t\t\t\t\tvar pos2=geometry.Graph(pos1,delta2);\n\t\t\t\t\t\t\tif(pos2!=null) {\n\t\t\t\t\t\t\t\tif(n==1) // possible to slide at least 1 cell, make sure the diagonal cell is not occupied, but cannot move to this cell\n\t\t\t\t\t\t\t\t\taway.push(pos1 | $this.cbConstants.FLAG_STOP);\n\t\t\t\t\t\t\t\taway.push(pos2 | flags);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(away.length>0)\n\t\t\t\t\t\t\tgraph[pos].push($this.cbTypedArray(away));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn $this.cbMergeGraphs(geometry,\n\t\t   $this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1]]),\n\t\t   graph\n\t\t);\n\t}\n\n\n\tModel.Game.cbRhinoGraph = function(geometry,confine){\n\t\tvar $this=this;\n\n\t\tvar flags = $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE;\n\t\tvar graph={};\n\t\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\t\tif(confine && !(pos in confine)){\n\t\t\t\tgraph[pos]=[];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar directions=[];\n\t\t\t[[1,2],[2,1],[1,-2],[2,-1],[-1,2],[-2,1],[-1,-2],[-2,-1]].forEach(function(delta) { // loop on all 8 diagonals\n\t\t\t\tvar movedir = [Math.sign(delta[0]),Math.sign(delta[1])];\n\t\t\t\tvar pos1=geometry.Graph(pos,delta);\n\t\t\t\tif(pos1!=null && (!confine || (pos1 in confine))) {\n\t\t\t\t\tvar direction=[pos1 | $this.cbConstants.FLAG_MOVE | $this.cbConstants.FLAG_CAPTURE | $this.cbConstants.FLAG_STOP];\n\t\t\t\t\t//directions.push($this.cbTypedArray(direction));\n\t\t\t\t\tvar nbMax = Math.max(lastRow , lastCol) - 1;\n\t\t\t\t\tvar away=[] // hold the sliding line\n\t\t\t\t\tfor(var n=1;n<nbMax;n++) {\n\t\t\t\t\t\tvar delta2=[movedir[0]*n,movedir[1]*n];\n\t\t\t\t\t\tvar pos2=geometry.Graph(pos1,delta2);\n\t\t\t\t\t\tif(pos2!=null && (!confine || (pos2 in confine))) {\n\t\t\t\t\t\t\tif(n==1) // possible to slide at least 1 cell, make sure the diagonal cell is not occupied, but cannot move to this cell\n\t\t\t\t\t\t\t\taway.push(pos1 | $this.cbConstants.FLAG_STOP);\n\t\t\t\t\t\t\taway.push(pos2 | flags | $this.cbConstants.FLAG_STOP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(away.length>0)\n\t\t\t\t\t\tdirections.push($this.cbTypedArray(away));\n\t\t\t\t}\n\t\t\t});\n\t\t\tgraph[pos]=directions;\n\t\t}\n\n\t\treturn $this.cbMergeGraphs(geometry,\n\t\t   $this.cbShortRangeGraph(geometry,[[1,2],[2,1],[1,-2],[2,-1],[-1,2],[-2,1],[-1,-2],[-2,-1]]),\n\t\t   graph\n\t\t);\n\t}\n\n\tvar confine = {};\n\n\tfor(var pos=0;pos<geometry.boardSize;pos++) {\n\t\tconfine[pos]=1;\n\t}\n\n\tModel.Game.cbDefine = function() {\n\n\t\t// classic chess pieces\n\n\t\tvar piecesTypes = {\n\n\n      0: {\n      name : 'ipawnw',\n      abbrev : '',\n      fenAbbrev: 'P',\n      aspect : 'fr-pawn',\n      graph : this.cbInitialPawnGraph(geometry,1,confine),\n      value : 0.5,\n      initial: [{s:1,p:48},{s:1,p:49},{s:1,p:50},{s:1,p:51},{s:1,p:52},{s:1,p:53},{s:1,p:54},{s:1,p:55},{s:1,p:56},{s:1,p:57},{s:1,p:58},{s:1,p:59},{s:1,p:60},{s:1,p:61},{s:1,p:62},{s:1,p:63}],\n      epCatch : true,\n      epTarget : true,\n      },\n\n      1: {\n      name : 'ipawnb',\n      abbrev : '',\n      fenAbbrev: 'P',\n      aspect : 'fr-pawn',\n      graph : this.cbInitialPawnGraph(geometry,-1,confine),\n      value : 0.5,\n      initial: [{s:-1,p:192},{s:-1,p:193},{s:-1,p:194},{s:-1,p:195},{s:-1,p:196},{s:-1,p:197},{s:-1,p:198},{s:-1,p:199},{s:-1,p:200},{s:-1,p:201},{s:-1,p:202},{s:-1,p:203},{s:-1,p:204},{s:-1,p:205},{s:-1,p:206},{s:-1,p:207}],\n      epCatch : true,\n      epTarget : true,\n      },\n\n      2: {\n      name : 'corporalw',\n      abbrev : 'O',\n      aspect : 'fr-corporal',\n      graph : this.cbCorporalGraph(geometry,1,confine),\n      value : 0.8,\n      initial: [{s:1,p:16},{s:1,p:17},{s:1,p:18},{s:1,p:19},{s:1,p:20},{s:1,p:21},{s:1,p:22},{s:1,p:25},{s:1,p:26},{s:1,p:27},{s:1,p:28},{s:1,p:29},{s:1,p:30},{s:1,p:31}],\n      epCatch : true,\n      epTarget : true,\n      },\n\n      3: {\n      name : 'corporalb',\n      abbrev : 'O',\n      aspect : 'fr-corporal',\n      graph : this.cbCorporalGraph(geometry,-1,confine),\n      value : 0.8,\n      initial: [{s:-1,p:224},{s:-1,p:225},{s:-1,p:226},{s:-1,p:227},{s:-1,p:228},{s:-1,p:229},{s:-1,p:230},{s:-1,p:233},{s:-1,p:234},{s:-1,p:235},{s:-1,p:236},{s:-1,p:237},{s:-1,p:238},{s:-1,p:239}],\n      epCatch : true,\n      epTarget : true,\n      },\n\n      4: {\n      name : 'princew',\n      abbrev : 'I',\n      aspect : 'fr-prince',\n      graph : this.cbPrinceGraph(geometry,1,confine),\n      value : 2.2,\n      initial: [{s:1,p:38},{s:1,p:41}],\n      epTarget : true,\n      },\n\n      5: {\n      name : 'princeb',\n      abbrev : 'I',\n      aspect : 'fr-prince',\n      graph : this.cbPrinceGraph(geometry,-1,confine),\n      value : 2.2,\n      initial: [{s:-1,p:214},{s:-1,p:217}],\n      epTarget : true,\n      },\n\n      6: {\n      name : 'rook',\n      abbrev : 'R',\n      aspect : 'fr-rook',\n      graph : this.cbRookGraph(geometry,confine),\n      value : 5,\n      initial: [{s:1,p:34},{s:1,p:45},{s:-1,p:210},{s:-1,p:221}],\n      },\n\n      7: {\n      name : 'bishop',\n      abbrev : 'B',\n      aspect : 'fr-bishop',\n      graph : this.cbBishopGraph(geometry,confine),\n      value : 3.4,\n      initial: [{s:1,p:36},{s:1,p:43},{s:-1,p:212},{s:-1,p:219}],\n      },\n\n      8: {\n      name : 'knight',\n      abbrev : 'N',\n      aspect : 'fr-knight',\n      graph : this.cbKnightGraph(geometry,confine),\n      value : 2,\n      initial: [{s:1,p:35},{s:1,p:44},{s:-1,p:211},{s:-1,p:220}],\n      },\n\n      9: {\n      name : 'queen',\n      abbrev : 'Q',\n      aspect : 'fr-queen',\n      graph : this.cbQueenGraph(geometry,confine),\n      value : 8.3,\n      initial: [{s:1,p:39},{s:-1,p:215}],\n      },\n\n      10: {\n      name : 'king',\n      abbrev : 'K',\n      aspect : 'fr-king',\n      graph : this.cbKingGraph(geometry,confine),\n      isKing : true,\n      initial: [{s:1,p:40},{s:-1,p:216}],\n      },\n\n      11: {\n      name : 'star',\n      abbrev : 'S',\n      aspect : 'fr-star',\n      graph : this.cbLongRangeGraph(geometry,[[0,-1],[0,1],[-1,0],[1,0],[1,1],[1,-1],[-1,-1],[-1,1]],null,this.cbConstants.FLAG_MOVE | this.cbConstants.FLAG_SCREEN_CAPTURE),\n      value : 8.2,\n      initial: [{s:1,p:7},{s:-1,p:247}],\n      },\n\n      12: {\n      name : 'bow',\n      abbrev : 'W',\n      aspect : 'fr-bow',\n      graph : this.cbLongRangeGraph(geometry,[[-1,-1],[1,1],[-1,1],[1,-1]],null,this.cbConstants.FLAG_MOVE | this.cbConstants.FLAG_SCREEN_CAPTURE),\n      value : 3.3,\n      initial: [{s:1,p:2},{s:1,p:13},{s:-1,p:242},{s:-1,p:253}],\n      },\n\n      13: {\n      name : 'rhino',\n      abbrev : 'U',\n      aspect : 'fr-rhino',\n      graph : this.cbRhinoGraph(geometry,confine),\n      value : 6.1,\n      initial: [{s:1,p:6},{s:-1,p:246}],\n      },\n\n      14: {\n      name : 'bull',\n      abbrev : 'T',\n      aspect : 'fr-bull',\n      graph : this.cbShortRangeGraph(geometry,[\n      \t\t\t\t\t[2,3],[3,2],[2,-3],[3,-2],[-2,3],[-3,2],[-2,-3],[-3,-2]\n      \t\t\t\t\t],confine),\n      value : 1.7,\n      initial: [{s:1,p:3},{s:1,p:12},{s:-1,p:243},{s:-1,p:252}],\n      },\n\n      15: {\n      name : 'antelope',\n      abbrev : 'G',\n      aspect : 'fr-antelope',\n      graph : this.cbShortRangeGraph(geometry,[\n      \t\t\t\t\t[2,2],[3,3],[2,-2],[3,-3],[-2,2],[-3,3],[-2,-2],[-3,-3],\n      \t\t\t\t\t[2,0],[3,0],[-2,0],[-3,0],[0,2],[0,3],[0,-2],[0,-3]\n      \t\t\t\t\t],\n      \t\t\t\t\tconfine),\n      value : 3.7,\n      initial: [{s:1,p:0},{s:1,p:15},{s:-1,p:240},{s:-1,p:255}],\n      },\n\n      16: {\n      name : 'lion',\n      abbrev : 'L',\n      aspect : 'fr-lion',\n      graph : this.cbShortRangeGraph(geometry,[\n      \t\t\t\t\t\t[-1,-1],[-1,1],[1,-1],[1,1],[1,0],[0,1],[-1,0],[0,-1],\n      \t\t\t\t\t\t[-2,0],[-2,-1],[-2,-2],[-1,-2],[0,-2],\n      \t\t\t\t\t\t[1,-2],[2,-2],[2,-1],[2,0],[2,1],\n      \t\t\t\t\t\t[2,2],[1,2],[0,2],[-1,2],[-2,2],[-2,1]\n      \t\t\t\t\t\t], confine),\n      value : 6,\n      initial: [{s:1,p:23},{s:-1,p:231}],\n      },\n\n      17: {\n      name : 'elephant',\n      abbrev : 'E',\n      aspect : 'fr-elephant',\n      graph : this.cbShortRangeGraph(geometry,[[-1,-1],[-1,1],[1,-1],[1,1],[-2,-2],[-2,2],[2,-2],[2,2]],confine),\n      value : 2,\n      initial: [{s:1,p:32},{s:1,p:47},{s:-1,p:208},{s:-1,p:223}],\n      },\n\n      18: {\n      name : 'cannon',\n      abbrev : 'Z',\n      aspect : 'fr-cannon2',\n      graph : this.cbXQCannonGraph(geometry),\n      value : 5,\n      initial: [{s:1,p:4},{s:1,p:11},{s:-1,p:244},{s:-1,p:251}],\n      },\n\n      19: {\n      name : 'machine',\n      abbrev : 'D',\n      aspect : 'fr-machine',\n      graph : this.cbShortRangeGraph(geometry,[[-1,0],[-2,0],[1,0],[2,0],[0,1],[0,2],[0,-1],[0,-2]],confine),\n      value : 2.2,\n      initial: [{s:1,p:33},{s:1,p:46},{s:-1,p:209},{s:-1,p:222}],\n      },\n\n      20: {\n      name : 'buffalo',\n      abbrev : 'F',\n      aspect : 'fr-buffalo',\n      graph : this.cbShortRangeGraph(geometry,[\n      \t\t\t\t\t\t[1,2],[1,3],[2,1],[2,3],[3,1],[3,2],\n      \t\t\t\t\t\t[1,-2],[1,-3],[2,-1],[2,-3],[3,-1],[3,-2],\n      \t\t\t\t\t\t[-1,-2],[-1,-3],[-2,-1],[-2,-3],[-3,-1],[-3,-2],\n      \t\t\t\t\t\t[-1,2],[-1,3],[-2,1],[-2,3],[-3,1],[-3,2]\n      \t\t\t\t\t\t],confine),\n      value : 5.4,\n      initial: [{s:1,p:5},{s:-1,p:245}],\n      },\n\n      21: {\n      name : 'ship',\n      abbrev : 'X',\n      aspect : 'fr-ship',\n      graph : this.cbShipGraph(geometry),\n      value : 4.4,\n      initial: [{s:1,p:37},{s:1,p:42},{s:-1,p:213},{s:-1,p:218}],\n      },\n\n      22: {\n      name : 'eagle',\n      abbrev : 'H',\n      aspect : 'fr-eagle',\n      graph : this.cbEagleGraph(geometry),\n      value : 8.4,\n      initial: [{s:1,p:24},{s:-1,p:232}],\n      },\n\n      23: {\n      name : 'camel',\n      abbrev : 'J',\n      aspect : 'fr-camel',\n      graph : this.cbShortRangeGraph(geometry,[[-3,-1],[-3,1],[3,-1],[3,1],[1,3],[1,-3],[-1,3],[-1,-3]]),\n      value : 2,\n      initial: [{s:1,p:1},{s:1,p:14},{s:-1,p:241},{s:-1,p:254}],\n      },\n\n      24: {\n      name : 'amazon',\n      abbrev : 'A',\n      aspect : 'fr-amazon',\n      graph : this.cbMergeGraphs(geometry,\n      \t\t\t\t\t\tthis.cbKnightGraph(geometry,confine),\n      \t\t\t\t\t\tthis.cbQueenGraph(geometry,confine)),\n      value : 10.2,\n      initial: [{s:1,p:8},{s:-1,p:248}],\n      },\n\n      25: {\n      name : 'marshall',\n      abbrev : 'M',\n      aspect : 'fr-marshall',\n      graph : this.cbMergeGraphs(geometry,\n      \t\t\t\t\t\tthis.cbKnightGraph(geometry,confine),\n      \t\t\t\t\t\tthis.cbRookGraph(geometry,confine)),\n      value : 6.9,\n      initial: [{s:1,p:9},{s:-1,p:249}],\n      },\n\n      26: {\n      name : 'cardinal',\n      abbrev : 'C',\n      aspect : 'fr-cardinal',\n      graph : this.cbMergeGraphs(geometry,\n      \t\t\t\t\t\tthis.cbKnightGraph(geometry,confine),\n      \t\t\t\t\t\tthis.cbBishopGraph(geometry,confine)),\n      value : 5.3,\n      initial: [{s:1,p:10},{s:-1,p:250}],\n      },\n\n\t\t}\n\n\t\t// defining types for readable promo cases\n\t\tvar T_ipawnw=0\n    var T_ipawnb=1\n    var T_corporalw=2\n    var T_corporalb=3\n    var T_princew=4\n    var T_princeb=5\n    var T_rook=6\n    var T_bishop=7\n    var T_knight=8\n    var T_queen=9\n    var T_king=10\n    var T_star=11\n    var T_bow=12\n    var T_rhino=13\n    var T_bull=14\n    var T_antelope=15\n    var T_lion=16\n    var T_elephant=17\n    var T_cannon=18\n    var T_machine=19\n    var T_buffalo=20\n    var T_ship=21\n    var T_eagle=22\n    var T_camel=23\n    var T_amazon=24\n    var T_marshall=25\n    var T_cardinal=26\n\n\t\treturn {\n\n\t\t\tgeometry: geometry,\n\n\t\t\tpieceTypes: piecesTypes,\n\n\t\t\tpromote: function(aGame,piece,move) {\n\t\t\t\t// initial pawns go up to last row where it promotes to Queen\n\t\t\t\tif( ((piece.t==T_ipawnw || piece.t==T_corporalw) && geometry.R(move.t)==lastRow) || ((piece.t==T_ipawnb || piece.t==T_corporalb) && geometry.R(move.t)==firstRow))\n\t\t\t\t\treturn [T_queen];\n\t\t\t\tif (piece.t==T_princew && geometry.R(move.t)==lastRow)\n\t\t\t\t\treturn [T_amazon];\n\t\t\t\tif (piece.t==T_princeb && geometry.R(move.t)==firstRow)\n\t\t\t\t\treturn [T_amazon];\n\t\t\t\tif ((piece.t==T_knight || piece.t==T_camel || piece.t==T_bull) && ((geometry.R(move.t)==lastRow && piece.s > 0) || (geometry.R(move.t)==firstRow && piece.s < 0)) )\n\t\t\t\t\treturn [T_buffalo];\n\t\t\t\tif (piece.t==T_elephant && ((geometry.R(move.t)==lastRow && piece.s > 0) || (geometry.R(move.t)==firstRow && piece.s < 0)) )\n\t\t\t\t\treturn [T_lion];\n\t\t\t\tif (piece.t==T_machine && ((geometry.R(move.t)==lastRow && piece.s > 0) || (geometry.R(move.t)==firstRow && piece.s < 0)) )\n\t\t\t\t\treturn [T_lion];\n\t\t\t\tif (piece.t==T_ship && ((geometry.R(move.t)==lastRow && piece.s > 0) || (geometry.R(move.t)==firstRow && piece.s < 0)) )\n\t\t\t\t\treturn [T_eagle];\n\t\t\t\tif (piece.t==T_antelope && ((geometry.R(move.t)==lastRow && piece.s > 0) || (geometry.R(move.t)==firstRow && piece.s < 0)) )\n\t\t\t\t\treturn [T_star];\n\t\t\t\treturn [];\n\t\t\t},\n\t\t};\n\t}\n\n\tvar SuperModelBoardGenerateMoves=Model.Board.GenerateMoves;\n\tModel.Board.GenerateMoves = function(aGame) {\n\t\tvar $this = this;\n\t\tSuperModelBoardGenerateMoves.apply(this,arguments); // call regular GenerateMoves method\n\t}\n\n\tvar SuperModelBoardApplyMove=Model.Board.ApplyMove;\n\tModel.Board.ApplyMove = function(aGame,move) {\n\t\t// console.log(\"ApplyMove entrance\",aGame,move);\n\t\tvar $this = this;\n\t\tSuperModelBoardApplyMove.apply(this,arguments); // call regular GenerateMoves method\n\t}\n\n})();\n"],"file":"tera-chess-model.js"}